<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<entries>
	<class native="AnimationClip" script="AnimationClip">
		<doc>Contains animation curves for translation/rotation/scale of scene objects/skeleton bones, as well as curves for generic property animation.</doc>
		<ctor>
			<doc>Creates an animation clip with no curves. After creation make sure to register some animation curves before using it.</doc>
			<param name="isAdditive" type="bool">
			</param>
		</ctor>
		<ctor>
			<doc>Creates an animation clip with specified curves.</doc>
			<param name="curves" type="AnimationCurves">
				<doc>Curves to initialize the animation with.</doc>
			</param>
			<param name="isAdditive" type="bool">
				<doc>Determines does the clip contain additive curve data. This will change the behaviour how is the clip blended with other animations.</doc>
			</param>
			<param name="sampleRate" type="int">
				<doc>If animation uses evenly spaced keyframes, number of samples per second. Not relevant if keyframes are unevenly spaced.</doc>
			</param>
			<param name="rootMotion" type="RootMotion">
				<doc>Optional set of curves that can be used for animating the root bone. Not used by the animation system directly but is instead provided to the user for manual evaluation.</doc>
			</param>
		</ctor>
		<property name="Curves" type="AnimationCurves" getter="getCurves" setter="setCurves" static="false">
			<doc>A set of all curves stored in the animation. Returned value will not be updated if the animation clip curves are added or removed, as it is a copy of clip&apos;s internal values.</doc>
		</property>
		<property name="Events" type="AnimationEvent" getter="getEvents" setter="setEvents" static="false">
			<doc>A set of all events to be triggered as the animation is playing.</doc>
		</property>
		<property name="RootMotion" type="RootMotion" getter="getRootMotion" setter="" static="false">
			<doc>Returns a set of curves containing motion of the root bone. This allows the user to evaluate the root bone animation curves manually, instead of through the normal animation process. This property is only available if animation clip was imported with root motion import enabled.</doc>
		</property>
		<property name="HasRootMotion" type="bool" getter="hasRootMotion" setter="" static="false">
			<doc>Checks if animation clip has root motion curves separate from the normal animation curves.</doc>
		</property>
		<property name="IsAddtive" type="bool" getter="isAdditive" setter="" static="false">
			<doc>Checks are the curves contained within the clip additive. Additive clips are intended to be added on top of other clips.</doc>
		</property>
		<property name="Length" type="float" getter="getLength" setter="" static="false">
			<doc>Returns the length of the animation clip, in seconds.</doc>
		</property>
		<property name="SampleRate" type="int" getter="getSampleRate" setter="setSampleRate" static="false">
			<doc>Number of samples per second the animation clip curves were sampled at. This value is not used by the animation clip or curves directly since unevenly spaced keyframes are supported. But it can be of value when determining the original sample rate of an imported animation or similar.</doc>
		</property>
	</class>
	<struct native="VECTOR_FIELD_DESC" script="VectorFieldOptions">
		<doc>Descriptor structure used for initialization of a VectorField.</doc>
		<ctor>
		</ctor>
		<field name="countX" type="int">
			<doc>Number of entries in the vector field along the X axis.</doc>
		</field>
		<field name="countY" type="int">
			<doc>Number of entries in the vector field along the Y axis.</doc>
		</field>
		<field name="countZ" type="int">
			<doc>Number of entries in the vector field along the Z axis.</doc>
		</field>
		<field name="bounds" type="AABox">
			<doc>Spatial bounds of the vector field.</doc>
		</field>
	</struct>
	<class native="CBoxCollider" script="BoxCollider">
		<doc>Collider with box geometry.</doc>
		<property name="Extents" type="Vector3" getter="getExtents" setter="setExtents" static="false">
			<doc>Determines the extents (half size) of the geometry of the box.</doc>
		</property>
		<property name="Center" type="Vector3" getter="getCenter" setter="setCenter" static="false">
			<doc>Determines the position of the box shape, relative to the component&apos;s scene object.</doc>
		</property>
	</class>
	<enum native="IndexType" script="IndexType">
		<doc>Type of mesh indices used, used for determining maximum number of vertices in a mesh.</doc>
		<enumentry native="IT_16BIT" script="Index16">
			<doc>16-bit indices.</doc>
		</enumentry>
		<enumentry native="IT_32BIT" script="Index32">
			<doc>32-bit indices.</doc>
		</enumentry>
	</enum>
	<enum native="EulerAngleOrder" script="EulerAngleOrder">
		<doc>Values that represent in which order are euler angles applied when used in transformations.</doc>
		<enumentry native="XYZ" script="XYZ">
		</enumentry>
		<enumentry native="XZY" script="XZY">
		</enumentry>
		<enumentry native="YXZ" script="YXZ">
		</enumentry>
		<enumentry native="YZX" script="YZX">
		</enumentry>
		<enumentry native="ZXY" script="ZXY">
		</enumentry>
		<enumentry native="ZYX" script="ZYX">
		</enumentry>
	</enum>
	<struct native="BlendClipInfo" script="BlendClipInfo">
		<doc>Represents an animation clip used in 1D blending. Each clip has a position on the number line.</doc>
		<ctor>
		</ctor>
		<field name="clip" type="RRef&lt;AnimationClip&gt;">
		</field>
		<field name="position" type="float">
		</field>
	</struct>
	<struct native="KeyframeRef" script="KeyframeRef">
		<ctor>
		</ctor>
		<ctor>
			<param name="curveIdx" type="int">
			</param>
			<param name="keyIdx" type="int">
			</param>
		</ctor>
		<field name="curveIdx" type="int">
		</field>
		<field name="keyIdx" type="int">
		</field>
	</struct>
	<struct native="Vector3I" script="Vector3I">
		<doc>A three dimensional vector with integer coordinates.</doc>
		<ctor>
		</ctor>
		<ctor>
			<param name="x" type="int">
			</param>
			<param name="y" type="int">
			</param>
			<param name="z" type="int">
			</param>
		</ctor>
		<field name="x" type="int">
		</field>
		<field name="y" type="int">
		</field>
		<field name="z" type="int">
		</field>
	</struct>
	<enum native="LogVerbosity" script="LogVerbosity">
		<doc>Represents verbosity level at which a specific log message will be displayed.</doc>
		<enumentry native="Fatal" script="Fatal">
			<doc>Fatal error happened that application cannot recover from and will crash.</doc>
		</enumentry>
		<enumentry native="Error" script="Error">
			<doc>An error happened that will not result in an immediate crash but may cause serious problems.</doc>
		</enumentry>
		<enumentry native="Warning" script="Warning">
			<doc>Something went wrong but the application will not crash, although invalid behaviour might be observed.</doc>
		</enumentry>
		<enumentry native="Info" script="Info">
			<doc>An informational message will be logged, can be used for debugging and tracing.</doc>
		</enumentry>
		<enumentry native="Log" script="Log">
			<doc>Same as Info, but the message will only be logged to the log file and not any console output.</doc>
		</enumentry>
		<enumentry native="Verbose" script="Verbose">
			<doc>Messages that can provide additional information and warnings, but are too spammy to be displayed under normal circumstances.</doc>
		</enumentry>
		<enumentry native="VeryVerbose" script="VeryVerbose">
			<doc>Same as Verbose, but for even spammier messages.</doc>
		</enumentry>
		<enumentry native="Any" script="Any">
			<doc>Meta-type encompassing all verbosity types. Should not be used for logging directly.</doc>
		</enumentry>
	</enum>
	<class native="Skeleton" script="Skeleton">
		<doc>Contains information about bones required for skeletal animation.</doc>
		<method native="getBoneInfo" script="GetBoneInfo" static="false">
			<doc>Returns information about a bone at the provided index.</doc>
			<param name="boneIdx" type="int">
				<doc>Index of the bone to retrieve information for.</doc>
			</param>
			<returns type="BoneInfo">
				<doc>Information about the bone at the specified index.</doc>
			</returns>
		</method>
		<property name="NumBones" type="int" getter="getNumBones" setter="" static="false">
			<doc>Returns the total number of bones in the skeleton.</doc>
		</property>
	</class>
	<class native="MotionBlurSettings" script="MotionBlurSettings">
		<doc>Settings that control the motion blur effect.</doc>
		<ctor>
		</ctor>
		<property name="Enabled" type="bool" getter="getenabled" setter="setenabled" static="false">
			<doc>Enables or disables the motion blur effect.</doc>
		</property>
		<property name="Domain" type="MotionBlurDomain" getter="getdomain" setter="setdomain" static="false">
			<doc>Determines which parts of the scene will trigger motion blur.</doc>
		</property>
		<property name="Filter" type="MotionBlurFilter" getter="getfilter" setter="setfilter" static="false">
			<doc>Type of filter to use when filtering samples contributing to a blurred pixel.</doc>
		</property>
		<property name="Quality" type="MotionBlurQuality" getter="getquality" setter="setquality" static="false">
			<doc>Determines the number of samples to take during motion blur filtering. Increasing this value will yield higher quality blur at the cost of the performance.</doc>
		</property>
		<property name="MaximumRadius" type="float" getter="getmaximumRadius" setter="setmaximumRadius" static="false">
			<doc>Determines the maximum radius over which the blur samples are allowed to be taken, in percent of the screen width (e.g. with 1% radius, on 1920x1028 resolution the maximum radius in pixels will be 1920 * 0.01 = 20px). This clamps the maximum velocity that can affect the blur, as higher velocities require higher radius. Very high values can adversely affect performance as cache accesses become more random.</doc>
		</property>
	</class>
	<struct native="START_UP_DESC" script="StartUpDesc">
		<doc>Structure containing parameters for starting the application.</doc>
		<ctor>
		</ctor>
		<field name="renderAPI" type="string">
			<doc>Name of the render system plugin to use.</doc>
		</field>
		<field name="renderer" type="string">
			<doc>Name of the renderer plugin to use.</doc>
		</field>
		<field name="physics" type="string">
			<doc>Name of physics plugin to use.</doc>
		</field>
		<field name="audio" type="string">
			<doc>Name of the audio plugin to use.</doc>
		</field>
		<field name="input" type="string">
			<doc>Name of the input plugin to use.</doc>
		</field>
		<field name="physicsCooking" type="bool">
			<doc>True if physics cooking library should be loaded. Cooking is useful for creating collision meshes during development type, but might be unnecessary in the final application. When turned off you can save on space by not shipping the cooking library.</doc>
		</field>
		<field name="asyncAnimation" type="bool">
			<doc>True if animation should be evaluated at the same time while rendering is happening. This introduces a one frame delay to all animations but can result in better performance. If false the animation will be forced to finish evaluating before rendering starts, ensuring up-to-date frame but potentially blocking the rendering thread from moving forward until the animation finishes.</doc>
		</field>
		<field name="primaryWindowDesc" type="RenderWindowDesc">
			<doc>Describes the window to create during start-up.</doc>
		</field>
		<field name="importers" type="string">
			<doc>A list of importer plugins to load.</doc>
		</field>
	</struct>
	<struct native="ColorGradientKey" script="ColorGradientKey">
		<doc>Single key in a ColorGradient.</doc>
		<ctor>
		</ctor>
		<ctor>
			<param name="color" type="Color">
			</param>
			<param name="time" type="float">
			</param>
		</ctor>
		<field name="color" type="Color">
		</field>
		<field name="time" type="float">
		</field>
	</struct>
	<class native="ApplicationEx" script="Application">
		<doc>Script-exported API for Application.</doc>
		<method native="startUp" script="StartUp" static="true">
			<param name="desc" type="StartUpDesc">
			</param>
		</method>
		<method native="startUp" script="StartUp" static="true">
			<param name="videoMode" type="VideoMode">
			</param>
			<param name="title" type="string">
			</param>
			<param name="fullscreen" type="bool">
			</param>
		</method>
		<method native="runMainLoop" script="RunMainLoop" static="true">
		</method>
		<method native="shutDown" script="ShutDown" static="true">
		</method>
	</class>
	<enum native="ProjectionType" script="ProjectionType">
		<doc>Projection type to use by the camera.</doc>
		<enumentry native="PT_ORTHOGRAPHIC" script="Orthographic">
			<doc>Projection type where object size remains constant and parallel lines remain parallel.</doc>
		</enumentry>
		<enumentry native="PT_PERSPECTIVE" script="Perspective">
			<doc>Projection type that emulates human vision. Objects farther away appear smaller.</doc>
		</enumentry>
	</enum>
	<class native="ColorGradient" script="ColorGradient">
		<doc>Represents a range of color values over some parameters, similar to a curve. Internally represented as a set of keys that get interpolated between. Stores colors as 32-bit integers, and is therefor unable to represent a color range outside of [0, 1] - see ColorGradientHDR for an alternative.</doc>
		<ctor>
		</ctor>
		<ctor>
			<param name="color" type="Color">
			</param>
		</ctor>
		<ctor>
			<param name="keys" type="ColorGradientKey">
			</param>
		</ctor>
		<method native="setKeys" script="SetKeys" static="false">
			<doc>Keys that control the gradient, sorted by time from first to last. Key times should be in range [0, 1].</doc>
			<param name="keys" type="ColorGradientKey">
			</param>
			<param name="duration" type="float">
			</param>
		</method>
		<method native="getKeys" script="GetKeys" static="false">
			<doc>Keys that control the gradient, sorted by time from first to last. Key times should be in range [0, 1].</doc>
			<returns type="ColorGradientKey">
			</returns>
		</method>
		<method native="getKey" script="GetKey" static="false">
			<doc>Returns the color key at the specified index. If out of range an empty key is returned.</doc>
			<param name="idx" type="int">
			</param>
			<returns type="ColorGradientKey">
			</returns>
		</method>
		<method native="setConstant" script="SetConstant" static="false">
			<doc>Specify a &quot;gradient&quot; that represents a single color value.</doc>
			<param name="color" type="Color">
			</param>
		</method>
		<method native="evaluate" script="Evaluate" static="false">
			<doc>Evaluates a color at the specified <paramref name="t"/>.</doc>
			<param name="t" type="float">
			</param>
			<returns type="Color">
			</returns>
		</method>
		<property name="NumKeys" type="int" getter="getNumKeys" setter="" static="false">
			<doc>Returns the number of color keys in the gradient.</doc>
		</property>
	</class>
	<struct native="PARTICLE_CIRCLE_SHAPE_DESC" script="ParticleCircleShapeOptions">
		<doc>Information describing a ParticleEmitterCircleShape.</doc>
		<ctor>
		</ctor>
		<field name="radius" type="float">
			<doc>Radius of the circle.</doc>
		</field>
		<field name="thickness" type="float">
			<doc>Proportion of the surface that can emit particles. Thickness of 0 results in particles being emitted only from the edge of the circle, while thickness of 1 results in particles being emitted from the entire surface. In-between values will use a part of the surface.</doc>
		</field>
		<field name="arc" type="Degree">
			<doc>Angular portion of the cone from which to emit particles from, in degrees.</doc>
		</field>
		<field name="mode" type="ParticleEmissionMode">
			<doc>Determines how will particle positions on the shape be generated.</doc>
		</field>
	</struct>
	<enum native="ChromaticAberrationType" script="ChromaticAberrationType">
		<doc>Types of available chromatic aberration effects.</doc>
		<enumentry native="Simple" script="Simple">
			<doc>Simple chromatic aberration effect that is fast to execute.</doc>
		</enumentry>
		<enumentry native="Complex" script="Complex">
			<doc>More complex chromatic aberration effect that takes longer to execute but may yield more visually pleasing results than the simple variant.</doc>
		</enumentry>
	</enum>
	<class native="HString" script="LocString">
		<doc>String handle. Provides a wrapper around an Unicode string, primarily for localization purposes.
Actual value for this string is looked up in a global string table based on the provided identifier string and currently active language. If such value doesn&apos;t exist then the identifier is used as is.
Use {0}, {1}, etc. in the string value for values that might change dynamically.</doc>
		<ctor>
			<doc>Creates a new localized string with the specified identifier. If the identifier doesn&apos;t previously exist in the string table, identifier value will also be used for initializing the default language version of the string.</doc>
			<param name="identifier" type="string">
				<doc>String you can use for later referencing the localized string.</doc>
			</param>
			<param name="stringTableId" type="int">
				<doc>Unique identifier of the string table to retrieve the string from.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new localized string with the specified identifier and sets the default language version of the string. If a string with that identifier already exists default language string will be updated.</doc>
			<param name="identifier" type="string">
				<doc>String you can use for later referencing the localized string.</doc>
			</param>
			<param name="defaultString" type="string">
				<doc>Default string to assign to the specified identifier. Language to which it will be assigned depends on the StringTable::DEFAULT_LANGUAGE value.</doc>
			</param>
			<param name="stringTableId" type="int">
				<doc>Unique identifier of the string table to retrieve the string from.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new empty localized string.</doc>
			<param name="stringTableId" type="int">
				<doc>Unique identifier of the string table to retrieve the string from.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new empty localized string.</doc>
		</ctor>
		<method native="setParameter" script="SetParameter" static="false">
			<doc>Sets a value of a string parameter. Parameters are specified as bracketed values within the string itself (for example {0}, {1}) etc. Use ^ as an escape character.</doc>
			<param name="idx" type="int">
			</param>
			<param name="value" type="string">
			</param>
		</method>
	</class>
	<class native="Random" script="Random">
		<doc>Generates pseudo random numbers using the Xorshift128 algorithm. Suitable for high performance requirements.</doc>
		<ctor>
			<doc>Initializes a new generator using the specified seed.</doc>
			<param name="seed" type="int">
			</param>
		</ctor>
		<method native="setSeed" script="SetSeed" static="false">
			<doc>Changes the seed of the generator to the specified value.</doc>
			<param name="seed" type="int">
			</param>
		</method>
		<method native="get" script="Get" static="false">
			<doc>Returns a random value in range [0, std::numeric_limits&lt;uint32_t&gt;::max()].</doc>
			<returns type="int">
			</returns>
		</method>
		<method native="getRange" script="GetRange" static="false">
			<doc>Returns a random value in range [min, max].</doc>
			<param name="min" type="int">
			</param>
			<param name="max" type="int">
			</param>
			<returns type="int">
			</returns>
		</method>
		<method native="getUNorm" script="GetUNorm" static="false">
			<doc>Returns a random value in range [0, 1].</doc>
			<returns type="float">
			</returns>
		</method>
		<method native="getSNorm" script="GetSNorm" static="false">
			<doc>Returns a random value in range [-1, 1].</doc>
			<returns type="float">
			</returns>
		</method>
		<method native="getUnitVector" script="GetUnitVector" static="false">
			<doc>Returns a random unit vector in three dimensions.</doc>
			<returns type="Vector3">
			</returns>
		</method>
		<method native="getUnitVector2D" script="GetUnitVector2D" static="false">
			<doc>Returns a random unit vector in two dimensions.</doc>
			<returns type="Vector2">
			</returns>
		</method>
		<method native="getPointInSphere" script="GetPointInSphere" static="false">
			<doc>Returns a random point inside a unit sphere.</doc>
			<returns type="Vector3">
			</returns>
		</method>
		<method native="getPointInSphereShell" script="GetPointInSphereShell" static="false">
			<doc>Returns a random point inside the specified range in a sphere shell of unit radius, with the specified thickness, in range [0, 1]. Thickness of 0 will generate points on the sphere surface, while thickness of 1 will generate points within the entire sphere volume. Intermediate values represent the shell, which is a volume between two concentric spheres.</doc>
			<param name="thickness" type="float">
			</param>
			<returns type="Vector3">
			</returns>
		</method>
		<method native="getPointInCircle" script="GetPointInCircle" static="false">
			<doc>Returns a random point inside a unit circle.</doc>
			<returns type="Vector2">
			</returns>
		</method>
		<method native="getPointInCircleShell" script="GetPointInCircleShell" static="false">
			<doc>Returns a random point inside the specified range in a circle shell of unit radius, with the specified thickness, in range [0, 1]. Thickness of 0 will generate points on the circle edge, while thickness of 1 will generate points within the entire circle surface. Intermediate values represent the shell, which is the surface between two concentric circles.</doc>
			<param name="thickness" type="float">
			</param>
			<returns type="Vector2">
			</returns>
		</method>
		<method native="getPointInArc" script="GetPointInArc" static="false">
			<doc>Returns a random point on a unit arc with the specified length (angle). Angle of 360 represents a circle.</doc>
			<param name="angle" type="Degree">
			</param>
			<returns type="Vector2">
			</returns>
		</method>
		<method native="getPointInArcShell" script="GetPointInArcShell" static="false">
			<doc>Returns a random point inside the specified range in an arc shell of unit radius, with the specified length (angle) and thickness in range [0, 1]. Angle of 360 represents a circle shell. Thickness of 0 will generate points on the arc edge, while thickness of 1 will generate points on the entire arc &apos;slice&apos;. Intermediate vlaues represent the shell, which is the surface between two concentric circles.</doc>
			<param name="angle" type="Degree">
			</param>
			<param name="thickness" type="float">
			</param>
			<returns type="Vector2">
			</returns>
		</method>
		<method native="getBarycentric" script="GetBarycentric" static="false">
			<doc>Returns a random set of Barycentric coordinates that may be used for generating random points on a triangle.</doc>
			<returns type="Vector3">
			</returns>
		</method>
	</class>
	<class native="MultiResource" script="MultiResource">
		<doc>Contains a group of resources imported from a single source file.</doc>
		<ctor>
		</ctor>
		<ctor>
			<param name="entries" type="SubResource">
			</param>
		</ctor>
		<property name="Entries" type="SubResource" getter="getentries" setter="setentries" static="false">
		</property>
	</class>
	<class native="ColorGradientHDR" script="ColorGradientHDR">
		<doc>Represents a range of color values over some parameters, similar to a curve. Internally represented as a set of keys that get interpolated between. Capable of representing HDR colors, unlike the normal ColorGradient.</doc>
		<ctor>
		</ctor>
		<ctor>
			<param name="color" type="Color">
			</param>
		</ctor>
		<ctor>
			<param name="keys" type="ColorGradientKey">
			</param>
		</ctor>
		<method native="setKeys" script="SetKeys" static="false">
			<doc>Keys that control the gradient, sorted by time from first to last. Key times should be in range [0, 1].</doc>
			<param name="keys" type="ColorGradientKey">
			</param>
			<param name="duration" type="float">
			</param>
		</method>
		<method native="getKeys" script="GetKeys" static="false">
			<doc>Keys that control the gradient, sorted by time from first to last. Key times should be in range [0, 1].</doc>
			<returns type="ColorGradientKey">
			</returns>
		</method>
		<method native="getKey" script="GetKey" static="false">
			<doc>Returns the color key at the specified index. If out of range an empty key is returned.</doc>
			<param name="idx" type="int">
			</param>
			<returns type="ColorGradientKey">
			</returns>
		</method>
		<method native="setConstant" script="SetConstant" static="false">
			<doc>Specify a &quot;gradient&quot; that represents a single color value.</doc>
			<param name="color" type="Color">
			</param>
		</method>
		<method native="evaluate" script="Evaluate" static="false">
			<doc>Evaluates a color at the specified <paramref name="t"/>.</doc>
			<param name="t" type="float">
			</param>
			<returns type="Color">
			</returns>
		</method>
		<property name="NumKeys" type="int" getter="getNumKeys" setter="" static="false">
			<doc>Returns the number of color keys in the gradient.</doc>
		</property>
	</class>
	<struct native="RENDER_WINDOW_DESC" script="RenderWindowDesc">
		<doc>Structure that is used for initializing a render window.</doc>
		<ctor>
		</ctor>
		<field name="videoMode" type="VideoMode">
			<doc>Output monitor, frame buffer resize and refresh rate.</doc>
		</field>
		<field name="fullscreen" type="bool">
			<doc>Should the window be opened in fullscreen mode.</doc>
		</field>
		<field name="vsync" type="bool">
			<doc>Should the window wait for vertical sync before swapping buffers.</doc>
		</field>
		<field name="vsyncInterval" type="int">
			<doc>Determines how many vsync intervals occur per frame. FPS = refreshRate/interval. Usually 1 when vsync active.</doc>
		</field>
		<field name="hidden" type="bool">
			<doc>Should the window be hidden initially.</doc>
		</field>
		<field name="depthBuffer" type="bool">
			<doc>Should the window be created with a depth/stencil buffer.</doc>
		</field>
		<field name="multisampleCount" type="int">
			<doc>If higher than 1, texture containing multiple samples per pixel is created.</doc>
		</field>
		<field name="multisampleHint" type="string">
			<doc>Hint about what kind of multisampling to use. Render system specific.</doc>
		</field>
		<field name="gamma" type="bool">
			<doc>Should the written color pixels be gamma corrected before write.</doc>
		</field>
		<field name="left" type="int">
			<doc>Window origin on X axis in pixels. -1 == screen center. Relative to monitor provided in videoMode.</doc>
		</field>
		<field name="top" type="int">
			<doc>Window origin on Y axis in pixels. -1 == screen center. Relative to monitor provided in videoMode.</doc>
		</field>
		<field name="title" type="string">
			<doc>Title of the window.</doc>
		</field>
		<field name="showTitleBar" type="bool">
			<doc>Determines if the title-bar should be shown or not.</doc>
		</field>
		<field name="showBorder" type="bool">
			<doc>Determines if the window border should be shown or not.</doc>
		</field>
		<field name="allowResize" type="bool">
			<doc>Determines if the user can resize the window by dragging on the window edges.</doc>
		</field>
		<field name="toolWindow" type="bool">
			<doc>Tool windows have no task bar entry and always remain on top of their parent window.</doc>
		</field>
		<field name="modal" type="bool">
			<doc>When a modal window is open all other windows will be locked until modal window is closed.</doc>
		</field>
		<field name="hideUntilSwap" type="bool">
			<doc>Window will be created as hidden and only be shown when the first framebuffer swap happens.</doc>
		</field>
	</struct>
	<enum native="PropertyDistributionType" script="PropertyDistributionType">
		<doc>Determines type of distribution used by distribution properties.</doc>
		<enumentry native="PDT_Constant" script="Constant">
			<doc>The distribution is a costant value.</doc>
		</enumentry>
		<enumentry native="PDT_RandomRange" script="RandomRange">
			<doc>The distribution is a random value in a specified constant range.</doc>
		</enumentry>
		<enumentry native="PDT_Curve" script="Curve">
			<doc>The distribution is a time-varying value.</doc>
		</enumentry>
		<enumentry native="PDT_RandomCurveRange" script="RandomCurveRange">
			<doc>The distribution is a random value in a specified time-varying range.</doc>
		</enumentry>
	</enum>
	<class native="TAnimationCurve&lt;float&gt;" script="AnimationCurve">
		<doc>Animation spline represented by a set of keyframes, each representing an endpoint of a cubic hermite curve. The spline can be evaluated at any time, and uses caching to speed up multiple sequential evaluations.</doc>
		<ctor>
			<doc>Creates a new animation curve.</doc>
			<param name="keyframes" type="KeyFrame">
				<doc>Keyframes to initialize the curve with. They must be sorted by time.</doc>
			</param>
		</ctor>
		<method native="evaluate" script="Evaluate" static="false">
			<doc>Evaluate the animation curve at the specified time. If evaluating multiple values in a sequential order consider using the cached version of evaluate() for better performance.</doc>
			<param name="time" type="float">
				<doc>%Time to evaluate the curve at.</doc>
			</param>
			<param name="loop" type="bool">
				<doc>If true the curve will loop when it goes past the end or beggining. Otherwise the curve value will be clamped.</doc>
			</param>
			<returns type="float">
				<doc>Interpolated value from the curve at provided time.</doc>
			</returns>
		</method>
		<property name="KeyFrames" type="KeyFrame" getter="getKeyFrames" setter="" static="false">
			<doc>Returns a list of all keyframes in the curve.</doc>
		</property>
	</class>
	<class native="TAnimationCurve&lt;Vector3&gt;" script="Vector3Curve">
		<doc>Animation spline represented by a set of keyframes, each representing an endpoint of a cubic hermite curve. The spline can be evaluated at any time, and uses caching to speed up multiple sequential evaluations.</doc>
		<ctor>
			<doc>Creates a new animation curve.</doc>
			<param name="keyframes" type="KeyFrameVec3">
				<doc>Keyframes to initialize the curve with. They must be sorted by time.</doc>
			</param>
		</ctor>
		<method native="evaluate" script="Evaluate" static="false">
			<doc>Evaluate the animation curve at the specified time. If evaluating multiple values in a sequential order consider using the cached version of evaluate() for better performance.</doc>
			<param name="time" type="float">
				<doc>%Time to evaluate the curve at.</doc>
			</param>
			<param name="loop" type="bool">
				<doc>If true the curve will loop when it goes past the end or beggining. Otherwise the curve value will be clamped.</doc>
			</param>
			<returns type="Vector3">
				<doc>Interpolated value from the curve at provided time.</doc>
			</returns>
		</method>
		<property name="KeyFrames" type="KeyFrameVec3" getter="getKeyFrames" setter="" static="false">
			<doc>Returns a list of all keyframes in the curve.</doc>
		</property>
	</class>
	<class native="TAnimationCurve&lt;Vector2&gt;" script="Vector2Curve">
		<doc>Animation spline represented by a set of keyframes, each representing an endpoint of a cubic hermite curve. The spline can be evaluated at any time, and uses caching to speed up multiple sequential evaluations.</doc>
		<ctor>
			<doc>Creates a new animation curve.</doc>
			<param name="keyframes" type="KeyFrameVec2">
				<doc>Keyframes to initialize the curve with. They must be sorted by time.</doc>
			</param>
		</ctor>
		<method native="evaluate" script="Evaluate" static="false">
			<doc>Evaluate the animation curve at the specified time. If evaluating multiple values in a sequential order consider using the cached version of evaluate() for better performance.</doc>
			<param name="time" type="float">
				<doc>%Time to evaluate the curve at.</doc>
			</param>
			<param name="loop" type="bool">
				<doc>If true the curve will loop when it goes past the end or beggining. Otherwise the curve value will be clamped.</doc>
			</param>
			<returns type="Vector2">
				<doc>Interpolated value from the curve at provided time.</doc>
			</returns>
		</method>
		<property name="KeyFrames" type="KeyFrameVec2" getter="getKeyFrames" setter="" static="false">
			<doc>Returns a list of all keyframes in the curve.</doc>
		</property>
	</class>
	<class native="TAnimationCurve&lt;Quaternion&gt;" script="QuaternionCurve">
		<doc>Animation spline represented by a set of keyframes, each representing an endpoint of a cubic hermite curve. The spline can be evaluated at any time, and uses caching to speed up multiple sequential evaluations.</doc>
		<ctor>
			<doc>Creates a new animation curve.</doc>
			<param name="keyframes" type="KeyFrameQuat">
				<doc>Keyframes to initialize the curve with. They must be sorted by time.</doc>
			</param>
		</ctor>
		<method native="evaluate" script="Evaluate" static="false">
			<doc>Evaluate the animation curve at the specified time. If evaluating multiple values in a sequential order consider using the cached version of evaluate() for better performance.</doc>
			<param name="time" type="float">
				<doc>%Time to evaluate the curve at.</doc>
			</param>
			<param name="loop" type="bool">
				<doc>If true the curve will loop when it goes past the end or beggining. Otherwise the curve value will be clamped.</doc>
			</param>
			<returns type="Quaternion">
				<doc>Interpolated value from the curve at provided time.</doc>
			</returns>
		</method>
		<property name="KeyFrames" type="KeyFrameQuat" getter="getKeyFrames" setter="" static="false">
			<doc>Returns a list of all keyframes in the curve.</doc>
		</property>
	</class>
	<class native="TAnimationCurve&lt;int32_t&gt;" script="IntegerCurve">
		<doc>Animation spline represented by a set of keyframes, each representing an endpoint of a cubic hermite curve. The spline can be evaluated at any time, and uses caching to speed up multiple sequential evaluations.</doc>
		<ctor>
			<doc>Creates a new animation curve.</doc>
			<param name="keyframes" type="KeyFrameInt">
				<doc>Keyframes to initialize the curve with. They must be sorted by time.</doc>
			</param>
		</ctor>
		<method native="evaluate" script="Evaluate" static="false">
			<doc>Evaluate the animation curve at the specified time. If evaluating multiple values in a sequential order consider using the cached version of evaluate() for better performance.</doc>
			<param name="time" type="float">
				<doc>%Time to evaluate the curve at.</doc>
			</param>
			<param name="loop" type="bool">
				<doc>If true the curve will loop when it goes past the end or beggining. Otherwise the curve value will be clamped.</doc>
			</param>
			<returns type="int">
				<doc>Interpolated value from the curve at provided time.</doc>
			</returns>
		</method>
		<property name="KeyFrames" type="KeyFrameInt" getter="getKeyFrames" setter="" static="false">
			<doc>Returns a list of all keyframes in the curve.</doc>
		</property>
	</class>
	<class native="CCamera" script="Camera">
		<doc>Camera determines how is world geometry projected onto a 2D surface. You may position and orient it in space, set options like aspect ratio and field or view and it outputs view and projection matrices required for rendering.</doc>
		<method native="notifyNeedsRedraw" script="NotifyNeedsRedraw" static="false">
			<doc>Notifies a on-demand camera that it should re-draw its contents on the next frame. Ignored for a camera that isn&apos;t on-demand.</doc>
		</method>
		<method native="worldToScreenPoint" script="WorldToScreenPoint" static="false">
			<doc>Converts a point in world space to screen coordinates.</doc>
			<param name="worldPoint" type="Vector3">
				<doc>3D point in world space.</doc>
			</param>
			<returns type="Vector2I">
				<doc>2D point on the render target attached to the camera&apos;s viewport, in pixels.</doc>
			</returns>
		</method>
		<method native="worldToNdcPoint" script="WorldToNdcPoint" static="false">
			<doc>Converts a point in world space to normalized device coordinates.</doc>
			<param name="worldPoint" type="Vector3">
				<doc>3D point in world space.</doc>
			</param>
			<returns type="Vector2">
				<doc>2D point in normalized device coordinates ([-1, 1] range), relative to the camera&apos;s viewport.</doc>
			</returns>
		</method>
		<method native="worldToViewPoint" script="WorldToViewPoint" static="false">
			<doc>Converts a point in world space to view space coordinates.</doc>
			<param name="worldPoint" type="Vector3">
				<doc>3D point in world space.</doc>
			</param>
			<returns type="Vector3">
				<doc>3D point relative to the camera&apos;s coordinate system.</doc>
			</returns>
		</method>
		<method native="screenToWorldPoint" script="ScreenToWorldPoint" static="false">
			<doc>Converts a point in screen space to a point in world space.</doc>
			<param name="screenPoint" type="Vector2I">
				<doc>2D point on the render target attached to the camera&apos;s viewport, in pixels.</doc>
			</param>
			<param name="depth" type="float">
				<doc>Depth to place the world point at, in world coordinates. The depth is applied to the vector going from camera origin to the point on the near plane.</doc>
			</param>
			<returns type="Vector3">
				<doc>3D point in world space.</doc>
			</returns>
		</method>
		<method native="screenToViewPoint" script="ScreenToViewPoint" static="false">
			<doc>Converts a point in screen space to a point in view space.</doc>
			<param name="screenPoint" type="Vector2I">
				<doc>2D point on the render target attached to the camera&apos;s viewport, in pixels.</doc>
			</param>
			<param name="depth" type="float">
				<doc>Depth to place the world point at, in device depth. The depth is applied to the vector going from camera origin to the point on the near plane.</doc>
			</param>
			<returns type="Vector3">
				<doc>3D point relative to the camera&apos;s coordinate system.</doc>
			</returns>
		</method>
		<method native="screenToNdcPoint" script="ScreenToNdcPoint" static="false">
			<doc>Converts a point in screen space to normalized device coordinates.</doc>
			<param name="screenPoint" type="Vector2I">
				<doc>2D point on the render target attached to the camera&apos;s viewport, in pixels.</doc>
			</param>
			<returns type="Vector2">
				<doc>2D point in normalized device coordinates ([-1, 1] range), relative to the camera&apos;s viewport.</doc>
			</returns>
		</method>
		<method native="viewToWorldPoint" script="ViewToWorldPoint" static="false">
			<doc>Converts a point in view space to world space.</doc>
			<param name="viewPoint" type="Vector3">
				<doc>3D point relative to the camera&apos;s coordinate system.</doc>
			</param>
			<returns type="Vector3">
				<doc>3D point in world space.</doc>
			</returns>
		</method>
		<method native="viewToScreenPoint" script="ViewToScreenPoint" static="false">
			<doc>Converts a point in view space to screen space.</doc>
			<param name="viewPoint" type="Vector3">
				<doc>3D point relative to the camera&apos;s coordinate system.</doc>
			</param>
			<returns type="Vector2I">
				<doc>2D point on the render target attached to the camera&apos;s viewport, in pixels.</doc>
			</returns>
		</method>
		<method native="viewToNdcPoint" script="ViewToNdcPoint" static="false">
			<doc>Converts a point in view space to normalized device coordinates.</doc>
			<param name="viewPoint" type="Vector3">
				<doc>3D point relative to the camera&apos;s coordinate system.</doc>
			</param>
			<returns type="Vector2">
				<doc>2D point in normalized device coordinates ([-1, 1] range), relative to the camera&apos;s viewport.</doc>
			</returns>
		</method>
		<method native="ndcToWorldPoint" script="NdcToWorldPoint" static="false">
			<doc>Converts a point in normalized device coordinates to world space.</doc>
			<param name="ndcPoint" type="Vector2">
				<doc>2D point in normalized device coordinates ([-1, 1] range), relative to the camera&apos;s viewport.</doc>
			</param>
			<param name="depth" type="float">
				<doc>Depth to place the world point at. The depth is applied to the vector going from camera origin to the point on the near plane.</doc>
			</param>
			<returns type="Vector3">
				<doc>3D point in world space.</doc>
			</returns>
		</method>
		<method native="ndcToViewPoint" script="NdcToViewPoint" static="false">
			<doc>Converts a point in normalized device coordinates to view space.</doc>
			<param name="ndcPoint" type="Vector2">
				<doc>2D point in normalized device coordinates ([-1, 1] range), relative to the camera&apos;s viewport.</doc>
			</param>
			<param name="depth" type="float">
				<doc>Depth to place the world point at. The depth is applied to the vector going from camera origin to the point on the near plane.</doc>
			</param>
			<returns type="Vector3">
				<doc>3D point relative to the camera&apos;s coordinate system.</doc>
			</returns>
		</method>
		<method native="ndcToScreenPoint" script="NdcToScreenPoint" static="false">
			<doc>Converts a point in normalized device coordinates to screen space.</doc>
			<param name="ndcPoint" type="Vector2">
				<doc>2D point in normalized device coordinates ([-1, 1] range), relative to the camera&apos;s viewport.</doc>
			</param>
			<returns type="Vector2I">
				<doc>2D point on the render target attached to the camera&apos;s viewport, in pixels.</doc>
			</returns>
		</method>
		<method native="screenPointToRay" script="ScreenPointToRay" static="false">
			<doc>Converts a point in screen space to a ray in world space.</doc>
			<param name="screenPoint" type="Vector2I">
				<doc>2D point on the render target attached to the camera&apos;s viewport, in pixels.</doc>
			</param>
			<returns type="Ray">
				<doc>Ray in world space, originating at the selected point on the camera near plane.</doc>
			</returns>
		</method>
		<method native="projectPoint" script="ProjectPoint" static="false">
			<doc>Projects a point in view space to normalized device coordinates. Similar to viewToNdcPoint() but preserves the depth component.</doc>
			<param name="point" type="Vector3">
				<doc>3D point relative to the camera&apos;s coordinate system.</doc>
			</param>
			<returns type="Vector3">
				<doc>3D point in normalized device coordinates ([-1, 1] range), relative to the camera&apos;s viewport. Z value range depends on active render API.</doc>
			</returns>
		</method>
		<method native="unprojectPoint" script="UnprojectPoint" static="false">
			<doc>Un-projects a point in normalized device space to view space.</doc>
			<param name="point" type="Vector3">
				<doc>3D point in normalized device coordinates ([-1, 1] range), relative to the camera&apos;s viewport. Z value range depends on active render API.</doc>
			</param>
			<returns type="Vector3">
				<doc>3D point relative to the camera&apos;s coordinate system.</doc>
			</returns>
		</method>
		<property name="Flags" type="CameraFlag" getter="getFlags" setter="setFlags" static="false">
			<doc>Determines flags used for controlling the camera behaviour.</doc>
		</property>
		<property name="Viewport" type="Viewport" getter="getViewport" setter="" static="false">
			<doc>Returns the viewport used by the camera.</doc>
		</property>
		<property name="FieldOfView" type="Radian" getter="getHorzFOV" setter="setHorzFOV" static="false">
			<doc>Determines the camera horizontal field of view. This determines how wide the camera viewing angle is along the horizontal axis. Vertical FOV is calculated from the horizontal FOV and the aspect ratio.</doc>
		</property>
		<property name="NearClipPlane" type="float" getter="getNearClipDistance" setter="setNearClipDistance" static="false">
			<doc>Determines the distance from the frustum to the near clipping plane. Anything closer than the near clipping plane will not be rendered. Decreasing this value decreases depth buffer precision.</doc>
		</property>
		<property name="FarClipPlane" type="float" getter="getFarClipDistance" setter="setFarClipDistance" static="false">
			<doc>Determines the distance from the frustum to the far clipping plane. Anything farther than the far clipping plane will not be rendered. Increasing this value decreases depth buffer precision.</doc>
		</property>
		<property name="AspectRatio" type="float" getter="getAspectRatio" setter="setAspectRatio" static="false">
			<doc>Determines the current viewport aspect ratio (width / height).</doc>
		</property>
		<property name="ProjMatrix" type="Matrix4" getter="getProjectionMatrixRS" setter="" static="false">
			<doc>Returns the standard projection matrix that determines how are 3D points projected to two dimensions. The layout of this matrix depends on currently used render system.</doc>
		</property>
		<property name="ViewMatrix" type="Matrix4" getter="getViewMatrix" setter="" static="false">
			<doc>Gets the camera view matrix. Used for positioning/orienting the camera.</doc>
		</property>
		<property name="ProjectionType" type="ProjectionType" getter="getProjectionType" setter="setProjectionType" static="false">
			<doc>Determines the type of projection used by the camera. Projection type controls how is 3D geometry projected onto a 2D plane.</doc>
		</property>
		<property name="OrthoHeight" type="float" getter="getOrthoWindowHeight" setter="setOrthoWindowHeight" static="false">
			<doc>Determines the orthographic window height, for use with orthographic rendering only. The width of the window will be calculated from the aspect ratio. Value is specified in world units.</doc>
		</property>
		<property name="OrthoWidth" type="float" getter="getOrthoWindowWidth" setter="setOrthoWindowWidth" static="false">
			<doc>Determines the orthographic window width, for use with orthographic rendering only. The height of the window will be calculated from the aspect ratio. Value is specified in world units.</doc>
		</property>
		<property name="Priority" type="int" getter="getPriority" setter="setPriority" static="false">
			<doc>Determines a priority that determines in which orders the cameras are rendered. This only applies to cameras rendering to the same render target. Higher value means the camera will be rendered sooner.</doc>
		</property>
		<property name="Layers" type="ulong" getter="getLayers" setter="setLayers" static="false">
			<doc>Determines layer bitfield that is used when determining which object should the camera render.</doc>
		</property>
		<property name="SampleCount" type="int" getter="getMSAACount" setter="setMSAACount" static="false">
			<doc>Determines number of samples to use when rendering to this camera. Values larger than 1 will enable MSAA rendering.</doc>
		</property>
		<property name="RenderSettings" type="RenderSettings" getter="getRenderSettings" setter="setRenderSettings" static="false">
			<doc>Settings that control rendering for this view. They determine how will the renderer process this view, which effects will be enabled, and what properties will those effects use.</doc>
		</property>
		<property name="Main" type="bool" getter="isMain" setter="setMain" static="false">
			<doc>Determines whether this is the main application camera. Main camera controls the final render surface that is displayed to the user.</doc>
		</property>
	</class>
	<class native="AmbientOcclusionSettings" script="AmbientOcclusionSettings">
		<doc>Settings that control screen space ambient occlusion.</doc>
		<ctor>
		</ctor>
		<property name="Enabled" type="bool" getter="getenabled" setter="setenabled" static="false">
			<doc>Enables or disables the screen space ambient occlusion effect.</doc>
		</property>
		<property name="Radius" type="float" getter="getradius" setter="setradius" static="false">
			<doc>Radius (in world space, in meters) over which occluders are searched for. Smaller radius ensures better sampling precision but can miss occluders. Larger radius ensures far away occluders are considered but can yield lower quality or noise because of low sampling precision. Usually best to keep at around a meter, valid range is roughly [0.05, 5.0].</doc>
		</property>
		<property name="Bias" type="float" getter="getbias" setter="setbias" static="false">
			<doc>Bias used to reduce false occlusion artifacts. Higher values reduce the amount of artifacts but will cause details to be lost in areas where occlusion isn&apos;t high. Value is in millimeters. Usually best to keep at a few dozen millimeters, valid range is roughly [0, 200].</doc>
		</property>
		<property name="FadeDistance" type="float" getter="getfadeDistance" setter="setfadeDistance" static="false">
			<doc>Distance (in view space, in meters) after which AO starts fading out. The fade process will happen over the range as specified by <see cref="fadeRange"/>.</doc>
		</property>
		<property name="FadeRange" type="float" getter="getfadeRange" setter="setfadeRange" static="false">
			<doc>Range (in view space, in meters) in which AO fades out from 100% to 0%. AO starts fading out after the distance specified in <see cref="fadeDistance"/>.</doc>
		</property>
		<property name="Intensity" type="float" getter="getintensity" setter="setintensity" static="false">
			<doc>Linearly scales the intensity of the AO effect. Values less than 1 make the AO effect less pronounced, and vice versa. Valid range is roughly [0.2, 2].</doc>
		</property>
		<property name="Power" type="float" getter="getpower" setter="setpower" static="false">
			<doc>Controls how quickly does the AO darkening effect increase with higher occlusion percent. This is a non-linear control and will cause the darkening to ramp up exponentially. Valid range is roughly [1, 4], where 1 means no extra darkening will occur.</doc>
		</property>
		<property name="Quality" type="int" getter="getquality" setter="setquality" static="false">
			<doc>Quality level of generated ambient occlusion. In range [0, 4]. Higher levels yield higher quality AO at the cost of performance.</doc>
		</property>
	</class>
	<struct native="Vector4I" script="Vector4I">
		<doc>A four dimensional vector with integer coordinates.</doc>
		<ctor>
		</ctor>
		<ctor>
			<param name="x" type="int">
			</param>
			<param name="y" type="int">
			</param>
			<param name="z" type="int">
			</param>
			<param name="w" type="int">
			</param>
		</ctor>
		<field name="x" type="int">
		</field>
		<field name="y" type="int">
		</field>
		<field name="z" type="int">
		</field>
		<field name="w" type="int">
		</field>
	</struct>
	<enum native="DrawOperationType" script="MeshTopology">
		<doc>Describes operation that will be used for rendering a certain set of vertices.</doc>
		<enumentry native="DOT_POINT_LIST" script="PointList">
			<doc>Each vertex represents a point.</doc>
		</enumentry>
		<enumentry native="DOT_LINE_LIST" script="LineList">
			<doc>Each sequential pair of vertices represent a line.</doc>
		</enumentry>
		<enumentry native="DOT_LINE_STRIP" script="LineStrip">
			<doc>Each vertex (except the first) forms a line with the previous vertex.</doc>
		</enumentry>
		<enumentry native="DOT_TRIANGLE_LIST" script="TriangleList">
			<doc>Each sequential 3-tuple of vertices represent a triangle.</doc>
		</enumentry>
		<enumentry native="DOT_TRIANGLE_STRIP" script="TriangleStrip">
			<doc>Each vertex (except the first two) form a triangle with the previous two vertices.</doc>
		</enumentry>
		<enumentry native="DOT_TRIANGLE_FAN" script="TriangleFan">
			<doc>Each vertex (except the first two) form a triangle with the first vertex and previous vertex.</doc>
		</enumentry>
	</enum>
	<class native="CAudioListener" script="AudioListener">
		<doc>Represents a listener that hears audio sources. For spatial audio the volume and pitch of played audio is determined by the distance, orientation and velocity differences between the source and the listener.</doc>
	</class>
	<class native="Mesh" script="Mesh">
		<doc>Primary class for holding geometry. Stores data in the form of vertex buffers and optionally an index buffer, which may be bound to the pipeline for drawing. May contain multiple sub-meshes.</doc>
		<ctor>
			<doc>Creates a new mesh with enough space to hold the a number of primitives using the specified layout. All indices will be part of a single sub-mesh.</doc>
			<param name="numVertices" type="int">
				<doc>Number of vertices in the mesh.</doc>
			</param>
			<param name="numIndices" type="int">
				<doc>Number of indices in the mesh. Must be a multiple of primitive size as specified by provided topology.</doc>
			</param>
			<param name="topology" type="MeshTopology">
				<doc>Determines how should the provided indices be interpreted by the pipeline. Default option is a triangle list, where three indices represent a single triangle.</doc>
			</param>
			<param name="usage" type="MeshUsage">
				<doc>Optimizes performance depending on planned usage of the mesh.</doc>
			</param>
			<param name="vertex" type="VertexLayout">
				<doc>Controls how are vertices organized in the vertex buffer and what data they contain.</doc>
			</param>
			<param name="index" type="IndexType">
				<doc>Size of indices, use smaller size for better performance, however be careful not to go over the number of vertices limited by the data type size.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new mesh with enough space to hold the a number of primitives using the specified layout. Indices can be referenced by multiple sub-meshes.</doc>
			<param name="numVertices" type="int">
				<doc>Number of vertices in the mesh.</doc>
			</param>
			<param name="numIndices" type="int">
				<doc>Number of indices in the mesh. Must be a multiple of primitive size as specified by provided topology.</doc>
			</param>
			<param name="subMeshes" type="SubMesh">
				<doc>Defines how are indices separated into sub-meshes, and how are those sub-meshes rendered. Sub-meshes may be rendered independently, each with a different material.</doc>
			</param>
			<param name="usage" type="MeshUsage">
				<doc>Optimizes performance depending on planned usage of the mesh.</doc>
			</param>
			<param name="vertex" type="VertexLayout">
				<doc>Controls how are vertices organized in the vertex buffer and what data they contain.</doc>
			</param>
			<param name="index" type="IndexType">
				<doc>Size of indices, use smaller size for better performance, however be careful not to go over the number of vertices limited by the data type size.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new mesh from an existing mesh data. Created mesh will match the vertex and index buffers described by the mesh data exactly. Mesh will have no sub-meshes.</doc>
			<param name="data" type="MeshData">
				<doc>Vertex and index data to initialize the mesh with.</doc>
			</param>
			<param name="topology" type="MeshTopology">
				<doc>Determines how should the provided indices be interpreted by the pipeline. Default option is a triangle list, where three indices represent a single triangle.</doc>
			</param>
			<param name="usage" type="MeshUsage">
				<doc>Optimizes performance depending on planned usage of the mesh.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new mesh with enough space to hold the a number of primitives using the specified layout. Indices can be referenced by multiple sub-meshes.</doc>
			<param name="data" type="MeshData">
				<doc>Vertex and index data to initialize the mesh with.</doc>
			</param>
			<param name="subMeshes" type="SubMesh">
				<doc>Defines how are indices separated into sub-meshes, and how are those sub-meshes rendered. Sub-meshes may be rendered independently, each with a different material.</doc>
			</param>
			<param name="usage" type="MeshUsage">
				<doc>Optimizes performance depending on planned usage of the mesh.</doc>
			</param>
		</ctor>
		<property name="Skeleton" type="Skeleton" getter="getSkeleton" setter="" static="false">
			<doc>Gets the skeleton required for animation of this mesh, if any is available.</doc>
		</property>
		<property name="MorphShapes" type="MorphShapes" getter="getMorphShapes" setter="" static="false">
			<doc>Returns an object containing all shapes used for morph animation, if any are available.</doc>
		</property>
		<property name="SubMeshes" type="SubMesh" getter="getSubMeshes" setter="" static="false">
			<doc>Returns all sub-meshes contained in the mesh.</doc>
		</property>
		<property name="SubMeshCount" type="int" getter="getSubMeshCount" setter="" static="false">
			<doc>Returns the number of sub-meshes contained in this mesh.</doc>
		</property>
		<property name="MeshData" type="MeshData" getter="getMeshData" setter="setMeshData" static="false">
			<doc>Accesses the vertex and index data of the mesh. If reading, mesh must have been created with the MeshUsage::CPUCached flag. If writing the caller must ensure the data matches mesh&apos;s vertex/index counts, vertex layout and index format.</doc>
		</property>
	</class>
	<class native="ParticleEvolver" script="ParticleEvolver">
		<doc>Updates properties of all active particles in a particle system in some way.</doc>
	</class>
	<enum native="ClearFlagBits" script="ClearFlags">
		<doc>Flags that determine which portion of the viewport to clear.</doc>
		<enumentry native="Empty" script="Empty">
		</enumentry>
		<enumentry native="Color" script="Color">
		</enumentry>
		<enumentry native="Depth" script="Depth">
		</enumentry>
		<enumentry native="Stencil" script="Stencil">
		</enumentry>
	</enum>
	<class native="RenderTexture" script="RenderTexture">
		<doc>Render target specialization that allows you to render into one or multiple textures. Such textures can then be used in other operations as GPU program input.</doc>
		<ctor>
			<doc>Creates a new 2D render texture.</doc>
			<param name="format" type="PixelFormat">
				<doc>Pixel format of the texture. Format must be a valid uncompressed color format.</doc>
			</param>
			<param name="width" type="int">
				<doc>Width of the texture in pixels.</doc>
			</param>
			<param name="height" type="int">
				<doc>Height of the texture in pixels.</doc>
			</param>
			<param name="numSamples" type="int">
				<doc>Number of samples contained per pixel.</doc>
			</param>
			<param name="gammaCorrection" type="bool">
				<doc>Determines should the pixels written on the texture be gamma corrected.</doc>
			</param>
			<param name="createDepth" type="bool">
				<doc>Should the render texture also contain a depth/stencil buffer.</doc>
			</param>
			<param name="depthStencilFormat" type="PixelFormat">
				<doc>Format of the depth/stencil buffer, if <paramref name="createDepth"/> is enabled. Format must be a valid depth/stencil format.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new 2D render texture using an existing color texture, and no depth-stencil texture.</doc>
			<param name="colorSurface" type="Texture">
				<doc>Color texture to render color data to.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new 2D render texture using existing textures as render destinations.</doc>
			<param name="colorSurface" type="Texture">
				<doc>Color texture to render color data to.</doc>
			</param>
			<param name="depthStencilSurface" type="Texture">
				<doc>Optional depth/stencil texture to render depth/stencil data to.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new 2D render texture using one or multiple color textures and no depth-stencil texture.</doc>
			<param name="colorSurface" type="Texture">
				<doc>Color texture(s) to render color data to.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new 2D render texture using one or multiple color textures and a depth/stencil texture.</doc>
			<param name="colorSurface" type="Texture">
				<doc>Color texture(s) to render color data to.</doc>
			</param>
			<param name="depthStencilSurface" type="Texture">
				<doc>Optional depth/stencil texture to render depth/stencil data to.</doc>
			</param>
		</ctor>
		<property name="ColorSurface" type="Texture" getter="getColorSurface" setter="" static="false">
			<doc>Returns the primary color surface that contains rendered color data.</doc>
		</property>
		<property name="ColorSurfaces" type="Texture" getter="getColorSurfaces" setter="" static="false">
			<doc>Returns all the color surfaces.</doc>
		</property>
		<property name="DepthStencilSurface" type="Texture" getter="getDepthStencilSurface" setter="" static="false">
			<doc>Returns the depth/stencil surface that contains rendered depth and stencil data.</doc>
		</property>
	</class>
	<enum native="TextureType" script="TextureType">
		<doc>Available texture types.</doc>
		<enumentry native="TEX_TYPE_1D" script="Texture1D">
			<doc>One dimensional texture. Just a row of pixels.</doc>
		</enumentry>
		<enumentry native="TEX_TYPE_2D" script="Texture2D">
			<doc>Two dimensional texture.</doc>
		</enumentry>
		<enumentry native="TEX_TYPE_3D" script="Texture3D">
			<doc>Three dimensional texture.</doc>
		</enumentry>
		<enumentry native="TEX_TYPE_CUBE_MAP" script="TextureCube">
			<doc>Texture consisting out of six 2D textures describing an inside of a cube. Allows special sampling.</doc>
		</enumentry>
	</enum>
	<enum native="PhysicsMeshType" script="PhysicsMeshType">
		<doc>Valid types of a mesh used for physics.</doc>
		<enumentry native="Triangle" script="Triangle">
			<doc>A regular triangle mesh. Mesh can be of arbitrary size but cannot be used for triggers and non-kinematic objects. Incurrs a significantly larger performance impact than convex meshes.</doc>
		</enumentry>
		<enumentry native="Convex" script="Convex">
			<doc>Mesh representing a convex shape. Mesh will not have more than 256 vertices. Incurrs a significantly lower performance impact than triangle meshes.</doc>
		</enumentry>
	</enum>
	<enum native="PointForceMode" script="PointForceMode">
		<doc>Type of force that can be applied to a rigidbody at an arbitrary point.</doc>
		<enumentry native="Force" script="Force">
			<doc>Value applied is a force.</doc>
		</enumentry>
		<enumentry native="Impulse" script="Impulse">
			<doc>Value applied is an impulse (a direct change in its linear or angular momentum).</doc>
		</enumentry>
	</enum>
	<enum native="CubemapSourceType" script="CubemapSourceType">
		<doc>Determines the type of the source image for generating cubemaps.</doc>
		<enumentry native="Single" script="Single">
			<doc>Source is a single image that will be replicated on all cubemap faces.</doc>
		</enumentry>
		<enumentry native="Faces" script="Faces">
			<doc>Source is a list of 6 images, either sequentially next to each other or in a cross format. The system will automatically guess the layout and orientation based on the aspect ratio.</doc>
		</enumentry>
		<enumentry native="Spherical" script="Spherical">
			<doc>Source is a single spherical panoramic image.</doc>
		</enumentry>
		<enumentry native="Cylindrical" script="Cylindrical">
			<doc>Source is a single cylindrical panoramic image.</doc>
		</enumentry>
	</enum>
	<class native="ImportOptions" script="ImportOptions">
		<doc>Base class for creating import options from. Import options are specific for each importer and control how is data imported.</doc>
	</class>
	<class native="ParticleEmitterStaticMeshShape" script="ParticleEmitterStaticMeshShape">
		<doc>Particle emitter shape that emits particles from a surface of a static (non-animated) mesh. Particles can be emitted from mesh vertices, edges or triangles. If information about normals exists, particles will also inherit the normals.</doc>
		<ctor>
			<doc>Creates a new particle emitter static mesh shape.</doc>
			<param name="desc" type="ParticleStaticMeshShapeOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle emitter static mesh shape.</doc>
		</ctor>
		<property name="Options" type="ParticleStaticMeshShapeOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the shape.</doc>
		</property>
	</class>
	<struct native="PixelVolume" script="PixelVolume">
		<doc>Represents a 3D region of pixels used for referencing pixel data.</doc>
		<ctor>
		</ctor>
		<ctor>
			<param name="left" type="int">
			</param>
			<param name="top" type="int">
			</param>
			<param name="right" type="int">
			</param>
			<param name="bottom" type="int">
			</param>
		</ctor>
		<ctor>
			<param name="left" type="int">
			</param>
			<param name="top" type="int">
			</param>
			<param name="front" type="int">
			</param>
			<param name="right" type="int">
			</param>
			<param name="bottom" type="int">
			</param>
			<param name="back" type="int">
			</param>
		</ctor>
		<field name="left" type="int">
		</field>
		<field name="top" type="int">
		</field>
		<field name="right" type="int">
		</field>
		<field name="bottom" type="int">
		</field>
		<field name="front" type="int">
		</field>
		<field name="back" type="int">
		</field>
	</struct>
	<class native="CCharacterController" script="CharacterController">
		<doc>Special physics controller meant to be used for game characters. Uses the &quot;slide-and-collide&quot; physics instead of of the standard physics model to handle various issues with manually moving kinematic objects. Uses a capsule to represent the character&apos;s bounds.</doc>
		<method native="move" script="Move" static="false">
			<doc>Moves the controller in the specified direction by the specified amount, while interacting with surrounding geometry. Returns flags signaling where collision occurred after the movement.
Does not account for gravity, you must apply it manually.</doc>
			<param name="displacement" type="Vector3">
			</param>
			<returns type="CharacterCollisionFlag">
			</returns>
		</method>
		<property name="FootPosition" type="Vector3" getter="getFootPosition" setter="setFootPosition" static="false">
			<doc>Determines the position of the bottom of the controller. Position takes contact offset into account. Changing this will teleport the character to the location. Use move() for movement that includes physics.</doc>
		</property>
		<property name="Radius" type="float" getter="getRadius" setter="setRadius" static="false">
			<doc>Determines the radius of the controller capsule.</doc>
		</property>
		<property name="Height" type="float" getter="getHeight" setter="setHeight" static="false">
			<doc>Determines the height between the centers of the two spheres of the controller capsule.</doc>
		</property>
		<property name="Up" type="Vector3" getter="getUp" setter="setUp" static="false">
			<doc>Determines the up direction of capsule. Determines capsule orientation.</doc>
		</property>
		<property name="ClimbingMode" type="CharacterClimbingMode" getter="getClimbingMode" setter="setClimbingMode" static="false">
			<doc>Controls what happens when character encounters a height higher than its step offset.</doc>
		</property>
		<property name="NonWalkableMode" type="CharacterNonWalkableMode" getter="getNonWalkableMode" setter="setNonWalkableMode" static="false">
			<doc>Controls what happens when character encounters a slope higher than its slope offset.</doc>
		</property>
		<property name="MinMoveDistance" type="float" getter="getMinMoveDistance" setter="setMinMoveDistance" static="false">
			<doc>Represents minimum distance that the character will move during a call to move(). This is used to stop the recursive motion algorithm when the remaining distance is too small.</doc>
		</property>
		<property name="ContactOffset" type="float" getter="getContactOffset" setter="setContactOffset" static="false">
			<doc>Contact offset specifies a skin around the object within which contacts will be generated. It should be a small positive non-zero value.</doc>
		</property>
		<property name="StepOffset" type="float" getter="getStepOffset" setter="setStepOffset" static="false">
			<doc>Controls which obstacles will the character be able to automatically step over without being stopped. This is the height of the maximum obstacle that will be stepped over (with exceptions, see climbingMode).</doc>
		</property>
		<property name="SlopeLimit" type="Radian" getter="getSlopeLimit" setter="setSlopeLimit" static="false">
			<doc>Controls which slopes should the character consider too steep and won&apos;t be able to move over. See nonWalkableMode for more information.</doc>
		</property>
		<property name="Layer" type="ulong" getter="getLayer" setter="setLayer" static="false">
			<doc>Determines the layer that controls what can the controller collide with.</doc>
		</property>
		<event native="onColliderHit" script="OnColliderHit" static="false">
			<doc>Triggered when the controller hits a collider.</doc>
			<param name="p0" type="ControllerColliderCollision">
			</param>
		</event>
		<event native="onControllerHit" script="OnControllerHit" static="false">
			<doc>Triggered when the controller hits another character controller.</doc>
			<param name="p0" type="ControllerControllerCollision">
			</param>
		</event>
	</class>
	<class native="BloomSettings" script="BloomSettings">
		<doc>Settings that control the bloom effect. Bloom adds an extra highlight to bright areas of the scene.</doc>
		<ctor>
		</ctor>
		<property name="Enabled" type="bool" getter="getenabled" setter="setenabled" static="false">
			<doc>Enables or disables the bloom effect.</doc>
		</property>
		<property name="Quality" type="int" getter="getquality" setter="setquality" static="false">
			<doc>Quality of the bloom effect. Higher values will use higher resolution texture for calculating bloom, at the cost of lower performance. Valid range is [0, 3], default is 2.</doc>
		</property>
		<property name="Threshold" type="float" getter="getthreshold" setter="setthreshold" static="false">
			<doc>Determines the minimal threshold of pixel luminance to be included in the bloom calculations. Any pixel with luminance below this value will be ignored for the purposes of bloom. The value represents luminance after it is scaled by exposure. Set to zero or negative to disable the threshold and include all pixels in the calculations.</doc>
		</property>
		<property name="Intensity" type="float" getter="getintensity" setter="setintensity" static="false">
			<doc>Determines the intensity of the bloom effect. Ideally should be in [0, 4] range but higher values are allowed.</doc>
		</property>
		<property name="Tint" type="Color" getter="gettint" setter="settint" static="false">
			<doc>Tint color to apply to the bloom highlight. A pure white means the bloom inherits the underlying scene color.</doc>
		</property>
		<property name="FilterSize" type="float" getter="getfilterSize" setter="setfilterSize" static="false">
			<doc>Determines the percent of the texture to account for when filtering for bloom. Larger values will include farther away pixels.</doc>
		</property>
	</class>
	<enum native="VectorComponent" script="VectorComponent">
		<doc>Names of individual components of a vector.</doc>
		<enumentry native="X" script="X">
		</enumentry>
		<enumentry native="Y" script="Y">
		</enumentry>
		<enumentry native="Z" script="Z">
		</enumentry>
		<enumentry native="W" script="W">
		</enumentry>
	</enum>
	<enum native="ColorComponent" script="ColorComponent">
		<doc>Names of individual components of a color.</doc>
		<enumentry native="R" script="R">
		</enumentry>
		<enumentry native="G" script="G">
		</enumentry>
		<enumentry native="B" script="B">
		</enumentry>
		<enumentry native="A" script="A">
		</enumentry>
	</enum>
	<class native="AnimationUtility" script="AnimationUtility">
		<doc>Helper class for dealing with animations, animation clips and curves.</doc>
		<method native="eulerToQuaternionCurve" script="EulerToQuaternionCurve" static="true">
			<doc>Converts a curve in euler angles (in degrees) into a curve using quaternions.</doc>
			<param name="eulerCurve" type="Vector3Curve">
			</param>
			<param name="order" type="EulerAngleOrder">
			</param>
			<returns type="QuaternionCurve">
			</returns>
		</method>
		<method native="quaternionToEulerCurve" script="QuaternionToEulerCurve" static="true">
			<doc>Converts a curve in quaternions into a curve using euler angles (in degrees).</doc>
			<param name="quatCurve" type="QuaternionCurve">
			</param>
			<returns type="Vector3Curve">
			</returns>
		</method>
		<method native="splitCurve3D" script="SplitCurve3D" static="true">
			<doc>Splits a Vector3 curve into three individual curves, one for each component.</doc>
			<param name="compoundCurve" type="Vector3Curve">
			</param>
			<returns type="AnimationCurve">
			</returns>
		</method>
		<method native="combineCurve3D" script="CombineCurve3D" static="true">
			<doc>Combines three single component curves into a Vector3 curve.</doc>
			<param name="curveComponents" type="AnimationCurve">
			</param>
			<returns type="Vector3Curve">
			</returns>
		</method>
		<method native="splitCurve2D" script="SplitCurve2D" static="true">
			<doc>Splits a Vector2 curve into two individual curves, one for each component.</doc>
			<param name="compoundCurve" type="Vector2Curve">
			</param>
			<returns type="AnimationCurve">
			</returns>
		</method>
		<method native="combineCurve2D" script="CombineCurve2D" static="true">
			<doc>Combines two single component curves into a Vector2 curve.</doc>
			<param name="curveComponents" type="AnimationCurve">
			</param>
			<returns type="Vector2Curve">
			</returns>
		</method>
		<method native="calculateRange" script="CalculateRange" static="true">
			<doc>Calculates the total range covered by a set of curves.</doc>
			<param name="curves" type="AnimationCurve">
				<doc>Curves to calculate range for.</doc>
			</param>
			<param name="xMin" type="float">
				<doc>Minimum time value present in the curves.</doc>
			</param>
			<param name="xMax" type="float">
				<doc>Maximum time value present in the curves.</doc>
			</param>
			<param name="yMin" type="float">
				<doc>Minimum curve value present in the curves.</doc>
			</param>
			<param name="yMax" type="float">
				<doc>Maximum curve value present in the curves.</doc>
			</param>
		</method>
	</class>
	<struct native="LimitAngularRange" script="LimitAngularRange">
		<doc>Represents a joint limit between two angles.</doc>
		<ctor>
			<doc>Constructs an empty limit.</doc>
		</ctor>
		<ctor>
			<doc>Constructs a hard limit. Once the limit is reached the movement of the attached bodies will come to a stop.</doc>
			<param name="lower" type="Radian">
				<doc>Lower angle of the limit. Must be less than <paramref name="upper"/>.</doc>
			</param>
			<param name="upper" type="Radian">
				<doc>Upper angle of the limit. Must be more than <paramref name="lower"/>.</doc>
			</param>
			<param name="contactDist" type="float">
				<doc>Distance from the limit at which it becomes active. Allows the solver to activate earlier than the limit is reached to avoid breaking the limit. Specify -1 for the default.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Constructs a soft limit. Once the limit is reached the bodies will bounce back according to the resitution parameter and will be pulled back towards the limit by the provided spring.</doc>
			<param name="lower" type="Radian">
				<doc>Lower angle of the limit. Must be less than <paramref name="upper"/>.</doc>
			</param>
			<param name="upper" type="Radian">
				<doc>Upper angle of the limit. Must be more than <paramref name="lower"/>.</doc>
			</param>
			<param name="spring" type="Spring">
				<doc>Spring that controls how are the bodies pulled back towards the limit when they breach it.</doc>
			</param>
			<param name="restitution" type="float">
				<doc>Controls how do objects react when the limit is reached, values closer to zero specify non-ellastic collision, while those closer to one specify more ellastic (i.e bouncy) collision. Must be in [0, 1] range.</doc>
			</param>
		</ctor>
		<field name="lower" type="Radian">
			<doc>Lower angle of the limit. Must be less than #upper.</doc>
		</field>
		<field name="upper" type="Radian">
			<doc>Upper angle of the limit. Must be less than #lower.</doc>
		</field>
		<field name="contactDist" type="float">
			<doc>Distance from the limit at which it becomes active. Allows the solver to activate earlier than the limit is reached to avoid breaking the limit.</doc>
		</field>
		<field name="restitution" type="float">
			<doc>Controls how do objects react when the limit is reached, values closer to zero specify non-ellastic collision, while those closer to one specify more ellastic (i.e bouncy) collision. Must be in [0, 1] range.</doc>
		</field>
		<field name="spring" type="Spring">
			<doc>Spring that controls how are the bodies pulled back towards the limit when they breach it.</doc>
		</field>
	</struct>
	<enum native="AnimWrapMode" script="AnimWrapMode">
		<doc>Determines how an animation clip behaves when it reaches the end.</doc>
		<enumentry native="Loop" script="Loop">
			<doc>Loop around to the beginning/end when the last/first frame is reached.</doc>
		</enumentry>
		<enumentry native="Clamp" script="Clamp">
			<doc>Clamp to end/beginning, keeping the last/first frame active.</doc>
		</enumentry>
	</enum>
	<struct native="SkeletonBoneInfoEx" script="BoneInfo">
		<doc>Contains internal information about a single bone in a Skeleton.</doc>
		<field name="name" type="string">
			<doc>Unique name of the bone.</doc>
		</field>
		<field name="parent" type="int">
			<doc>Index of the parent bone (within the relevant Skeleton object). -1 if root bone.</doc>
		</field>
		<field name="invBindPose" type="Matrix4">
			<doc>Inverse transform of the pose the skeleton was initially created in.</doc>
		</field>
	</struct>
	<enum native="RangeComponent" script="RangeComponent">
		<doc>Identifiers representing a range of values.</doc>
		<enumentry native="Min" script="Min">
		</enumentry>
		<enumentry native="Max" script="Max">
		</enumentry>
	</enum>
	<enum native="ObjectMobility" script="ObjectMobility">
		<doc>Controls what kind of mobility restrictions a scene object has. This is used primarily as a performance hint to other systems. Generally the more restricted the mobility the higher performance can be achieved.</doc>
		<enumentry native="Movable" script="Movable">
			<doc>Scene object can be moved and has no mobility restrictions.</doc>
		</enumentry>
		<enumentry native="Immovable" script="Immovable">
			<doc>Scene object isn&apos;t allowed to be moved but is allowed to be visually changed in other ways (e.g. changing the displayed mesh or light intensity (depends on attached components).</doc>
		</enumentry>
		<enumentry native="Static" script="Static">
			<doc>Scene object isn&apos;t allowed to be moved nor is it allowed to be visually changed. Object must be fully static.</doc>
		</enumentry>
	</enum>
	<class native="RootMotion" script="RootMotion">
		<doc>Contains a set of animation curves used for moving and rotating the root bone.</doc>
		<property name="Position" type="Vector3Curve" getter="getPositionCurves" setter="" static="false">
			<doc>Animation curve representing the movement of the root bone.</doc>
		</property>
		<property name="Rotation" type="QuaternionCurve" getter="getRotationCurves" setter="" static="false">
			<doc>Animation curve representing the rotation of the root bone.</doc>
		</property>
	</class>
	<struct native="TextureSurface" script="TextureSurface">
		<doc>References a subset of surfaces within a texture.</doc>
		<ctor>
			<param name="mipLevel" type="int">
			</param>
			<param name="numMipLevels" type="int">
			</param>
			<param name="face" type="int">
			</param>
			<param name="numFaces" type="int">
			</param>
		</ctor>
		<field name="mipLevel" type="int">
			<doc>First mip level to reference.</doc>
		</field>
		<field name="numMipLevels" type="int">
			<doc>Number of mip levels to reference. Must be greater than zero.</doc>
		</field>
		<field name="face" type="int">
			<doc>First face to reference. Face can represent a single cubemap face, or a single array entry in a texture array. If cubemaps are laid out in a texture array then every six sequential faces represent a single array entry.</doc>
		</field>
		<field name="numFaces" type="int">
			<doc>Number of faces to reference, if the texture has more than one.</doc>
		</field>
	</struct>
	<class native="MorphShapes" script="MorphShapes">
		<doc>Contains a set of morph channels used for morph target animation. Each morph channel contains one or multiple shapes which are blended together depending on frame animation. Each channel is then additively blended together depending on some weight.</doc>
		<property name="Channels" type="MorphChannel" getter="getChannels" setter="" static="false">
			<doc>Returns a list of all morph channels in the morph animation.</doc>
		</property>
	</class>
	<enum native="ParticleRenderMode" script="ParticleRenderMode">
		<doc>Determines how are particles represented on the screen.</doc>
		<enumentry native="Billboard" script="Billboard">
			<doc>Particle is represented using a 2D quad.</doc>
		</enumentry>
		<enumentry native="Mesh" script="Mesh">
			<doc>Particle is represented using a 3D mesh.</doc>
		</enumentry>
	</enum>
	<struct native="RectOffset" script="RectOffset">
		<doc>Rectangle represented in the form of offsets from some parent rectangle.</doc>
		<ctor>
		</ctor>
		<ctor>
			<param name="left" type="int">
			</param>
			<param name="right" type="int">
			</param>
			<param name="top" type="int">
			</param>
			<param name="bottom" type="int">
			</param>
		</ctor>
		<field name="left" type="int">
		</field>
		<field name="right" type="int">
		</field>
		<field name="top" type="int">
		</field>
		<field name="bottom" type="int">
		</field>
	</struct>
	<struct native="AnimationClipState" script="AnimationClipState">
		<doc>Contains information about a currently playing animation clip.</doc>
		<ctor>
		</ctor>
		<field name="layer" type="int">
			<doc>Layer the clip is playing on. Multiple clips can be played simulatenously on different layers.</doc>
		</field>
		<field name="time" type="float">
			<doc>Current time the animation is playing from.</doc>
		</field>
		<field name="speed" type="float">
			<doc>Speed at which the animation is playing.</doc>
		</field>
		<field name="weight" type="float">
			<doc>Determines how much of an influence does the clip have on the final pose.</doc>
		</field>
		<field name="wrapMode" type="AnimWrapMode">
			<doc>Determines what happens to other animation clips when a new clip starts playing.</doc>
		</field>
		<field name="stopped" type="bool">
			<doc>Determines should the time be advanced automatically. Certain type of animation clips don&apos;t involve playback (e.g. for blending where animation weight controls the animation).</doc>
		</field>
	</struct>
	<struct native="Blend1DInfo" script="Blend1DInfo">
		<doc>Defines a 1D blend where multiple animation clips are blended between each other using linear interpolation.</doc>
		<field name="clips" type="BlendClipInfo">
		</field>
	</struct>
	<struct native="GUIElementStateStyle" script="GUIElementStateStyle">
		<doc>Specific texture and text color used in a particular GUI element style.</doc>
		<field name="texture" type="SpriteTexture">
		</field>
		<field name="textColor" type="Color">
		</field>
	</struct>
	<struct native="Blend2DInfo" script="Blend2DInfo">
		<doc>Defines a 2D blend where two animation clips are blended between each other using bilinear interpolation.</doc>
		<field name="topLeftClip" type="RRef&lt;AnimationClip&gt;">
		</field>
		<field name="topRightClip" type="RRef&lt;AnimationClip&gt;">
		</field>
		<field name="botLeftClip" type="RRef&lt;AnimationClip&gt;">
		</field>
		<field name="botRightClip" type="RRef&lt;AnimationClip&gt;">
		</field>
	</struct>
	<class native="FontBitmap" script="FontBitmap">
		<doc>Contains textures and data about every character for a bitmap font of a specific size.</doc>
		<method native="getCharDesc" script="GetCharDesc" static="false">
			<doc>Returns a character description for the character with the specified Unicode key.</doc>
			<param name="charId" type="int">
			</param>
			<returns type="CharDesc">
			</returns>
		</method>
		<property name="Size" type="int" getter="getsize" setter="setsize" static="false">
			<doc>Font size for which the data is contained.</doc>
		</property>
		<property name="BaselineOffset" type="int" getter="getbaselineOffset" setter="setbaselineOffset" static="false">
			<doc>Y offset to the baseline on which the characters are placed, in pixels.</doc>
		</property>
		<property name="LineHeight" type="int" getter="getlineHeight" setter="setlineHeight" static="false">
			<doc>Height of a single line of the font, in pixels.</doc>
		</property>
		<property name="MissingGlyph" type="CharDesc" getter="getmissingGlyph" setter="setmissingGlyph" static="false">
			<doc>Character to use when data for a character is missing.</doc>
		</property>
		<property name="SpaceWidth" type="int" getter="getspaceWidth" setter="setspaceWidth" static="false">
			<doc>Width of a space in pixels.</doc>
		</property>
		<property name="TexturePages" type="RRef&lt;Texture&gt;" getter="gettexturePages" setter="settexturePages" static="false">
			<doc>Textures in which the character&apos;s pixels are stored.</doc>
		</property>
	</class>
	<struct native="TKeyframe&lt;int32_t&gt;" script="KeyFrameInt">
		<doc>Animation keyframe, represented as an endpoint of a cubic hermite spline.</doc>
		<field name="value" type="int">
			<doc>Value of the key.</doc>
		</field>
		<field name="time" type="float">
			<doc>Position of the key along the animation spline.</doc>
		</field>
	</struct>
	<struct native="TKeyframe&lt;float&gt;" script="KeyFrame">
		<doc>Animation keyframe, represented as an endpoint of a cubic hermite spline.</doc>
		<field name="value" type="float">
			<doc>Value of the key.</doc>
		</field>
		<field name="inTangent" type="float">
			<doc>Input tangent (going from the previous key to this one) of the key.</doc>
		</field>
		<field name="outTangent" type="float">
			<doc>Output tangent (going from this key to next one) of the key.</doc>
		</field>
		<field name="time" type="float">
			<doc>Position of the key along the animation spline.</doc>
		</field>
	</struct>
	<struct native="TKeyframe&lt;Vector3&gt;" script="KeyFrameVec3">
		<doc>Animation keyframe, represented as an endpoint of a cubic hermite spline.</doc>
		<field name="value" type="Vector3">
			<doc>Value of the key.</doc>
		</field>
		<field name="inTangent" type="Vector3">
			<doc>Input tangent (going from the previous key to this one) of the key.</doc>
		</field>
		<field name="outTangent" type="Vector3">
			<doc>Output tangent (going from this key to next one) of the key.</doc>
		</field>
		<field name="time" type="float">
			<doc>Position of the key along the animation spline.</doc>
		</field>
	</struct>
	<struct native="TKeyframe&lt;Vector2&gt;" script="KeyFrameVec2">
		<doc>Animation keyframe, represented as an endpoint of a cubic hermite spline.</doc>
		<field name="value" type="Vector2">
			<doc>Value of the key.</doc>
		</field>
		<field name="inTangent" type="Vector2">
			<doc>Input tangent (going from the previous key to this one) of the key.</doc>
		</field>
		<field name="outTangent" type="Vector2">
			<doc>Output tangent (going from this key to next one) of the key.</doc>
		</field>
		<field name="time" type="float">
			<doc>Position of the key along the animation spline.</doc>
		</field>
	</struct>
	<struct native="TKeyframe&lt;Quaternion&gt;" script="KeyFrameQuat">
		<doc>Animation keyframe, represented as an endpoint of a cubic hermite spline.</doc>
		<field name="value" type="Quaternion">
			<doc>Value of the key.</doc>
		</field>
		<field name="inTangent" type="Quaternion">
			<doc>Input tangent (going from the previous key to this one) of the key.</doc>
		</field>
		<field name="outTangent" type="Quaternion">
			<doc>Output tangent (going from this key to next one) of the key.</doc>
		</field>
		<field name="time" type="float">
			<doc>Position of the key along the animation spline.</doc>
		</field>
	</struct>
	<class native="VectorField" script="VectorField">
		<doc>Represents a three dimensional field of vectors. It is represented by spatial bounds which are split into a grid of values with user-defined density, where each grid cell is assigned a vector.</doc>
		<ctor>
			<doc>Creates a new vector field.</doc>
			<param name="desc" type="VectorFieldOptions">
				<doc>Description of the vector field to create.</doc>
			</param>
			<param name="values" type="Vector3">
				<doc>Values to assign to the vector field. Number of entries must match countX * countY * countZ.</doc>
			</param>
		</ctor>
	</class>
	<enum native="AnimationCurveFlag" script="AnimationCurveFlags">
		<doc>Flags that describe an animation curve.</doc>
		<enumentry native="ImportedCurve" script="ImportedCurve">
			<doc>If enabled, the curve was imported from an external file and not created within the engine. This will affect how are animation results applied to scene objects (with imported animations it is assumed the curve is animating bones and with in-engine curves it is assumed the curve is animating scene objects).</doc>
		</enumentry>
		<enumentry native="MorphFrame" script="MorphFrame">
			<doc>Signifies the curve is used to animate between different frames within a morph channel. In range [0, 1].</doc>
		</enumentry>
		<enumentry native="MorphWeight" script="MorphWeight">
			<doc>Signifies the curve is used to adjust the weight of a morph channel. In range [0, 1].</doc>
		</enumentry>
	</enum>
	<struct native="TNamedAnimationCurve&lt;float&gt;" script="NamedFloatCurve">
		<doc>An animation curve and its name.</doc>
		<ctor>
		</ctor>
		<ctor>
			<doc>Constructs a new named animation curve.</doc>
			<param name="name" type="string">
				<doc>Name of the curve.</doc>
			</param>
			<param name="curve" type="AnimationCurve">
				<doc>Curve containing the animation data.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Constructs a new named animation curve.</doc>
			<param name="name" type="string">
				<doc>Name of the curve.</doc>
			</param>
			<param name="flags" type="AnimationCurveFlags">
				<doc>Flags that describe the animation curve.</doc>
			</param>
			<param name="curve" type="AnimationCurve">
				<doc>Curve containing the animation data.</doc>
			</param>
		</ctor>
		<field name="name" type="string">
			<doc>Name of the curve.</doc>
		</field>
		<field name="flags" type="AnimationCurveFlags">
			<doc>Flags that describe the animation curve.</doc>
		</field>
		<field name="curve" type="AnimationCurve">
			<doc>Actual curve containing animation data.</doc>
		</field>
	</struct>
	<struct native="TNamedAnimationCurve&lt;Vector3&gt;" script="NamedVector3Curve">
		<doc>An animation curve and its name.</doc>
		<ctor>
		</ctor>
		<ctor>
			<doc>Constructs a new named animation curve.</doc>
			<param name="name" type="string">
				<doc>Name of the curve.</doc>
			</param>
			<param name="curve" type="Vector3Curve">
				<doc>Curve containing the animation data.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Constructs a new named animation curve.</doc>
			<param name="name" type="string">
				<doc>Name of the curve.</doc>
			</param>
			<param name="flags" type="AnimationCurveFlags">
				<doc>Flags that describe the animation curve.</doc>
			</param>
			<param name="curve" type="Vector3Curve">
				<doc>Curve containing the animation data.</doc>
			</param>
		</ctor>
		<field name="name" type="string">
			<doc>Name of the curve.</doc>
		</field>
		<field name="flags" type="AnimationCurveFlags">
			<doc>Flags that describe the animation curve.</doc>
		</field>
		<field name="curve" type="Vector3Curve">
			<doc>Actual curve containing animation data.</doc>
		</field>
	</struct>
	<struct native="TNamedAnimationCurve&lt;Vector2&gt;" script="NamedVector2Curve">
		<doc>An animation curve and its name.</doc>
		<ctor>
		</ctor>
		<ctor>
			<doc>Constructs a new named animation curve.</doc>
			<param name="name" type="string">
				<doc>Name of the curve.</doc>
			</param>
			<param name="curve" type="Vector2Curve">
				<doc>Curve containing the animation data.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Constructs a new named animation curve.</doc>
			<param name="name" type="string">
				<doc>Name of the curve.</doc>
			</param>
			<param name="flags" type="AnimationCurveFlags">
				<doc>Flags that describe the animation curve.</doc>
			</param>
			<param name="curve" type="Vector2Curve">
				<doc>Curve containing the animation data.</doc>
			</param>
		</ctor>
		<field name="name" type="string">
			<doc>Name of the curve.</doc>
		</field>
		<field name="flags" type="AnimationCurveFlags">
			<doc>Flags that describe the animation curve.</doc>
		</field>
		<field name="curve" type="Vector2Curve">
			<doc>Actual curve containing animation data.</doc>
		</field>
	</struct>
	<struct native="TNamedAnimationCurve&lt;Quaternion&gt;" script="NamedQuaternionCurve">
		<doc>An animation curve and its name.</doc>
		<ctor>
		</ctor>
		<ctor>
			<doc>Constructs a new named animation curve.</doc>
			<param name="name" type="string">
				<doc>Name of the curve.</doc>
			</param>
			<param name="curve" type="QuaternionCurve">
				<doc>Curve containing the animation data.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Constructs a new named animation curve.</doc>
			<param name="name" type="string">
				<doc>Name of the curve.</doc>
			</param>
			<param name="flags" type="AnimationCurveFlags">
				<doc>Flags that describe the animation curve.</doc>
			</param>
			<param name="curve" type="QuaternionCurve">
				<doc>Curve containing the animation data.</doc>
			</param>
		</ctor>
		<field name="name" type="string">
			<doc>Name of the curve.</doc>
		</field>
		<field name="flags" type="AnimationCurveFlags">
			<doc>Flags that describe the animation curve.</doc>
		</field>
		<field name="curve" type="QuaternionCurve">
			<doc>Actual curve containing animation data.</doc>
		</field>
	</struct>
	<struct native="TNamedAnimationCurve&lt;int32_t&gt;" script="NamedIntegerCurve">
		<doc>An animation curve and its name.</doc>
		<ctor>
		</ctor>
		<ctor>
			<doc>Constructs a new named animation curve.</doc>
			<param name="name" type="string">
				<doc>Name of the curve.</doc>
			</param>
			<param name="curve" type="IntegerCurve">
				<doc>Curve containing the animation data.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Constructs a new named animation curve.</doc>
			<param name="name" type="string">
				<doc>Name of the curve.</doc>
			</param>
			<param name="flags" type="AnimationCurveFlags">
				<doc>Flags that describe the animation curve.</doc>
			</param>
			<param name="curve" type="IntegerCurve">
				<doc>Curve containing the animation data.</doc>
			</param>
		</ctor>
		<field name="name" type="string">
			<doc>Name of the curve.</doc>
		</field>
		<field name="flags" type="AnimationCurveFlags">
			<doc>Flags that describe the animation curve.</doc>
		</field>
		<field name="curve" type="IntegerCurve">
			<doc>Actual curve containing animation data.</doc>
		</field>
	</struct>
	<class native="AnimationCurves" script="AnimationCurves">
		<doc>A set of animation curves representing translation/rotation/scale and generic animation.</doc>
		<ctor>
		</ctor>
		<method native="addPositionCurve" script="AddPositionCurve" static="false">
			<doc>Registers a new curve used for animating position.</doc>
			<param name="name" type="string">
				<doc>Unique name of the curve. This name will be used mapping the curve to the relevant bone in a skeleton, if any.</doc>
			</param>
			<param name="curve" type="Vector3Curve">
				<doc>Curve to add to the clip.</doc>
			</param>
		</method>
		<method native="addRotationCurve" script="AddRotationCurve" static="false">
			<doc>Registers a new curve used for animating rotation.</doc>
			<param name="name" type="string">
				<doc>Unique name of the curve. This name will be used mapping the curve to the relevant bone in a skeleton, if any.</doc>
			</param>
			<param name="curve" type="QuaternionCurve">
				<doc>Curve to add to the clip.</doc>
			</param>
		</method>
		<method native="addScaleCurve" script="AddScaleCurve" static="false">
			<doc>Registers a new curve used for animating scale.</doc>
			<param name="name" type="string">
				<doc>Unique name of the curve. This name will be used mapping the curve to the relevant bone in a skeleton, if any.</doc>
			</param>
			<param name="curve" type="Vector3Curve">
				<doc>Curve to add to the clip.</doc>
			</param>
		</method>
		<method native="addGenericCurve" script="AddGenericCurve" static="false">
			<doc>Registers a new curve used for generic animation.</doc>
			<param name="name" type="string">
				<doc>Unique name of the curve. This can be used for retrieving the value of the curve from animation.</doc>
			</param>
			<param name="curve" type="AnimationCurve">
				<doc>Curve to add to the clip.</doc>
			</param>
		</method>
		<method native="removePositionCurve" script="RemovePositionCurve" static="false">
			<doc>Removes an existing curve from the clip.</doc>
			<param name="name" type="string">
			</param>
		</method>
		<method native="removeRotationCurve" script="RemoveRotationCurve" static="false">
			<doc>Removes an existing curve from the clip.</doc>
			<param name="name" type="string">
			</param>
		</method>
		<method native="removeScaleCurve" script="RemoveScaleCurve" static="false">
			<doc>Removes an existing curve from the clip.</doc>
			<param name="name" type="string">
			</param>
		</method>
		<method native="removeGenericCurve" script="RemoveGenericCurve" static="false">
			<doc>Removes an existing curve from the clip.</doc>
			<param name="name" type="string">
			</param>
		</method>
		<property name="Position" type="NamedVector3Curve" getter="getPositionCurves" setter="setPositionCurves" static="false">
			<doc>Curves for animating scene object&apos;s position.</doc>
		</property>
		<property name="Rotation" type="NamedQuaternionCurve" getter="getRotationCurves" setter="setRotationCurves" static="false">
			<doc>Curves for animating scene object&apos;s rotation.</doc>
		</property>
		<property name="Scale" type="NamedVector3Curve" getter="getScaleCurves" setter="setScaleCurves" static="false">
			<doc>Curves for animating scene object&apos;s scale.</doc>
		</property>
		<property name="Generic" type="NamedFloatCurve" getter="getGenericCurves" setter="setGenericCurves" static="false">
			<doc>Curves for animating generic component properties.</doc>
		</property>
	</class>
	<class native="AudioClip" script="AudioClip">
		<doc>Audio clip stores audio data in a compressed or uncompressed format. Clips can be provided to audio sources or other audio methods to be played.</doc>
		<property name="BitDepth" type="int" getter="getBitDepth" setter="" static="false">
			<doc>Returns the size of a single sample, in bits.</doc>
		</property>
		<property name="SampleRate" type="int" getter="getFrequency" setter="" static="false">
			<doc>Returns how many samples per second is the audio encoded in.</doc>
		</property>
		<property name="NumChannels" type="int" getter="getNumChannels" setter="" static="false">
			<doc>Returns the number of channels provided by the clip.</doc>
		</property>
		<property name="Format" type="AudioFormat" getter="getFormat" setter="" static="false">
			<doc>Returns in which format is audio data stored in.</doc>
		</property>
		<property name="ReadMode" type="AudioReadMode" getter="getReadMode" setter="" static="false">
			<doc>Returns how is the audio data read/decoded.</doc>
		</property>
		<property name="Duration" type="float" getter="getLength" setter="" static="false">
			<doc>Returns the length of the audio clip, in seconds.</doc>
		</property>
		<property name="NumSamples" type="int" getter="getNumSamples" setter="" static="false">
			<doc>Returns the total number of samples in the clip (includes all channels).</doc>
		</property>
		<property name="Is3D" type="bool" getter="is3D" setter="" static="false">
			<doc>Determines will the clip be played a spatial 3D sound, or as a normal sound (for example music).</doc>
		</property>
	</class>
	<struct native="AnimationEvent" script="AnimationEvent">
		<doc>Event that is triggered when animation reaches a certain point.</doc>
		<ctor>
		</ctor>
		<ctor>
			<doc>Constructs a new animation event.</doc>
			<param name="name" type="string">
				<doc>Name used to identify the event when triggered.</doc>
			</param>
			<param name="time" type="float">
				<doc>Time at which to trigger the event, in seconds.</doc>
			</param>
		</ctor>
		<field name="name" type="string">
			<doc>Name used to identify the event when triggered.</doc>
		</field>
		<field name="time" type="float">
			<doc>Time at which to trigger the event, in seconds.</doc>
		</field>
	</struct>
	<struct native="AudioDevice" script="AudioDevice">
		<doc>Identifier for a device that can be used for playing audio.</doc>
		<field name="name" type="string">
		</field>
	</struct>
	<enum native="TangentType" script="TangentType">
		<doc>Type of tangent on a keyframe in an animation curve.</doc>
		<enumentry native="In" script="In">
		</enumentry>
		<enumentry native="Out" script="Out">
		</enumentry>
	</enum>
	<enum native="TangentModeBits" script="TangentMode">
		<doc>Flags that are used for describing how are tangents calculated for a specific keyframe in an animation curve. Modes for &quot;in&quot; and &quot;out&quot; tangents can be combined.</doc>
		<enumentry native="OutStep" script="OutStep">
			<doc>Tangent is infinite, ensuring there is a instantaneus jump between current and next keyframe value.</doc>
		</enumentry>
		<enumentry native="Auto" script="Auto">
			<doc>Both tangents are calculated automatically based on the two surrounding keyframes.</doc>
		</enumentry>
		<enumentry native="InAuto" script="InAuto">
			<doc>Left tangent is calculated automatically based on the two surrounding keyframes.</doc>
		</enumentry>
		<enumentry native="OutLinear" script="OutLinear">
			<doc>Tangent is calculated automatically based on the next keyframe.</doc>
		</enumentry>
		<enumentry native="InFree" script="InFree">
			<doc>Left tangent is manually adjusted by the user.</doc>
		</enumentry>
		<enumentry native="InStep" script="InStep">
			<doc>Tangent is infinite, ensuring there is a instantaneus jump between previous and current keyframe value.</doc>
		</enumentry>
		<enumentry native="InLinear" script="InLinear">
			<doc>Tangent is calculated automatically based on the previous keyframe.</doc>
		</enumentry>
		<enumentry native="OutFree" script="OutFree">
			<doc>Right tangent is manually adjusted by the user.</doc>
		</enumentry>
		<enumentry native="OutAuto" script="OutAuto">
			<doc>Right tangents are calculated automatically based on the two surrounding keyframes.</doc>
		</enumentry>
		<enumentry native="Free" script="Free">
			<doc>Both tangents are manually adjusted by the user.</doc>
		</enumentry>
	</enum>
	<struct native="PARTICLE_SIZE_DESC" script="ParticleSizeOptions">
		<doc>Structure used for initializing a ParticleSize object.</doc>
		<ctor>
		</ctor>
		<field name="size" type="FloatDistribution">
			<doc>Determines the uniform size of the particles evaluated over particle lifetime. Only used if 3D size is disabled.</doc>
		</field>
		<field name="size3D" type="Vector3Distribution">
			<doc>Determines the non-uniform size of the particles evaluated over particle lifetime. Only used if 3D size is enabled.</doc>
		</field>
		<field name="use3DSize" type="bool">
			<doc>Determines should the size be evaluated uniformly for all dimensions, or evaluate each dimension with its own distribution.</doc>
		</field>
	</struct>
	<struct native="TangentRef" script="TangentRef">
		<doc>Structure containing a reference to a keyframe tangent, as a keyframe reference and type of the tangent.</doc>
		<ctor>
		</ctor>
		<ctor>
			<param name="keyframeRef" type="KeyframeRef">
			</param>
			<param name="type" type="TangentType">
			</param>
		</ctor>
		<field name="keyframeRef" type="KeyframeRef">
		</field>
		<field name="type" type="TangentType">
		</field>
	</struct>
	<class native="MorphShape" script="MorphShape">
		<doc>Name and weight of a single shape in a morph target animation. Each shape internally represents a set of vertices that describe the morph shape.</doc>
		<property name="Name" type="string" getter="getName" setter="" static="false">
			<doc>Returns the name of the shape.</doc>
		</property>
		<property name="Weight" type="float" getter="getWeight" setter="" static="false">
			<doc>Returns the weight of the shape, determining how are different shapes within a channel blended.</doc>
		</property>
	</class>
	<class native="MorphChannel" script="MorphChannel">
		<doc>A collection of morph shapes that are sequentially blended together. Each shape has a weight in range [0, 1] which determines at what point is that shape blended. As the channel percent moves from 0 to 1, different shapes will be blended with those before or after them, depending on their weight.</doc>
		<property name="Name" type="string" getter="getName" setter="" static="false">
			<doc>Returns the unique name of the channel.</doc>
		</property>
		<property name="Shapes" type="MorphShape" getter="getShapes" setter="" static="false">
			<doc>Returns all morph shapes within this channel, in order from lowest to highest.</doc>
		</property>
	</class>
	<enum native="AudioSourceState" script="AudioSourceState">
		<doc>Valid states in which AudioSource can be in.</doc>
		<enumentry native="Playing" script="Playing">
			<doc>Source is currently playing.</doc>
		</enumentry>
		<enumentry native="Paused" script="Paused">
			<doc>Source is currently paused (play will resume from paused point).</doc>
		</enumentry>
		<enumentry native="Stopped" script="Stopped">
			<doc>Source is currently stopped (play will resume from start).</doc>
		</enumentry>
	</enum>
	<class native="Audio" script="Audio">
		<doc>Provides global functionality relating to sounds and music.</doc>
		<property name="Volume" type="float" getter="getVolume" setter="setVolume" static="false">
			<doc>Determines global audio volume. In range [0, 1].</doc>
		</property>
		<property name="Paused" type="bool" getter="isPaused" setter="setPaused" static="false">
			<doc>Determines if audio reproduction is paused globally.</doc>
		</property>
		<property name="ActiveDevice" type="AudioDevice" getter="getActiveDevice" setter="setActiveDevice" static="false">
			<doc>Determines the device on which is the audio played back on.</doc>
		</property>
		<property name="DefaultDevice" type="AudioDevice" getter="getDefaultDevice" setter="" static="false">
			<doc>Returns the default audio device identifier.</doc>
		</property>
		<property name="AllDevices" type="AudioDevice" getter="getAllDevices" setter="" static="false">
			<doc>Returns a list of all available audio devices.</doc>
		</property>
	</class>
	<enum native="AudioFormat" script="AudioFormat">
		<doc>Valid internal engine audio formats.</doc>
		<enumentry native="PCM" script="PCM">
			<doc>Pulse code modulation audio (&quot;raw&quot; uncompressed audio).</doc>
		</enumentry>
		<enumentry native="VORBIS" script="VORBIS">
			<doc>Vorbis compressed audio.</doc>
		</enumentry>
	</enum>
	<enum native="AudioReadMode" script="AudioReadMode">
		<doc>Modes that determine how and when is audio data read.</doc>
		<enumentry native="LoadDecompressed" script="LoadDecompressed">
			<doc>Entire audio clip will be loaded and decompressed. Uses most memory but has lowest CPU impact.</doc>
		</enumentry>
		<enumentry native="LoadCompressed" script="LoadCompressed">
			<doc>Entire audio clip will be loaded, but will be decompressed while playing. Uses medium amount of memory and has the highest CPU impact.</doc>
		</enumentry>
		<enumentry native="Stream" script="Stream">
			<doc>Audio will be slowly streamed from the disk, and decompressed if needed. Uses very little memory, and has either low or high CPU impact depending if the audio is in a compressed format. Since data is streamed from the disk, read speeds could also be a bottleneck.</doc>
		</enumentry>
	</enum>
	<class native="TemporalAASettings" script="TemporalAASettings">
		<doc>Settings that control temporal anti-aliasing.</doc>
		<ctor>
		</ctor>
		<property name="Enabled" type="bool" getter="getenabled" setter="setenabled" static="false">
			<doc>Enables or disables temporal anti-aliasing.</doc>
		</property>
	</class>
	<class native="AudioClipImportOptions" script="AudioClipImportOptions">
		<doc>Contains import options you may use to control how an audio clip is imported.</doc>
		<ctor>
			<doc>Creates a new import options object that allows you to customize how are audio clips imported.</doc>
		</ctor>
		<property name="Format" type="AudioFormat" getter="getformat" setter="setformat" static="false">
			<doc>Audio format to import the audio clip as.</doc>
		</property>
		<property name="ReadMode" type="AudioReadMode" getter="getreadMode" setter="setreadMode" static="false">
			<doc>Determines how is audio data loaded into memory.</doc>
		</property>
		<property name="Is3D" type="bool" getter="getis3D" setter="setis3D" static="false">
			<doc>Determines should the clip be played as spatial (3D) audio or as normal audio. 3D clips will be converted to mono on import.</doc>
		</property>
		<property name="BitDepth" type="int" getter="getbitDepth" setter="setbitDepth" static="false">
			<doc>Size of a single sample in bits. The clip will be converted to this bit depth on import.</doc>
		</property>
	</class>
	<enum native="PixelFormat" script="PixelFormat">
		<doc>Pixel formats usable by images, textures and render surfaces.</doc>
		<enumentry native="PF_R8" script="R8">
			<doc>8-bit 1-channel pixel format, unsigned normalized.</doc>
		</enumentry>
		<enumentry native="PF_RG8" script="RG8">
			<doc>8-bit 2-channel pixel format, unsigned normalized.</doc>
		</enumentry>
		<enumentry native="PF_RGB8" script="RGB8">
			<doc>8-bit 3-channel pixel format, unsigned normalized.</doc>
		</enumentry>
		<enumentry native="PF_BGR8" script="BGR8">
			<doc>8-bit 3-channel pixel format, unsigned normalized.</doc>
		</enumentry>
		<enumentry native="PF_BC2" script="BC2">
			<doc>DXT3/BC2 format containing RGB with explicit alpha. 8 bits per pixel.</doc>
		</enumentry>
		<enumentry native="PF_BGRA8" script="BGRA8">
			<doc>8-bit 4-channel pixel format, unsigned normalized.</doc>
		</enumentry>
		<enumentry native="PF_BC3" script="BC3">
			<doc>DXT5/BC2 format containing RGB with explicit alpha. 8 bits per pixel. Better alpha gradients than BC2.</doc>
		</enumentry>
		<enumentry native="PF_RGBA8" script="RGBA8">
			<doc>8-bit 4-channel pixel format, unsigned normalized.</doc>
		</enumentry>
		<enumentry native="PF_BC1" script="BC1">
			<doc>DXT1/BC1 format containing opaque RGB or 1-bit alpha RGB. 4 bits per pixel.</doc>
		</enumentry>
		<enumentry native="PF_BC4" script="BC4">
			<doc>One channel compressed format. 4 bits per pixel.</doc>
		</enumentry>
		<enumentry native="PF_BC5" script="BC5">
			<doc>Two channel compressed format. 8 bits per pixel.</doc>
		</enumentry>
		<enumentry native="PF_BC6H" script="BC6H">
			<doc>Format storing RGB in half (16-bit) floating point format usable for HDR. 8 bits per pixel.</doc>
		</enumentry>
		<enumentry native="PF_BC7" script="BC7">
			<doc>Format storing RGB with optional alpha channel. Similar to BC1/BC2/BC3 formats but with higher quality and higher decompress overhead. 8 bits per pixel.</doc>
		</enumentry>
		<enumentry native="PF_R16F" script="R16F">
			<doc>16-bit 1-channel pixel format, signed float.</doc>
		</enumentry>
		<enumentry native="PF_RG16F" script="RG16F">
			<doc>16-bit 2-channel pixel format, signed float.</doc>
		</enumentry>
		<enumentry native="PF_RGBA16F" script="RGBA16F">
			<doc>16-bit 4-channel pixel format, signed float.</doc>
		</enumentry>
		<enumentry native="PF_R32F" script="R32F">
			<doc>32-bit 1-channel pixel format, signed float.</doc>
		</enumentry>
		<enumentry native="PF_RG32F" script="RG32F">
			<doc>32-bit 2-channel pixel format, signed float.</doc>
		</enumentry>
		<enumentry native="PF_RGB32F" script="RGB32F">
			<doc>32-bit 3-channel pixel format, signed float.</doc>
		</enumentry>
		<enumentry native="PF_RGBA32F" script="RGBA32F">
			<doc>32-bit 4-channel pixel format, signed float.</doc>
		</enumentry>
		<enumentry native="PF_D32_S8X24" script="D32_S8X24">
			<doc>Depth stencil format, 32bit depth, 8bit stencil + 24 unused. Depth stored as signed float.</doc>
		</enumentry>
		<enumentry native="PF_D24S8" script="D24S8">
			<doc>Depth stencil fomrat, 24bit depth + 8bit stencil. Depth stored as unsigned normalized.</doc>
		</enumentry>
		<enumentry native="PF_D32" script="D32">
			<doc>Depth format, 32bits. Signed float.</doc>
		</enumentry>
		<enumentry native="PF_D16" script="D16">
			<doc>Depth format, 16bits. Unsigned normalized.</doc>
		</enumentry>
		<enumentry native="PF_R8I" script="R8I">
			<doc>8-bit 1-channel pixel format, signed integer.</doc>
		</enumentry>
		<enumentry native="PF_RG8I" script="RG8I">
			<doc>8-bit 2-channel pixel format, signed integer.</doc>
		</enumentry>
		<enumentry native="PF_RGBA8I" script="RGBA8I">
			<doc>8-bit 4-channel pixel format, signed integer.</doc>
		</enumentry>
		<enumentry native="PF_R8U" script="R8U">
			<doc>8-bit 1-channel pixel format, unsigned integer.</doc>
		</enumentry>
		<enumentry native="PF_RG8U" script="RG8U">
			<doc>8-bit 2-channel pixel format, unsigned integer.</doc>
		</enumentry>
		<enumentry native="PF_RGBA8U" script="RGBA8U">
			<doc>8-bit 4-channel pixel format, unsigned integer.</doc>
		</enumentry>
		<enumentry native="PF_R8S" script="R8S">
			<doc>8-bit 1-channel pixel format, signed normalized.</doc>
		</enumentry>
		<enumentry native="PF_RG8S" script="RG8S">
			<doc>8-bit 2-channel pixel format, signed normalized.</doc>
		</enumentry>
		<enumentry native="PF_RGBA8S" script="RGBA8S">
			<doc>8-bit 4-channel pixel format, signed normalized.</doc>
		</enumentry>
		<enumentry native="PF_R16I" script="R16I">
			<doc>16-bit 1-channel pixel format, signed integer.</doc>
		</enumentry>
		<enumentry native="PF_RG16I" script="RG16I">
			<doc>16-bit 2-channel pixel format, signed integer.</doc>
		</enumentry>
		<enumentry native="PF_RGBA16I" script="RGBA16I">
			<doc>16-bit 4-channel pixel format, signed integer.</doc>
		</enumentry>
		<enumentry native="PF_R16U" script="R16U">
			<doc>16-bit 1-channel pixel format, unsigned integer.</doc>
		</enumentry>
		<enumentry native="PF_RG16U" script="RG16U">
			<doc>16-bit 2-channel pixel format, unsigned integer.</doc>
		</enumentry>
		<enumentry native="PF_RGBA16U" script="RGBA16U">
			<doc>16-bit 4-channel pixel format, unsigned integer.</doc>
		</enumentry>
		<enumentry native="PF_R32I" script="R32I">
			<doc>32-bit 1-channel pixel format, signed integer.</doc>
		</enumentry>
		<enumentry native="PF_RG32I" script="RG32I">
			<doc>32-bit 2-channel pixel format, signed integer.</doc>
		</enumentry>
		<enumentry native="PF_RGB32I" script="RGB32I">
			<doc>32-bit 3-channel pixel format, signed integer.</doc>
		</enumentry>
		<enumentry native="PF_RGBA32I" script="RGBA32I">
			<doc>32-bit 4-channel pixel format, signed integer.</doc>
		</enumentry>
		<enumentry native="PF_R32U" script="R32U">
			<doc>32-bit 1-channel pixel format, unsigned integer.</doc>
		</enumentry>
		<enumentry native="PF_RG32U" script="RG32U">
			<doc>32-bit 2-channel pixel format, unsigned integer.</doc>
		</enumentry>
		<enumentry native="PF_RGB32U" script="RGB32U">
			<doc>32-bit 3-channel pixel format, unsigned integer.</doc>
		</enumentry>
		<enumentry native="PF_RGBA32U" script="RGBA32U">
			<doc>32-bit 4-channel pixel format, unsigned integer.</doc>
		</enumentry>
		<enumentry native="PF_R16S" script="R16S">
			<doc>16-bit 1-channel pixel format, signed normalized.</doc>
		</enumentry>
		<enumentry native="PF_RG16S" script="RG16S">
			<doc>16-bit 2-channel pixel format, signed normalized.</doc>
		</enumentry>
		<enumentry native="PF_RGBA16S" script="RGBA16S">
			<doc>16-bit 4-channel pixel format, signed normalized.</doc>
		</enumentry>
		<enumentry native="PF_R16" script="R16">
			<doc>16-bit 1-channel pixel format, unsigned normalized.</doc>
		</enumentry>
		<enumentry native="PF_RG16" script="RG16">
			<doc>16-bit 2-channel pixel format, unsigned normalized.</doc>
		</enumentry>
		<enumentry native="PF_RGB16" script="RGB16">
			<doc>16-bit 3-channel pixel format, unsigned normalized.</doc>
		</enumentry>
		<enumentry native="PF_RGBA16" script="RGBA16">
			<doc>16-bit 4-channel pixel format, unsigned normalized.</doc>
		</enumentry>
	</enum>
	<class native="PixelData" script="PixelData">
		<doc>A buffer describing a volume (3D), image (2D) or line (1D) of pixels in memory. Pixels are stored as a succession of &quot;depth&quot; slices, each containing &quot;height&quot; rows of &quot;width&quot; pixels.</doc>
		<ctor>
			<param name="volume" type="PixelVolume">
			</param>
			<param name="format" type="PixelFormat">
			</param>
		</ctor>
		<ctor>
			<param name="width" type="int">
			</param>
			<param name="height" type="int">
			</param>
			<param name="depth" type="int">
			</param>
			<param name="pixelFormat" type="PixelFormat">
			</param>
		</ctor>
		<method native="getPixel" script="GetPixel" static="false">
			<doc>Returns a pixel at the specified location in the buffer.</doc>
			<param name="x" type="int">
				<doc>X coordinate of the pixel.</doc>
			</param>
			<param name="y" type="int">
				<doc>Y coordinate of the pixel.</doc>
			</param>
			<param name="z" type="int">
				<doc>Z coordinate of the pixel.</doc>
			</param>
			<returns type="Color">
				<doc>Value of the pixel, or undefined value if coordinates are out of range.</doc>
			</returns>
		</method>
		<method native="setPixel" script="SetPixel" static="false">
			<doc>Sets a pixel at the specified location in the buffer.</doc>
			<param name="value" type="Color">
				<doc>Color of the pixel to set.</doc>
			</param>
			<param name="x" type="int">
				<doc>X coordinate of the pixel.</doc>
			</param>
			<param name="y" type="int">
				<doc>Y coordinate of the pixel.</doc>
			</param>
			<param name="z" type="int">
				<doc>Z coordinate of the pixel.</doc>
			</param>
		</method>
		<method native="getPixels" script="GetPixels" static="false">
			<doc>Returns values of all pixels.</doc>
			<returns type="Color">
				<doc>All pixels in the buffer ordered consecutively. Pixels are stored as a succession of &quot;depth&quot; slices, each containing &quot;height&quot; rows of &quot;width&quot; pixels.</doc>
			</returns>
		</method>
		<method native="setPixels" script="SetPixels" static="false">
			<doc>Sets all pixels in the buffer.Caller must ensure that number of pixels match the extends of the buffer.</doc>
			<param name="value" type="Color">
				<doc>All pixels in the buffer ordered consecutively. Pixels are stored as a succession of &quot;depth&quot; slices, each containing &quot;height&quot; rows of &quot;width&quot; pixels.</doc>
			</param>
		</method>
		<method native="getRawPixels" script="GetRawPixels" static="false">
			<doc>Returns all pixels in the buffer as raw bytes.</doc>
			<returns type="char">
				<doc>Raw pixel bytes. It is up to the caller to interpret the pixel format and account for potential row and slice pitch values.</doc>
			</returns>
		</method>
		<method native="setRawPixels" script="SetRawPixels" static="false">
			<doc>Sets all pixels in the buffer as raw bytes.</doc>
			<param name="value" type="char">
				<doc>Raw pixel bytes. It is up to the caller to interpret the pixel format and account for potential row and slice pitch values.</doc>
			</param>
		</method>
		<property name="RawRowPitch" type="int" getter="getRowPitch" setter="" static="false">
			<doc>Returns the number of bytes that offsets one row from another. This can be exact number of bytes required to hold &quot;width&quot; pixel, but doesn&apos;t have to be as some buffers require padding.</doc>
		</property>
		<property name="RawSlicePitch" type="int" getter="getSlicePitch" setter="" static="false">
			<doc>Returns the number of bytes that offsets one depth slice from another. This can be exact number of bytes required to hold &quot;width * height&quot; pixels, but doesn&apos;t have to be as some buffers require padding.</doc>
		</property>
		<property name="Format" type="PixelFormat" getter="getFormat" setter="" static="false">
			<doc>Returns the pixel format used by the internal buffer for storing the pixels.</doc>
		</property>
		<property name="Extents" type="PixelVolume" getter="getExtents" setter="" static="false">
			<doc>Returns extents of the pixel volume this object is capable of holding.</doc>
		</property>
		<property name="RawIsConsecutive" type="bool" getter="isConsecutive" setter="" static="false">
			<doc>Return whether this buffer is laid out consecutive in memory (meaning the pitches are equal to the dimensions).</doc>
		</property>
		<property name="RawSize" type="int" getter="getSize" setter="" static="false">
			<doc>Return the size (in bytes) of the buffer this image requires.</doc>
		</property>
	</class>
	<class native="Viewport" script="Viewport">
		<doc>Viewport determines to which RenderTarget should rendering be performed. It allows you to render to a sub-region of the target by specifying the area rectangle, and allows you to set up color/depth/stencil clear values for that specific region.</doc>
		<ctor>
			<doc>Creates a new viewport.</doc>
			<param name="target" type="RenderTarget">
			</param>
			<param name="x" type="float">
			</param>
			<param name="y" type="float">
			</param>
			<param name="width" type="float">
			</param>
			<param name="height" type="float">
			</param>
		</ctor>
		<property name="Target" type="RenderTarget" getter="getTarget" setter="setTarget" static="false">
			<doc>Determines the render target the viewport is associated with.</doc>
		</property>
		<property name="Area" type="Rect2" getter="getArea" setter="setArea" static="false">
			<doc>Determines the area that the viewport covers. Coordinates are in normalized [0, 1] range.</doc>
		</property>
		<property name="PixelArea" type="Rect2I" getter="getPixelArea" setter="" static="false">
			<doc>Returns the area of the render target covered by the viewport, in pixels.</doc>
		</property>
		<property name="ClearFlags" type="ClearFlags" getter="getClearFlags" setter="setClearFlags" static="false">
			<doc>Determines which portions of the render target should be cleared before rendering to this viewport is performed.</doc>
		</property>
		<property name="ClearColor" type="Color" getter="getClearColorValue" setter="setClearColorValue" static="false">
			<doc>Determines the color to clear the viewport to before rendering, if color clear is enabled.</doc>
		</property>
		<property name="ClearDepth" type="float" getter="getClearDepthValue" setter="setClearDepthValue" static="false">
			<doc>Determines the value to clear the depth buffer to before rendering, if depth clear is enabled.</doc>
		</property>
		<property name="ClearStencil" type="ushort" getter="getClearStencilValue" setter="setClearStencilValue" static="false">
			<doc>Determines the value to clear the stencil buffer to before rendering, if stencil clear is enabled.</doc>
		</property>
	</class>
	<class native="RenderTarget" script="RenderTarget">
		<doc>Render target is a frame buffer or a texture that the render system renders the scene to.</doc>
		<property name="Width" type="int" getter="getWidth" setter="" static="false">
			<doc>Width of the render target, in pixels.</doc>
		</property>
		<property name="Height" type="int" getter="getHeight" setter="" static="false">
			<doc>Height of the render target, in pixels.</doc>
		</property>
		<property name="GammaCorrection" type="bool" getter="getGammaCorrection" setter="" static="false">
			<doc>True if pixels written to the render target will be gamma corrected.</doc>
		</property>
		<property name="Priority" type="int" getter="getPriority" setter="setPriority" static="false">
			<doc>Controls in what order is the render target rendered to compared to other render targets. Targets with higher priority will be rendered before ones with lower priority.</doc>
		</property>
		<property name="SampleCount" type="int" getter="getSampleCount" setter="" static="false">
			<doc>Controls how many samples are used for multisampling. (0 or 1 if multisampling is not used).</doc>
		</property>
	</class>
	<struct native="VideoMode" script="VideoMode">
		<doc>Video mode contains information about how a render window presents its information to an output device like a monitor.</doc>
		<ctor>
		</ctor>
		<ctor>
			<doc>Creates a new video mode.</doc>
			<param name="width" type="int">
				<doc>Width of the frame buffer in pixels.</doc>
			</param>
			<param name="height" type="int">
				<doc>Height of the frame buffer in pixels.</doc>
			</param>
			<param name="refreshRate" type="float">
				<doc>How often should the output device refresh the output image in hertz.</doc>
			</param>
			<param name="outputIdx" type="int">
				<doc>Output index of the output device. Normally this means output monitor. 0th index always represents the primary device while order of others is undefined.</doc>
			</param>
		</ctor>
		<field name="width" type="int">
			<doc>Width of the front/back buffer in pixels.</doc>
		</field>
		<field name="height" type="int">
			<doc>Height of the front/back buffer in pixels.</doc>
		</field>
		<field name="refreshRate" type="float">
			<doc>Refresh rate in hertz.</doc>
		</field>
		<field name="outputIdx" type="int">
			<doc>Index of the parent video output.</doc>
		</field>
		<field name="isCustom" type="bool">
			<doc>Determines was video mode user created or provided by the API/OS. API/OS created video modes can contain additional information that allows the video mode to be used more accurately and you should use them when possible.</doc>
		</field>
	</struct>
	<class native="CAnimation" script="Animation">
		<doc>Handles animation playback. Takes one or multiple animation clips as input and evaluates them every animation update tick depending on set properties. The evaluated data is used by the core thread for skeletal animation, by the sim thread for updating attached scene objects and bones (if skeleton is attached), or the data is made available for manual queries in the case of generic animation.</doc>
		<method native="play" script="Play" static="false">
			<doc>Plays the specified animation clip.</doc>
			<param name="clip" type="RRef&lt;AnimationClip&gt;">
				<doc>Clip to play.</doc>
			</param>
		</method>
		<method native="blendAdditive" script="BlendAdditive" static="false">
			<doc>Plays the specified animation clip on top of the animation currently playing in the main layer. Multiple such clips can be playing at once, as long as you ensure each is given its own layer. Each animation can also have a weight that determines how much it influences the main animation.</doc>
			<param name="clip" type="RRef&lt;AnimationClip&gt;">
				<doc>Clip to additively blend. Must contain additive animation curves.</doc>
			</param>
			<param name="weight" type="float">
				<doc>Determines how much of an effect will the blended animation have on the final output. In range [0, 1].</doc>
			</param>
			<param name="fadeLength" type="float">
				<doc>Applies the blend over a specified time period, increasing the weight as the time passes. Set to zero to blend immediately. In seconds.</doc>
			</param>
			<param name="layer" type="int">
				<doc>Layer to play the clip in. Multiple additive clips can be playing at once in separate layers and each layer has its own weight.</doc>
			</param>
		</method>
		<method native="blend1D" script="Blend1D" static="false">
			<doc>Blend multiple animation clips between each other using linear interpolation. Unlike normal animations these animations are not advanced with the progress of time, and is instead expected the user manually changes the <paramref name="t"/> parameter.</doc>
			<param name="info" type="Blend1DInfo">
				<doc>Information about the clips to blend. Clip positions must be sorted from lowest to highest.</doc>
			</param>
			<param name="t" type="float">
				<doc>Parameter that controls the blending. Range depends on the positions of the provided animation clips.</doc>
			</param>
		</method>
		<method native="blend2D" script="Blend2D" static="false">
			<doc>Blend four animation clips between each other using bilinear interpolation. Unlike normal animations these animations are not advanced with the progress of time, and is instead expected the user manually changes the <paramref name="t"/> parameter.</doc>
			<param name="info" type="Blend2DInfo">
				<doc>Information about the clips to blend.</doc>
			</param>
			<param name="t" type="Vector2">
				<doc>Parameter that controls the blending, in range [(0, 0), (1, 1)]. t = (0, 0) means top left animation has full influence, t = (1, 0) means top right animation has full influence, t = (0, 1) means bottom left animation has full influence, t = (1, 1) means bottom right animation has full influence.</doc>
			</param>
		</method>
		<method native="crossFade" script="CrossFade" static="false">
			<doc>Fades the specified animation clip in, while fading other playing animation out, over the specified time period.</doc>
			<param name="clip" type="RRef&lt;AnimationClip&gt;">
				<doc>Clip to fade in.</doc>
			</param>
			<param name="fadeLength" type="float">
				<doc>Determines the time period over which the fade occurs. In seconds.</doc>
			</param>
		</method>
		<method native="sample" script="Sample" static="false">
			<doc>Samples an animation clip at the specified time, displaying only that particular frame without further playback.</doc>
			<param name="clip" type="RRef&lt;AnimationClip&gt;">
				<doc>Animation clip to sample.</doc>
			</param>
			<param name="time" type="float">
				<doc>Time to sample the clip at.</doc>
			</param>
		</method>
		<method native="stop" script="Stop" static="false">
			<doc>Stops playing all animations on the provided layer. Specify -1 to stop animation on the main layer (non-additive animations).</doc>
			<param name="layer" type="int">
			</param>
		</method>
		<method native="stopAll" script="StopAll" static="false">
			<doc>Stops playing all animations.</doc>
		</method>
		<method native="getState" script="GetState" static="false">
			<doc>Retrieves detailed information about a currently playing animation clip.</doc>
			<param name="clip" type="RRef&lt;AnimationClip&gt;">
				<doc>Clip to retrieve the information for.</doc>
			</param>
			<param name="state" type="AnimationClipState">
				<doc>Animation clip state containing the requested information. Only valid if the method returns true.</doc>
			</param>
			<returns type="bool">
				<doc>True if the state was found (animation clip is playing), false otherwise.</doc>
			</returns>
		</method>
		<method native="setState" script="SetState" static="false">
			<doc>Changes the state of a playing animation clip. If animation clip is not currently playing the playback is started for the clip.</doc>
			<param name="clip" type="RRef&lt;AnimationClip&gt;">
				<doc>Clip to change the state for.</doc>
			</param>
			<param name="state" type="AnimationClipState">
				<doc>New state of the animation (e.g. changing the time for seeking).</doc>
			</param>
		</method>
		<method native="setMorphChannelWeight" script="SetMorphChannelWeight" static="false">
			<doc>Changes a weight of a single morph channel, determining how much of it to apply on top of the base mesh.</doc>
			<param name="name" type="string">
				<doc>Name of the morph channel to modify. This depends on the mesh the animation is currently animating.</doc>
			</param>
			<param name="weight" type="float">
				<doc>Weight that determines how much of the channel to apply to the mesh, in range [0, 1].</doc>
			</param>
		</method>
		<property name="DefaultClip" type="RRef&lt;AnimationClip&gt;" getter="getDefaultClip" setter="setDefaultClip" static="false">
			<doc>Determines the default clip to play as soon as the component is enabled. If more control over playing clips is needed use the play(), blend() and crossFade() methods to queue clips for playback manually, and setState() method for modify their states individually.</doc>
		</property>
		<property name="WrapMode" type="AnimWrapMode" getter="getWrapMode" setter="setWrapMode" static="false">
			<doc>Determines the wrap mode for all active animations. Wrap mode determines what happens when animation reaches the first or last frame.</doc>
		</property>
		<property name="Speed" type="float" getter="getSpeed" setter="setSpeed" static="false">
			<doc>Determines the speed for all animations. The default value is 1.0f. Use negative values to play-back in reverse.</doc>
		</property>
		<property name="IsPlaying" type="bool" getter="isPlaying" setter="" static="false">
			<doc>Checks if any animation clips are currently playing.</doc>
		</property>
		<property name="Bounds" type="AABox" getter="getBounds" setter="setBounds" static="false">
			<doc>Determines bounds that will be used for animation and mesh culling. Only relevant if setUseBounds() is set to true.</doc>
		</property>
		<property name="UseBounds" type="bool" getter="getUseBounds" setter="setUseBounds" static="false">
			<doc>Determines should animation bounds be used for visibility determination (culling). If false the bounds of the mesh attached to the relevant CRenderable component will be used instead.</doc>
		</property>
		<property name="Cull" type="bool" getter="getEnableCull" setter="setEnableCull" static="false">
			<doc>Enables or disables culling of the animation when out of view. Culled animation will not be evaluated.</doc>
		</property>
	</class>
	<class native="CAudioSource" script="AudioSource">
		<doc>Represents a source for emitting audio. Audio can be played spatially (gun shot), or normally (music). Each audio source must have an AudioClip to play-back, and it can also have a position in the case of spatial (3D) audio.
Whether or not an audio source is spatial is controlled by the assigned AudioClip. The volume and the pitch of a spatial audio source is controlled by its position and the AudioListener&apos;s position/direction/velocity.</doc>
		<method native="play" script="Play" static="false">
			<doc>Starts playing the currently assigned audio clip.</doc>
		</method>
		<method native="pause" script="Pause" static="false">
			<doc>Pauses the audio playback.</doc>
		</method>
		<method native="stop" script="Stop" static="false">
			<doc>Stops audio playback, rewinding it to the start.</doc>
		</method>
		<property name="Clip" type="RRef&lt;AudioClip&gt;" getter="getClip" setter="setClip" static="false">
			<doc>Audio clip to play.</doc>
		</property>
		<property name="Volume" type="float" getter="getVolume" setter="setVolume" static="false">
			<doc>Volume of the audio played from this source, in [0, 1] range.</doc>
		</property>
		<property name="Pitch" type="float" getter="getPitch" setter="setPitch" static="false">
			<doc>Determines the pitch of the played audio. 1 is the default.</doc>
		</property>
		<property name="Loop" type="bool" getter="getIsLooping" setter="setIsLooping" static="false">
			<doc>Determines whether the audio clip should loop when it finishes playing.</doc>
		</property>
		<property name="Priority" type="int" getter="getPriority" setter="setPriority" static="false">
			<doc>Determines the priority of the audio source. If more audio sources are playing than supported by the hardware, some might get disabled. By setting a higher priority the audio source is guaranteed to be disabled after sources with lower priority.</doc>
		</property>
		<property name="MinDistance" type="float" getter="getMinDistance" setter="setMinDistance" static="false">
			<doc>Minimum distance at which audio attenuation starts. When the listener is closer to the source than this value, audio is heard at full volume. Once farther away the audio starts attenuating.</doc>
		</property>
		<property name="Attenuation" type="float" getter="getAttenuation" setter="setAttenuation" static="false">
			<doc>Attenuation that controls how quickly does audio volume drop off as the listener moves further from the source.</doc>
		</property>
		<property name="Time" type="float" getter="getTime" setter="setTime" static="false">
			<doc>Determines the current time of playback. If playback hasn&apos;t yet started, it specifies the time at which playback will start at. The time is in seconds, in range [0, clipLength].</doc>
		</property>
		<property name="PlayOnStart" type="bool" getter="getPlayOnStart" setter="setPlayOnStart" static="false">
			<doc>Sets whether playback should start as soon as the component is enabled.</doc>
		</property>
		<property name="State" type="AudioSourceState" getter="getState" setter="" static="false">
			<doc>Returns the current state of the audio playback (playing/paused/stopped).</doc>
		</property>
	</class>
	<class native="CBone" script="Bone">
		<doc>Component that maps animation for specific bone also be applied to the SceneObject this component is attached to. The component will attach to the first found parent Animation component.</doc>
		<property name="Name" type="string" getter="getBoneName" setter="setBoneName" static="false">
			<doc>Determines the name of the bone the component is referencing.</doc>
		</property>
	</class>
	<struct native="BoneWeight" script="BoneWeight">
		<doc>Contains per-vertex bone weights and indexes used for skinning, for up to four bones.</doc>
		<field name="index0" type="int">
		</field>
		<field name="index1" type="int">
		</field>
		<field name="index2" type="int">
		</field>
		<field name="index3" type="int">
		</field>
		<field name="weight0" type="float">
		</field>
		<field name="weight1" type="float">
		</field>
		<field name="weight2" type="float">
		</field>
		<field name="weight3" type="float">
		</field>
	</struct>
	<struct native="ContactPoint" script="ContactPoint">
		<doc>Information about a single contact point during physics collision.</doc>
		<field name="position" type="Vector3">
			<doc>Contact point in world space.</doc>
		</field>
		<field name="normal" type="Vector3">
			<doc>Normal pointing from the second shape to the first shape.</doc>
		</field>
		<field name="impulse" type="float">
			<doc>Impulse applied to the objects to keep them from penetrating. Divide by simulation step to get the force.</doc>
		</field>
		<field name="separation" type="float">
			<doc>Determines how far are the objects. Negative value denotes penetration.</doc>
		</field>
	</struct>
	<class native="ParticleGravity" script="ParticleGravity">
		<doc>Applies gravity to the particles.</doc>
		<ctor>
			<doc>Creates a new particle gravity evolver.</doc>
			<param name="desc" type="ParticleGravityOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle gravity evolver.</doc>
		</ctor>
		<property name="Options" type="ParticleGravityOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the evolver.</doc>
		</property>
	</class>
	<enum native="LightType" script="LightType">
		<doc>Light type that determines how is light information parsed by the renderer and other systems.</doc>
		<enumentry native="Directional" script="Directional">
		</enumentry>
		<enumentry native="Radial" script="Radial">
		</enumentry>
		<enumentry native="Spot" script="Spot">
		</enumentry>
	</enum>
	<struct native="CollisionData" script="CollisionData">
		<doc>Information about a collision between two physics objects.</doc>
		<field name="collider" type="Collider">
			<doc>Components of the colliders that have collided.</doc>
		</field>
		<field name="contactPoints" type="ContactPoint">
			<doc>Information about all the contact points for the hit.</doc>
		</field>
	</struct>
	<class native="ScreenSpaceLensFlareSettings" script="ScreenSpaceLensFlareSettings">
		<doc>Settings that control the screen-space lens flare effect.</doc>
		<ctor>
		</ctor>
		<property name="Enabled" type="bool" getter="getenabled" setter="setenabled" static="false">
			<doc>Enables or disables the lens flare effect.</doc>
		</property>
		<property name="DownsampleCount" type="int" getter="getdownsampleCount" setter="setdownsampleCount" static="false">
			<doc>Determines how many times to downsample the scene texture before using it for lens flare effect. Lower values will use higher resolution texture for calculating lens flare, at the cost of lower performance. Valid range is [1, 6], default is 4.</doc>
		</property>
		<property name="Threshold" type="float" getter="getthreshold" setter="setthreshold" static="false">
			<doc>Determines the minimal threshold of pixel luminance to be included in the lens flare calculations. Any pixel with luminance below this value will be ignored for the purposes of lens flare. Set to zero or negative to disable the threshold and include all pixels in the calculations.</doc>
		</property>
		<property name="GhostCount" type="int" getter="getghostCount" setter="setghostCount" static="false">
			<doc>Determines the number of ghost features to appear, shown as blurred blobs of bright areas of the scene.</doc>
		</property>
		<property name="GhostSpacing" type="float" getter="getghostSpacing" setter="setghostSpacing" static="false">
			<doc>Determines the distance between ghost features. Value is in normalized screen space, in range [0,1] where 1 represents the full screen length.</doc>
		</property>
		<property name="Brightness" type="float" getter="getbrightness" setter="setbrightness" static="false">
			<doc>Determines the brightness of the lens flare effect. Value of 1 means the lens flare will be displayed at the same intensity as the scene it was derived from. In range [0, 1], default being 0.05.</doc>
		</property>
		<property name="FilterSize" type="float" getter="getfilterSize" setter="setfilterSize" static="false">
			<doc>Determines the size of the filter when blurring the lens flare features. Larger values yield a blurrier image and will require more performance.</doc>
		</property>
		<property name="Halo" type="bool" getter="gethalo" setter="sethalo" static="false">
			<doc>Determines if a halo effect should be rendered as part of the lens flare.</doc>
		</property>
		<property name="HaloRadius" type="float" getter="gethaloRadius" setter="sethaloRadius" static="false">
			<doc>Determines how far away from the screen center does the halo appear, in normalized screen space (range [0,1]) where 0.5 represents half screen length.</doc>
		</property>
		<property name="HaloThickness" type="float" getter="gethaloThickness" setter="sethaloThickness" static="false">
			<doc>Determines the thickness of the halo ring. In normalized screen space (range [0.01,0.5]).</doc>
		</property>
		<property name="HaloThreshold" type="float" getter="gethaloThreshold" setter="sethaloThreshold" static="false">
			<doc>Determines the minimal threshold of pixel luminance to be included for halo generation. Any pixel with luminance below this value will be ignored for the purposes of halo generation.</doc>
		</property>
		<property name="HaloAspectRatio" type="float" getter="gethaloAspectRatio" setter="sethaloAspectRatio" static="false">
			<doc>Determines the shape of the halo. Set to value other than 1 to make the halo an oval rather than a circle.</doc>
		</property>
		<property name="ChromaticAberration" type="bool" getter="getchromaticAberration" setter="setchromaticAberration" static="false">
			<doc>Enables or disables chromatic aberration of the lens flare and halo features. Chromatic aberration separates the values of red, green and blue channels according to a user provided offset.</doc>
		</property>
		<property name="ChromaticAberrationOffset" type="float" getter="getchromaticAberrationOffset" setter="setchromaticAberrationOffset" static="false">
			<doc>Determines the distance between pixels within which to sample different channels. The value is in UV coordinates, range [0, 1].</doc>
		</property>
		<property name="BicubicUpsampling" type="bool" getter="getbicubicUpsampling" setter="setbicubicUpsampling" static="false">
			<doc>Uses a higher quality upscaling when blending the lens flare features with scene color. Results in less blocky artifacts at a cost to performance.</doc>
		</property>
	</class>
	<enum native="CollisionReportMode" script="CollisionReportMode">
		<doc>Determines which collision events will be reported by physics objects.</doc>
		<enumentry native="None" script="None">
			<doc>No collision events will be triggered.</doc>
		</enumentry>
		<enumentry native="Report" script="Report">
			<doc>Collision events will be triggered when object enters and/or leaves collision.</doc>
		</enumentry>
		<enumentry native="ReportPersistent" script="ReportPersistent">
			<doc>Collision events will be triggered when object enters and/or leaves collision, but also every frame the object remains in collision.</doc>
		</enumentry>
	</enum>
	<struct native="PhysicsQueryHit" script="PhysicsQueryHit">
		<doc>Hit information from a physics query.</doc>
		<ctor>
		</ctor>
		<field name="point" type="Vector3">
			<doc>Position of the hit in world space.</doc>
		</field>
		<field name="normal" type="Vector3">
			<doc>Normal to the surface that was hit.</doc>
		</field>
		<field name="uv" type="Vector2">
			<doc>Barycentric coordinates of the triangle that was hit (only applicable when triangle meshes are hit).</doc>
		</field>
		<field name="distance" type="float">
			<doc>Distance from the query origin to the hit position.</doc>
		</field>
		<field name="triangleIdx" type="int">
			<doc>Index of the triangle that was hit (only applicable when triangle meshes are hit).</doc>
		</field>
		<field name="unmappedTriangleIdx" type="int">
			<doc>Unmapped index of the triangle that was hit (only applicable when triangle meshes are hit). It represents an index into the original MeshData used to create the PhysicsMesh associated with <see cref="collider"/>. In contrast, <see cref="triangleIdx"/> is only a valid index for the MeshData directly obtained from #collider which can differ from the original MeshData due to the internal implementation.</doc>
		</field>
		<field name="collider" type="Collider">
			<doc>Component of the collider that was hit. This may be null if the hit collider has no owner component, in which case refer to #colliderRaw.</doc>
		</field>
	</struct>
	<class native="CCollider" script="Collider">
		<doc>Collider represents physics geometry that can be in multiple states: - Default: Static geometry that physics objects can collide with. - Trigger: Static geometry that can&apos;t be collided with but will report touch events. - Dynamic: Dynamic geometry that is a part of a Rigidbody. A set of colliders defines the shape of the parent rigidbody.</doc>
		<property name="Trigger" type="bool" getter="getIsTrigger" setter="setIsTrigger" static="false">
			<doc>Enables/disables a collider as a trigger. A trigger will not be used for collisions (objects will pass through it), but collision events will still be reported.</doc>
		</property>
		<property name="Mass" type="float" getter="getMass" setter="setMass" static="false">
			<doc>Determines the mass of the collider. Only relevant if the collider is part of a rigidbody. Ultimately this will determine the total mass, center of mass and inertia tensors of the parent rigidbody (if they&apos;re being calculated automatically).</doc>
		</property>
		<property name="Material" type="RRef&lt;PhysicsMaterial&gt;" getter="getMaterial" setter="setMaterial" static="false">
			<doc>Determines the physical material of the collider. The material determines how objects hitting the collider behave.</doc>
		</property>
		<property name="ContactOffset" type="float" getter="getContactOffset" setter="setContactOffset" static="false">
			<doc>Determines how far apart do two shapes need to be away from each other before the physics runtime starts generating repelling impulse for them. This distance will be the sum of contact offsets of the two interacting objects. If objects are moving fast you can increase this value to start generating the impulse earlier and potentially prevent the objects from interpenetrating. This value is in meters. Must be positive and greater than rest offset.
Also see setRestOffset().</doc>
		</property>
		<property name="RestOffset" type="float" getter="getRestOffset" setter="setRestOffset" static="false">
			<doc>Determines at what distance should two objects resting on one another come to an equilibrium. The value used in the runtime will be the sum of rest offsets for both interacting objects. This value is in meters. Cannot be larger than contact offset.
Also see setContactOffset().</doc>
		</property>
		<property name="Layer" type="ulong" getter="getLayer" setter="setLayer" static="false">
			<doc>Determines the layer of the collider. Layer controls with which objects will the collider collide.</doc>
		</property>
		<property name="CollisionReportMode" type="CollisionReportMode" getter="getCollisionReportMode" setter="setCollisionReportMode" static="false">
			<doc>Determines which (if any) collision events are reported.</doc>
		</property>
		<event native="onCollisionBegin" script="OnCollisionBegin" static="false">
			<doc>Triggered when some object starts interacting with the collider. Only triggered if proper collision report mode is turned on.</doc>
			<param name="p0" type="CollisionData">
			</param>
		</event>
		<event native="onCollisionStay" script="OnCollisionStay" static="false">
			<doc>Triggered for every frame that an object remains interacting with a collider. Only triggered if proper collision report mode is turned on.</doc>
			<param name="p0" type="CollisionData">
			</param>
		</event>
		<event native="onCollisionEnd" script="OnCollisionEnd" static="false">
			<doc>Triggered when some object stops interacting with the collider. Only triggered if proper collision report mode is turned on.</doc>
			<param name="p0" type="CollisionData">
			</param>
		</event>
	</class>
	<struct native="SpriteSheetGridAnimation" script="SpriteSheetGridAnimation">
		<doc>Descriptor that describes a simple sprite sheet animation. The parent texture is split into a grid of <see cref="numRows"/> x <see cref="numColumns"/>, each representing one frame of the animation. Every frame is of equal size. Frames are sequentially evaluated starting from the top-most row, iterating over all columns in a row and then moving to next row, up to <see cref="count"/> frames. Frames in rows/colums past <see cref="count"/>. <see cref="fps"/> frames are evaluated every second, allowing you to control animation speed.</doc>
		<ctor>
		</ctor>
		<ctor>
			<param name="numRows" type="int">
			</param>
			<param name="numColumns" type="int">
			</param>
			<param name="count" type="int">
			</param>
			<param name="fps" type="int">
			</param>
		</ctor>
		<field name="numRows" type="int">
			<doc>Number of rows to divide the parent&apos;s texture area. Determines height of the individual frame (depends on parent texture size).</doc>
		</field>
		<field name="numColumns" type="int">
			<doc>Number of columns to divide the parent&apos;s texture area. Determines column of the individual frame (depends on parent texture size).</doc>
		</field>
		<field name="count" type="int">
			<doc>Number of frames in the animation. Must be less or equal than <see cref="numRows"/> * <see cref="numColumns"/>.</doc>
		</field>
		<field name="fps" type="int">
			<doc>How many frames to evaluate each second. Determines the animation speed.</doc>
		</field>
	</struct>
	<enum native="TextureUsage" script="TextureUsage">
		<doc>Flags that describe how is a texture used.</doc>
		<enumentry native="TU_STATIC" script="Default">
			<doc>A regular texture that is not often or ever updated from the CPU.</doc>
		</enumentry>
		<enumentry native="TU_DYNAMIC" script="Dynamic">
			<doc>A regular texture that is often updated by the CPU.</doc>
		</enumentry>
		<enumentry native="TU_RENDERTARGET" script="Render">
			<doc>Texture that can be rendered to by the GPU.</doc>
		</enumentry>
		<enumentry native="TU_DEPTHSTENCIL" script="DepthStencil">
			<doc>Texture used as a depth/stencil buffer by the GPU.</doc>
		</enumentry>
		<enumentry native="TU_LOADSTORE" script="LoadStore">
			<doc>Texture that allows load/store operations from the GPU program.</doc>
		</enumentry>
		<enumentry native="TU_CPUCACHED" script="CPUCached">
			<doc>All mesh data will also be cached in CPU memory, making it available for fast read access from the CPU.</doc>
		</enumentry>
		<enumentry native="TU_CPUREADABLE" script="CPUReadable">
			<doc>Allows the CPU to directly read the texture data buffers from the GPU.</doc>
		</enumentry>
		<enumentry native="TU_MUTABLEFORMAT" script="MutableFormat">
			<doc>Allows you to retrieve views of the texture using a format different from one specified on creation.</doc>
		</enumentry>
	</enum>
	<class native="Texture" script="Texture">
		<doc>Abstract class representing a texture. Specific render systems have their own Texture implementations. Internally represented as one or more surfaces with pixels in a certain number of dimensions, backed by a hardware buffer.</doc>
		<method native="readData" script="GetGPUPixels" static="false">
			<doc>Reads internal texture data into a newly allocated buffer.</doc>
			<param name="face" type="int">
				<doc>Texture face to read from.</doc>
			</param>
			<param name="mipLevel" type="int">
				<doc>Mipmap level to read from.</doc>
			</param>
			<returns type="AsyncOp&lt;PixelData&gt;">
				<doc>Async operation object that will contain the buffer with the data once the operation completes.</doc>
			</returns>
		</method>
		<ctor>
			<param name="format" type="PixelFormat">
			</param>
			<param name="width" type="int">
			</param>
			<param name="height" type="int">
			</param>
			<param name="depth" type="int">
			</param>
			<param name="texType" type="TextureType">
			</param>
			<param name="usage" type="TextureUsage">
			</param>
			<param name="numSamples" type="int">
			</param>
			<param name="hasMipmaps" type="bool">
			</param>
			<param name="gammaCorrection" type="bool">
			</param>
		</ctor>
		<method native="getPixels" script="GetPixels" static="false">
			<doc>Returns pixels for the specified mip level &amp; face. Pixels will be read from system memory, which means the texture has to be created with TextureUsage.CPUCached. If the texture was updated from the GPU the pixels retrieved from this method will not reflect that, and you should use GetGPUPixels instead.</doc>
			<param name="face" type="int">
				<doc>Face to read the pixels from. Cubemap textures have six faces whose face indices are as specified in the CubeFace enum. Array textures can have an arbitrary number of faces (if it&apos;s a cubemap array it has to be a multiple of 6).</doc>
			</param>
			<param name="mipLevel" type="int">
				<doc>Mip level to retrieve pixels for. Top level (0) is the highest quality.</doc>
			</param>
			<returns type="PixelData">
				<doc>A set of pixels for the specified mip level.</doc>
			</returns>
		</method>
		<method native="setPixels" script="SetPixels" static="false">
			<doc>Sets pixels for the specified mip level and face.</doc>
			<param name="data" type="PixelData">
				<doc>Pixels to assign to the specified mip level. Pixel data must match the mip level size and texture pixel format.</doc>
			</param>
			<param name="face" type="int">
				<doc>Face to write the pixels to. Cubemap textures have six faces whose face indices are as specified in the CubeFace enum. Array textures can have an arbitrary number of faces (if it&apos;s a cubemap array it has to be a multiple of 6).</doc>
			</param>
			<param name="mipLevel" type="int">
				<doc>Mip level to set pixels for. Top level (0) is the highest quality.</doc>
			</param>
		</method>
		<method native="setPixelsArray" script="SetPixels" static="false">
			<doc>Sets pixels for the specified mip level and face.</doc>
			<param name="colors" type="Color">
				<doc>Pixels to assign to the specified mip level. Size of the array must match the mip level dimensions. Data is expected to be laid out row by row. Pixels will be automatically converted to the valid pixel format.</doc>
			</param>
			<param name="face" type="int">
				<doc>Face to write the pixels to. Cubemap textures have six faces whose face indices are as specified in the CubeFace enum. Array textures can have an arbitrary number of faces (if it&apos;s a cubemap array it has to be a multiple of 6).</doc>
			</param>
			<param name="mipLevel" type="int">
				<doc>Mip level to set pixels for. Top level (0) is the highest quality.</doc>
			</param>
		</method>
		<property name="PixelFormat" type="PixelFormat" getter="getPixelFormat" setter="" static="false">
			<doc>Returns the pixel format for the texture surface.</doc>
		</property>
		<property name="Usage" type="TextureUsage" getter="getUsage" setter="" static="false">
			<doc>Returns a value that signals the engine in what way is the texture expected to be used.</doc>
		</property>
		<property name="Type" type="TextureType" getter="getType" setter="" static="false">
			<doc>Gets the type of texture.</doc>
		</property>
		<property name="Width" type="int" getter="getWidth" setter="" static="false">
			<doc>Returns the width of the texture.</doc>
		</property>
		<property name="Height" type="int" getter="getHeight" setter="" static="false">
			<doc>Returns the height of the texture.</doc>
		</property>
		<property name="Depth" type="int" getter="getDepth" setter="" static="false">
			<doc>Returns the depth of the texture (only applicable for 3D textures).</doc>
		</property>
		<property name="GammaSpace" type="bool" getter="getGammaCorrection" setter="" static="false">
			<doc>Determines does the texture contain gamma corrected data. If true then the GPU will automatically convert the pixels to linear space before reading from the texture, and convert them to gamma space when writing to the texture.</doc>
		</property>
		<property name="SampleCount" type="int" getter="getSampleCount" setter="" static="false">
			<doc>Gets the number of samples used for multisampling (0 or 1 if multisampling is not used).</doc>
		</property>
		<property name="MipMapCount" type="int" getter="getMipmapCount" setter="" static="false">
			<doc>Gets the number of mipmaps to be used for this texture. This number excludes the top level map (which is always assumed to be present).</doc>
		</property>
	</class>
	<class native="AutoExposureSettings" script="AutoExposureSettings">
		<doc>Settings that control automatic exposure (eye adaptation) post-process.</doc>
		<ctor>
		</ctor>
		<property name="HistogramLog2Min" type="float" getter="gethistogramLog2Min" setter="sethistogramLog2Min" static="false">
			<doc>Determines minimum luminance value in the eye adaptation histogram. The histogram is used for calculating the average brightness of the scene. Any luminance value below this value will not be included in the histogram and ignored in scene brightness calculations. In log2 units (-8 = 1/256). In the range [-16, 0].</doc>
		</property>
		<property name="HistogramLog2Max" type="float" getter="gethistogramLog2Max" setter="sethistogramLog2Max" static="false">
			<doc>Determines maximum luminance value in the eye adaptation histogram. The histogram is used for calculating the average brightness of the scene. Any luminance value above this value will not be included in the histogram and ignored in scene brightness calculations. In log2 units (4 = 16). In the range [0, 16].</doc>
		</property>
		<property name="HistogramPctLow" type="float" getter="gethistogramPctLow" setter="sethistogramPctLow" static="false">
			<doc>Percentage below which to ignore values in the eye adaptation histogram. The histogram is used for calculating the average brightness of the scene. Total luminance in the histogram will be summed up and multiplied by this value to calculate minimal luminance. Luminance values below the minimal luminance will be ignored and not used in scene brightness calculations. This allows you to remove outliers on the lower end of the histogram (for example a few very dark pixels in an otherwise bright image). In range [0.0f, 1.0f].</doc>
		</property>
		<property name="HistogramPctHigh" type="float" getter="gethistogramPctHigh" setter="sethistogramPctHigh" static="false">
			<doc>Percentage above which to ignore values in the eye adaptation histogram. The histogram is used for calculating the average brightness of the scene. Total luminance in the histogram will be summed up and multiplied by this value to calculate maximum luminance. Luminance values above the maximum luminance will be ignored and not used in scene brightness calculations. This allows you to remove outliers on the high end of the histogram (for example a few very bright pixels). In range [0.0f, 1.0f].</doc>
		</property>
		<property name="MinEyeAdaptation" type="float" getter="getminEyeAdaptation" setter="setminEyeAdaptation" static="false">
			<doc>Clamps the minimum eye adaptation scale to this value. This allows you to limit eye adaptation so that exposure is never too high (for example when in a very dark room you probably do not want the exposure to be so high that everything is still visible). In range [0.0f, 10.0f].</doc>
		</property>
		<property name="MaxEyeAdaptation" type="float" getter="getmaxEyeAdaptation" setter="setmaxEyeAdaptation" static="false">
			<doc>Clamps the maximum eye adaptation scale to this value. This allows you to limit eye adaptation so that exposure is never too low (for example when looking at a very bright light source you probably don&apos;t want the exposure to be so low that the rest of the scene is all white (overexposed). In range [0.0f, 10.0f].</doc>
		</property>
		<property name="EyeAdaptationSpeedUp" type="float" getter="geteyeAdaptationSpeedUp" setter="seteyeAdaptationSpeedUp" static="false">
			<doc>Determines how quickly does the eye adaptation adjust to larger values. This affects how quickly does the automatic exposure changes when the scene brightness increases. In range [0.01f, 20.0f].</doc>
		</property>
		<property name="EyeAdaptationSpeedDown" type="float" getter="geteyeAdaptationSpeedDown" setter="seteyeAdaptationSpeedDown" static="false">
			<doc>Determines how quickly does the eye adaptation adjust to smaller values. This affects how quickly does the automatic exposure changes when the scene brightness decreases. In range [0.01f, 20.0f].</doc>
		</property>
	</class>
	<class native="TonemappingSettings" script="TonemappingSettings">
		<doc>Settings that control tonemap post-process.</doc>
		<ctor>
		</ctor>
		<property name="FilmicCurveShoulderStrength" type="float" getter="getfilmicCurveShoulderStrength" setter="setfilmicCurveShoulderStrength" static="false">
			<doc>Controls the shoulder (upper non-linear) section of the filmic curve used for tonemapping. Mostly affects bright areas of the image and allows you to reduce over-exposure.</doc>
		</property>
		<property name="FilmicCurveLinearStrength" type="float" getter="getfilmicCurveLinearStrength" setter="setfilmicCurveLinearStrength" static="false">
			<doc>Controls the linear (middle) section of the filmic curve used for tonemapping. Mostly affects mid-range areas of the image.</doc>
		</property>
		<property name="FilmicCurveLinearAngle" type="float" getter="getfilmicCurveLinearAngle" setter="setfilmicCurveLinearAngle" static="false">
			<doc>Controls the linear (middle) section of the filmic curve used for tonemapping. Mostly affects mid-range areas of the image and allows you to control how quickly does the curve climb.</doc>
		</property>
		<property name="FilmicCurveToeStrength" type="float" getter="getfilmicCurveToeStrength" setter="setfilmicCurveToeStrength" static="false">
			<doc>Controls the toe (lower non-linear) section of the filmic curve used for tonemapping. Mostly affects dark areas of the image and allows you to reduce under-exposure.</doc>
		</property>
		<property name="FilmicCurveToeNumerator" type="float" getter="getfilmicCurveToeNumerator" setter="setfilmicCurveToeNumerator" static="false">
			<doc>Controls the toe (lower non-linear) section of the filmic curve. used for tonemapping. Affects low-range.</doc>
		</property>
		<property name="FilmicCurveToeDenominator" type="float" getter="getfilmicCurveToeDenominator" setter="setfilmicCurveToeDenominator" static="false">
			<doc>Controls the toe (lower non-linear) section of the filmic curve used for tonemapping. Affects low-range.</doc>
		</property>
		<property name="FilmicCurveLinearWhitePoint" type="float" getter="getfilmicCurveLinearWhitePoint" setter="setfilmicCurveLinearWhitePoint" static="false">
			<doc>Controls the white point of the filmic curve used for tonemapping. Affects the entire curve.</doc>
		</property>
	</class>
	<class native="WhiteBalanceSettings" script="WhiteBalanceSettings">
		<doc>Settings that control white balance post-process.</doc>
		<ctor>
		</ctor>
		<property name="Temperature" type="float" getter="gettemperature" setter="settemperature" static="false">
			<doc>Temperature used for white balancing, in Kelvins.
Moves along the Planckian locus. In range [1500.0f, 15000.0f].</doc>
		</property>
		<property name="Tint" type="float" getter="gettint" setter="settint" static="false">
			<doc>Additional tint to be applied during white balancing. Can be used to further tweak the white balancing effect by modifying the tint of the light. The tint is chosen on the Planckian locus isothermal, depending on the light temperature specified by #temperature.
In range [-1.0f, 1.0f].</doc>
		</property>
	</class>
	<class native="ShaderImportOptions" script="ShaderImportOptions">
		<doc>Contains import options you may use to control how is a shader imported.</doc>
		<method native="setDefine" script="SetDefine" static="false">
			<doc>Sets a define and its value. Replaces an existing define if one already exists with the provided name.</doc>
			<param name="define" type="string">
				<doc>Name of the define.</doc>
			</param>
			<param name="value" type="string">
				<doc>Value to assign to the define.</doc>
			</param>
		</method>
		<method native="getDefine" script="GetDefine" static="false">
			<doc>Checks if the define exists and returns its value if it does.</doc>
			<param name="define" type="string">
				<doc>Name of the define to get the value for.</doc>
			</param>
			<param name="value" type="string">
				<doc>value of the define. Only defined if the method returns true.</doc>
			</param>
			<returns type="bool">
				<doc>True if the define was found, false otherwise.</doc>
			</returns>
		</method>
		<method native="hasDefine" script="HasDefine" static="false">
			<doc>Checks if the provided define exists.</doc>
			<param name="define" type="string">
				<doc>Name of the define to check.</doc>
			</param>
			<returns type="bool">
				<doc>True if the define was found, false otherwise.</doc>
			</returns>
		</method>
		<method native="removeDefine" script="RemoveDefine" static="false">
			<doc>Unregisters a previously set define.</doc>
			<param name="define" type="string">
				<doc>Name of the define to unregister.</doc>
			</param>
		</method>
		<ctor>
			<doc>Creates a new import options object that allows you to customize how are meshes imported.</doc>
		</ctor>
		<property name="Languages" type="ShadingLanguageFlags" getter="getlanguages" setter="setlanguages" static="false">
			<doc>Flags that control which shading languages should the BSL shader be converted into. This ultimately controls on which render backends it will be able to run on.</doc>
		</property>
	</class>
	<class native="ColorGradingSettings" script="ColorGradingSettings">
		<doc>Settings that control color grading post-process.</doc>
		<property name="Saturation" type="Vector3" getter="getsaturation" setter="setsaturation" static="false">
			<doc>Saturation to be applied during color grading. Larger values increase vibrancy of the image. In range [0.0f, 2.0f].</doc>
		</property>
		<property name="Contrast" type="Vector3" getter="getcontrast" setter="setcontrast" static="false">
			<doc>Contrast to be applied during color grading. Larger values increase difference between light and dark areas of the image. In range [0.0f, 2.0f].</doc>
		</property>
		<property name="Gain" type="Vector3" getter="getgain" setter="setgain" static="false">
			<doc>Gain to be applied during color grading. Simply increases all color values by an equal scale. In range [0.0f, 2.0f].</doc>
		</property>
		<property name="Offset" type="Vector3" getter="getoffset" setter="setoffset" static="false">
			<doc>Gain to be applied during color grading. Simply offsets all color values by an equal amount. In range [-1.0f, 1.0f].</doc>
		</property>
	</class>
	<enum native="DepthOfFieldType" script="DepthOfFieldType">
		<doc>Types of available depth of field effects.</doc>
		<enumentry native="Gaussian" script="Gaussian">
			<doc>Fastest depth of field variant, uses gaussian blur to approximate depth of field on near and far objects, but doesn&apos;t use any physically based methods for determining blur amount.</doc>
		</enumentry>
		<enumentry native="Bokeh" script="Bokeh">
			<doc>Very expensive depth of field variant that allows you to use a bokeh texture, controlling the shape of the blur (usually intended to mimic real world camera aperature shapes). Blur is varied according to actual object distance and the effect is more physically based than gaussian blur (but not completely). Very expensive in terms of performance.</doc>
		</enumentry>
	</enum>
	<class native="ScriptCodeImportOptions" script="ScriptCodeImportOptions">
		<doc>Contains import options you may use to control how is a file containing script source code importer.</doc>
		<ctor>
			<doc>Creates a new import options object that allows you to customize how is script code imported.</doc>
		</ctor>
		<property name="EditorScript" type="bool" getter="geteditorScript" setter="seteditorScript" static="false">
			<doc>Determines whether the script is editor-only or a normal game script.</doc>
		</property>
	</class>
	<class native="DepthOfFieldSettings" script="DepthOfFieldSettings">
		<doc>Settings that control the depth-of-field effect.</doc>
		<ctor>
		</ctor>
		<property name="BokehShape" type="RRef&lt;Texture&gt;" getter="getbokehShape" setter="setbokehShape" static="false">
			<doc>Texture to use for the bokeh shape. Only relevant when using Bokeh depth of field.</doc>
		</property>
		<property name="Enabled" type="bool" getter="getenabled" setter="setenabled" static="false">
			<doc>Enables or disables the depth of field effect.</doc>
		</property>
		<property name="Type" type="DepthOfFieldType" getter="gettype" setter="settype" static="false">
			<doc>Type of depth of field effect to use.</doc>
		</property>
		<property name="FocalDistance" type="float" getter="getfocalDistance" setter="setfocalDistance" static="false">
			<doc>Distance from the camera at which the focal plane is located in. Objects at this distance will be fully in focus. In world units (meters).</doc>
		</property>
		<property name="FocalRange" type="float" getter="getfocalRange" setter="setfocalRange" static="false">
			<doc>Range within which the objects remain fully in focus. This range is applied relative to the focal distance. This parameter should usually be non-zero when using the Gaussian depth of field effect. When using other types of depth-of-field you can set this to zero for a more physically-based effect, or keep it non-zero for more artistic control. In world units (meters).</doc>
		</property>
		<property name="NearTransitionRange" type="float" getter="getnearTransitionRange" setter="setnearTransitionRange" static="false">
			<doc>Determines the size of the range within which objects transition from focused to fully unfocused, at the near  plane. Only relevant for Gaussian and Bokeh depth of field. In world units (meters).</doc>
		</property>
		<property name="FarTransitionRange" type="float" getter="getfarTransitionRange" setter="setfarTransitionRange" static="false">
			<doc>Determines the size of the range within which objects transition from focused to fully unfocused, at the far  plane. Only relevant for Gaussian and Bokeh depth of field. In world units (meters).</doc>
		</property>
		<property name="NearBlurAmount" type="float" getter="getnearBlurAmount" setter="setnearBlurAmount" static="false">
			<doc>Determines the amount of blur to apply to fully unfocused objects that are closer to camera than the in-focus zone. Set to zero to disable near-field blur. Only relevant for Gaussian depth of field.</doc>
		</property>
		<property name="FarBlurAmount" type="float" getter="getfarBlurAmount" setter="setfarBlurAmount" static="false">
			<doc>Determines the amount of blur to apply to fully unfocused objects that are farther away from camera than the in-focus zone. Set to zero to disable far-field blur. Only relevant for Gaussian depth of field.</doc>
		</property>
		<property name="MaxBokehSize" type="float" getter="getmaxBokehSize" setter="setmaxBokehSize" static="false">
			<doc>Determines the maximum size of the blur kernel, in percent of view size. Larger values cost more performance.  Only relevant when using Bokeh depth of field.</doc>
		</property>
		<property name="AdaptiveColorThreshold" type="float" getter="getadaptiveColorThreshold" setter="setadaptiveColorThreshold" static="false">
			<doc>Determines the maximum color difference between surrounding pixels allowed (as a sum of all channels) before higher fidelity sampling is triggered. Increasing this value can improve performance as less higher fidelity samples will be required, but may decrease quality of the effect. Only relevant when using Bokeh depth of field.</doc>
		</property>
		<property name="AdaptiveRadiusThreshold" type="float" getter="getadaptiveRadiusThreshold" setter="setadaptiveRadiusThreshold" static="false">
			<doc>Determines the minimum circle of confusion size before higher fidelity sampling is triggered. Small values trigger high fidelity sampling because they can otherwise produce aliasing, and they are small enough so they don&apos;t cost much. Increasing this value can improve performance as less higher fidelity samples will be required,  but may decrease quality of the effect. Only relevant when using Bokeh depth of field.</doc>
		</property>
		<property name="ApertureSize" type="float" getter="getapertureSize" setter="setapertureSize" static="false">
			<doc>Camera aperture size in mm. Only relevant when using Bokeh depth of field.</doc>
		</property>
		<property name="FocalLength" type="float" getter="getfocalLength" setter="setfocalLength" static="false">
			<doc>Focal length of the camera&apos;s lens (e.g. 75mm). Only relevant when using Bokeh depth of field.</doc>
		</property>
		<property name="SensorSize" type="Vector2" getter="getsensorSize" setter="setsensorSize" static="false">
			<doc>Camera sensor width and height, in mm. Used for controlling the size of the circle of confusion. Only relevant  when using Bokeh depth of field.</doc>
		</property>
		<property name="BokehOcclusion" type="bool" getter="getbokehOcclusion" setter="setbokehOcclusion" static="false">
			<doc>Set to true if Bokeh flare should use soft depth testing to ensure they don&apos;t render on top of foreground geometry. This can help reduce background bleeding into the foreground, which can be especially noticeable if the background is much brighter than the foreground. Use <see cref="occlusionDepthRange"/> to tweak the effect.</doc>
		</property>
		<property name="OcclusionDepthRange" type="float" getter="getocclusionDepthRange" setter="setocclusionDepthRange" static="false">
			<doc>Range in world units over which range to fade out Bokeh flare influence. Influence of the flare will be faded out as the depth difference between the flare&apos;s origin pixel and the destination pixel grows larger. Only relevant if <see cref="bokehOcclusion"/> is turned on.</doc>
		</property>
	</class>
	<enum native="MotionBlurDomain" script="MotionBlurDomain">
		<doc>Determines which parts of the scene will trigger motion blur.</doc>
		<enumentry native="CameraOnly" script="CameraOnly">
			<doc>Camera movement and rotation will result in full-screen motion blur.</doc>
		</enumentry>
		<enumentry native="ObjectOnly" script="ObjectOnly">
			<doc>Object movement and rotation will result in blurring of the moving object. Can be significantly more expensive than just using camera blur due to the requirement to use a velocity buffer (unless some other effect also requires it, in which case it will be re-used).</doc>
		</enumentry>
		<enumentry native="CameraAndObject" script="CameraAndObject">
			<doc>Both the camera movement and object movement will result in motion blur.</doc>
		</enumentry>
	</enum>
	<struct native="SubMesh" script="SubMesh">
		<doc>Data about a sub-mesh range and the type of primitives contained in the range.</doc>
		<ctor>
		</ctor>
		<ctor>
			<param name="indexOffset" type="int">
			</param>
			<param name="indexCount" type="int">
			</param>
			<param name="drawOp" type="MeshTopology">
			</param>
		</ctor>
		<field name="indexOffset" type="int">
		</field>
		<field name="indexCount" type="int">
		</field>
		<field name="drawOp" type="MeshTopology">
		</field>
	</struct>
	<class native="ImportedAnimationEvents" script="ImportedAnimationEvents">
		<doc>A set of animation events that will be added to an animation clip during animation import.</doc>
		<ctor>
		</ctor>
		<property name="Name" type="string" getter="getname" setter="setname" static="false">
		</property>
		<property name="Events" type="AnimationEvent" getter="getevents" setter="setevents" static="false">
		</property>
	</class>
	<enum native="MotionBlurFilter" script="MotionBlurFilter">
		<doc>Type of filter to use when filtering samples contributing to a blurred pixel.</doc>
		<enumentry native="Simple" script="Simple">
			<doc>Samples will be simply averaged together to create the blurred pixel.</doc>
		</enumentry>
		<enumentry native="Reconstruction" script="Reconstruction">
			<doc>A more advanced reconstruction filter will be used. This filter provides better blur quality at a performance cost. In particular the filter will improve blurring at object boundaries, allowing blur to extend beyond the object silhouette. It will also try to estimate blurred background and provide better weighting between background, center and foreground samples.</doc>
		</enumentry>
	</enum>
	<enum native="MotionBlurQuality" script="MotionBlurQuality">
		<doc>Determines the number of samples to take during motion blur filtering.</doc>
		<enumentry native="VeryLow" script="VeryLow">
			<doc>4 samples per pixel.</doc>
		</enumentry>
		<enumentry native="Low" script="Low">
			<doc>6 samples per pixel.</doc>
		</enumentry>
		<enumentry native="Medium" script="Medium">
			<doc>8 samples per pixel.</doc>
		</enumentry>
		<enumentry native="High" script="High">
			<doc>12 samples per pixel.</doc>
		</enumentry>
		<enumentry native="Ultra" script="Ultra">
			<doc>16 samples per pixel.</doc>
		</enumentry>
	</enum>
	<class native="ScreenSpaceReflectionsSettings" script="ScreenSpaceReflectionsSettings">
		<doc>Settings that control the screen space reflections effect. Screen space reflections provide high quality mirror-like reflections at low performance cost. They should be used together with reflection probes as the effects complement each other. As the name implies, the reflections are only limited to geometry drawn on the screen and the system will fall back to refl. probes when screen space data is unavailable. Similarly the system will fall back to refl. probes for rougher (more glossy rather than mirror-like) surfaces. Those surfaces require a higher number of samples to achieve the glossy look, so we instead fall back to refl. probes which are pre-filtered and can be quickly sampled.</doc>
		<ctor>
		</ctor>
		<property name="Enabled" type="bool" getter="getenabled" setter="setenabled" static="false">
			<doc>Enables or disables the SSR effect.</doc>
		</property>
		<property name="Quality" type="int" getter="getquality" setter="setquality" static="false">
			<doc>Quality of the SSR effect. Higher values cast more sample rays, and march those rays are lower increments for better precision. This results in higher quality, as well as a higher performance requirement. Valid range is [0, 4], default is 2.</doc>
		</property>
		<property name="Intensity" type="float" getter="getintensity" setter="setintensity" static="false">
			<doc>Intensity of the screen space reflections. Valid range is [0, 1]. Default is 1 (100%).</doc>
		</property>
		<property name="MaxRoughness" type="float" getter="getmaxRoughness" setter="setmaxRoughness" static="false">
			<doc>Roughness at which screen space reflections start fading out and become replaced with refl. probes. Valid range is [0, 1]. Default is 0.8.</doc>
		</property>
	</class>
	<class native="CHingeJoint" script="HingeJoint">
		<doc>Hinge joint removes all but a single rotation degree of freedom from its two attached bodies (for example a door hinge).</doc>
		<method native="setFlag" script="SetFlag" static="false">
			<doc>Enables or disables a flag that controls joint behaviour.</doc>
			<param name="flag" type="HingeJointFlag">
			</param>
			<param name="enabled" type="bool">
			</param>
		</method>
		<method native="hasFlag" script="HasFlag" static="false">
			<doc>Checks is the specified option enabled.</doc>
			<param name="flag" type="HingeJointFlag">
			</param>
			<returns type="bool">
			</returns>
		</method>
		<property name="Angle" type="Radian" getter="getAngle" setter="" static="false">
			<doc>Returns the current angle between the two attached bodes.</doc>
		</property>
		<property name="Speed" type="float" getter="getSpeed" setter="" static="false">
			<doc>Returns the current angular speed of the joint.</doc>
		</property>
		<property name="Limit" type="LimitAngularRange" getter="getLimit" setter="setLimit" static="false">
			<doc>Determines the limit of the joint. Limit constrains the motion to the specified angle range. You must enable the limit flag on the joint in order for this to be recognized.</doc>
		</property>
		<property name="Drive" type="HingeJointDrive" getter="getDrive" setter="setDrive" static="false">
			<doc>Determines the drive properties of the joint. It drives the joint&apos;s angular velocity towards a particular value. You must enable the drive flag on the joint in order for the drive to be active.</doc>
		</property>
	</class>
	<class native="ChromaticAberrationSettings" script="ChromaticAberrationSettings">
		<doc>Settings that control the chromatic aberration effect.</doc>
		<ctor>
		</ctor>
		<property name="FringeTexture" type="RRef&lt;Texture&gt;" getter="getfringeTexture" setter="setfringeTexture" static="false">
			<doc>Optional texture to apply to generate the channel shift fringe, allowing you to modulate the shifted colors. This texture should be 3x1 size, where the first pixel modules red, second green and third blue channel. If using the complex aberration effect you can use a larger texture, Nx1 size.</doc>
		</property>
		<property name="Enabled" type="bool" getter="getenabled" setter="setenabled" static="false">
			<doc>Enables or disables the effect.</doc>
		</property>
		<property name="Type" type="ChromaticAberrationType" getter="gettype" setter="settype" static="false">
			<doc>Type of algorithm to use for rendering the effect.</doc>
		</property>
		<property name="ShiftAmount" type="float" getter="getshiftAmount" setter="setshiftAmount" static="false">
			<doc>Determines the brightness of the lens flare effect. Value of 1 means the lens flare will be displayed at the same intensity as the scene it was derived from. In range [0, 1], default being 0.05.</doc>
		</property>
	</class>
	<class native="FilmGrainSettings" script="FilmGrainSettings">
		<doc>Settings that control the film grain effect. Film grains adds a time-varying noise effect over the entire image.</doc>
		<ctor>
		</ctor>
		<property name="Enabled" type="bool" getter="getenabled" setter="setenabled" static="false">
			<doc>Enables or disables the effect.</doc>
		</property>
		<property name="Intensity" type="float" getter="getintensity" setter="setintensity" static="false">
			<doc>Controls how intense are the displayed film grains.</doc>
		</property>
		<property name="Speed" type="float" getter="getspeed" setter="setspeed" static="false">
			<doc>Controls at what speed do the film grains change.</doc>
		</property>
	</class>
	<class native="ShadowSettings" script="ShadowSettings">
		<doc>Various options that control shadow rendering for a specific view.</doc>
		<ctor>
		</ctor>
		<property name="DirectionalShadowDistance" type="float" getter="getdirectionalShadowDistance" setter="setdirectionalShadowDistance" static="false">
			<doc>Maximum distance that directional light shadows are allowed to render at. Decreasing the distance can yield higher quality shadows nearer to the viewer, as the shadow map resolution isn&apos;t being used up on far away portions of the scene. In world units (meters).</doc>
		</property>
		<property name="NumCascades" type="int" getter="getnumCascades" setter="setnumCascades" static="false">
			<doc>Number of cascades to use for directional shadows. Higher number of cascades increases shadow quality as each individual cascade has less area to cover, but can significantly increase performance cost, as well as a minor increase in memory cost. Valid range is roughly [1, 6].</doc>
		</property>
		<property name="CascadeDistributionExponent" type="float" getter="getcascadeDistributionExponent" setter="setcascadeDistributionExponent" static="false">
			<doc>Allows you to control how are directional shadow cascades distributed. Value of 1 means the cascades will be linearly split, each cascade taking up the same amount of space. Value of 2 means each subsequent split will be twice the size of the previous one (meaning cascades closer to the viewer cover a smaller area, and therefore yield higher resolution shadows). Higher values increase the size disparity between near and far cascades at an exponential rate. Valid range is roughly [1, 4].</doc>
		</property>
		<property name="ShadowFilteringQuality" type="int" getter="getshadowFilteringQuality" setter="setshadowFilteringQuality" static="false">
			<doc>Determines the number of samples used for percentage closer shadow map filtering. Higher values yield higher quality shadows, at the cost of performance. Valid range is [1, 4].</doc>
		</property>
	</class>
	<class native="RenderSettings" script="RenderSettings">
		<doc>Settings that control rendering for a specific camera (view).</doc>
		<ctor>
		</ctor>
		<property name="DepthOfField" type="DepthOfFieldSettings" getter="getdepthOfField" setter="setdepthOfField" static="false">
			<doc>Parameters used for customizing the gaussian depth of field effect.</doc>
		</property>
		<property name="ChromaticAberration" type="ChromaticAberrationSettings" getter="getchromaticAberration" setter="setchromaticAberration" static="false">
			<doc>Parameters used for customizing the chromatic aberration effect.</doc>
		</property>
		<property name="EnableAutoExposure" type="bool" getter="getenableAutoExposure" setter="setenableAutoExposure" static="false">
			<doc>Determines should automatic exposure be applied to the HDR image. When turned on the average scene brightness will be calculated and used to automatically expose the image to the optimal range. Use the parameters provided by autoExposure to customize the automatic exposure effect. You may also use exposureScale to manually adjust the automatic exposure. When automatic exposure is turned off you can use exposureScale to manually set the exposure.</doc>
		</property>
		<property name="AutoExposure" type="AutoExposureSettings" getter="getautoExposure" setter="setautoExposure" static="false">
			<doc>Parameters used for customizing automatic scene exposure.</doc>
		</property>
		<property name="EnableTonemapping" type="bool" getter="getenableTonemapping" setter="setenableTonemapping" static="false">
			<doc>Determines should the image be tonemapped. Tonemapping converts an HDR image into LDR image by applying a filmic curve to the image, simulating the effect of film cameras. Filmic curve improves image quality by tapering off lows and highs, preventing under- and over-exposure. This is useful if an image contains both very dark and very bright areas, in which case the global exposure parameter would leave some areas either over- or under-exposed. Use #tonemapping to customize how tonemapping performed.
If this is disabled, then color grading and white balancing will not be enabled either. Only relevant for HDR images.</doc>
		</property>
		<property name="Tonemapping" type="TonemappingSettings" getter="gettonemapping" setter="settonemapping" static="false">
			<doc>Parameters used for customizing tonemapping.</doc>
		</property>
		<property name="WhiteBalance" type="WhiteBalanceSettings" getter="getwhiteBalance" setter="setwhiteBalance" static="false">
			<doc>Parameters used for customizing white balancing. White balancing converts a scene illuminated by a light of the specified temperature into a scene illuminated by a standard D65 illuminant (average midday light) in order to simulate the effects of chromatic adaptation of the human visual system.</doc>
		</property>
		<property name="ColorGrading" type="ColorGradingSettings" getter="getcolorGrading" setter="setcolorGrading" static="false">
			<doc>Parameters used for customizing color grading.</doc>
		</property>
		<property name="AmbientOcclusion" type="AmbientOcclusionSettings" getter="getambientOcclusion" setter="setambientOcclusion" static="false">
			<doc>Parameters used for customizing screen space ambient occlusion.</doc>
		</property>
		<property name="ScreenSpaceReflections" type="ScreenSpaceReflectionsSettings" getter="getscreenSpaceReflections" setter="setscreenSpaceReflections" static="false">
			<doc>Parameters used for customizing screen space reflections.</doc>
		</property>
		<property name="Bloom" type="BloomSettings" getter="getbloom" setter="setbloom" static="false">
			<doc>Parameters used for customizing the bloom effect.</doc>
		</property>
		<property name="ScreenSpaceLensFlare" type="ScreenSpaceLensFlareSettings" getter="getscreenSpaceLensFlare" setter="setscreenSpaceLensFlare" static="false">
			<doc>Parameters used for customizing the screen space lens flare effect.</doc>
		</property>
		<property name="FilmGrain" type="FilmGrainSettings" getter="getfilmGrain" setter="setfilmGrain" static="false">
			<doc>Parameters used for customizing the film grain effect.</doc>
		</property>
		<property name="MotionBlur" type="MotionBlurSettings" getter="getmotionBlur" setter="setmotionBlur" static="false">
			<doc>Parameters used for customizing the motion blur effect.</doc>
		</property>
		<property name="TemporalAA" type="TemporalAASettings" getter="gettemporalAA" setter="settemporalAA" static="false">
			<doc>Parameters used for customizing the temporal anti-aliasing effect.</doc>
		</property>
		<property name="EnableFXAA" type="bool" getter="getenableFXAA" setter="setenableFXAA" static="false">
			<doc>Enables the fast approximate anti-aliasing effect.</doc>
		</property>
		<property name="ExposureScale" type="float" getter="getexposureScale" setter="setexposureScale" static="false">
			<doc>Log2 value to scale the eye adaptation by (for example 2^0 = 1). Smaller values yield darker image, while larger yield brighter image. Allows you to customize exposure manually, applied on top of eye adaptation exposure (if enabled). In range [-8, 8].</doc>
		</property>
		<property name="Gamma" type="float" getter="getgamma" setter="setgamma" static="false">
			<doc>Gamma value to adjust the image for. Larger values result in a brighter image. When tonemapping is turned on the best gamma curve for the output device is chosen automatically and this value can by used to merely tweak that curve. If tonemapping is turned off this is the exact value of the gamma curve that will be applied.</doc>
		</property>
		<property name="EnableHDR" type="bool" getter="getenableHDR" setter="setenableHDR" static="false">
			<doc>High dynamic range allows light intensity to be more correctly recorded when rendering by allowing for a larger range of values. The stored light is then converted into visible color range using exposure and a tone mapping operator.</doc>
		</property>
		<property name="EnableLighting" type="bool" getter="getenableLighting" setter="setenableLighting" static="false">
			<doc>Determines if scene objects will be lit by lights. If disabled everything will be rendered using their albedo texture with no lighting applied.</doc>
		</property>
		<property name="EnableShadows" type="bool" getter="getenableShadows" setter="setenableShadows" static="false">
			<doc>Determines if shadows cast by lights should be rendered. Only relevant if lighting is turned on.</doc>
		</property>
		<property name="EnableVelocityBuffer" type="bool" getter="getenableVelocityBuffer" setter="setenableVelocityBuffer" static="false">
			<doc>Determines if the G-Buffer should contain per-pixel velocity information. This can be useful if you are rendering an effect that requires this information. Note that effects such as motion blur or temporal anti-aliasing might force the velocity buffer to be enabled regardless of this setting.</doc>
		</property>
		<property name="ShadowSettings" type="ShadowSettings" getter="getshadowSettings" setter="setshadowSettings" static="false">
			<doc>Parameters used for customizing shadow rendering.</doc>
		</property>
		<property name="EnableIndirectLighting" type="bool" getter="getenableIndirectLighting" setter="setenableIndirectLighting" static="false">
			<doc>Determines if indirect lighting (e.g. from light probes or the sky) is rendered.</doc>
		</property>
		<property name="OverlayOnly" type="bool" getter="getoverlayOnly" setter="setoverlayOnly" static="false">
			<doc>Signals the renderer to only render overlays (like GUI), and not scene objects. Such rendering doesn&apos;t require depth buffer or multi-sampled render targets and will not render any scene objects. This can improve performance and memory usage for overlay-only views.</doc>
		</property>
		<property name="EnableSkybox" type="bool" getter="getenableSkybox" setter="setenableSkybox" static="false">
			<doc>If enabled the camera will use the skybox for rendering the background. A skybox has to be present in the scene. When disabled the camera will use the clear color for rendering the background.</doc>
		</property>
		<property name="CullDistance" type="float" getter="getcullDistance" setter="setcullDistance" static="false">
			<doc>The absolute base cull-distance for objects rendered through this camera in world units. Objects will use this distance and apply their own factor to it to determine whether they should be visible.</doc>
		</property>
	</class>
	<enum native="CameraFlag" script="CameraFlag">
		<doc>Flags for controlling Camera options.</doc>
		<enumentry native="OnDemand" script="OnDemand">
			<doc>If set the camera will only render when requested by the user through Camera::notifyNeedsRedraw(). Otherwise the camera will render every frame (unless disabled).</doc>
		</enumentry>
	</enum>
	<class native="CCapsuleCollider" script="CapsuleCollider">
		<doc>Collider with a capsule geometry.</doc>
		<property name="Normal" type="Vector3" getter="getNormal" setter="setNormal" static="false">
			<doc>Normal vector that determines how is the capsule oriented.</doc>
		</property>
		<property name="Center" type="Vector3" getter="getCenter" setter="setCenter" static="false">
			<doc>Determines the position of the capsule shape, relative to the component&apos;s scene object.</doc>
		</property>
		<property name="HalfHeight" type="float" getter="getHalfHeight" setter="setHalfHeight" static="false">
			<doc>Determines the half height of the capsule, from the origin to one of the hemispherical centers, along the normal vector.</doc>
		</property>
		<property name="Radius" type="float" getter="getRadius" setter="setRadius" static="false">
			<doc>Determines the radius of the capsule.</doc>
		</property>
	</class>
	<enum native="CharacterClimbingMode" script="CharacterClimbingMode">
		<doc>Controls climbing behaviour for a capsule character controller. Normally the character controller will not automatically climb when heights are greater than the assigned step offset. However due to the shape of the capsule it might automatically climb over slightly larger heights than assigned step offsets.</doc>
		<enumentry native="Normal" script="Normal">
			<doc>Normal behaviour. Capsule character controller will be able to auto-step even above the step offset.</doc>
		</enumentry>
		<enumentry native="Constrained" script="Constrained">
			<doc>The system will attempt to limit auto-step to the provided step offset and no higher.</doc>
		</enumentry>
	</enum>
	<enum native="CharacterNonWalkableMode" script="CharacterNonWalkableMode">
		<doc>Controls behaviour when a character controller reaches a slope thats larger than its slope offset.</doc>
		<enumentry native="Prevent" script="Prevent">
			<doc>Character will be prevented from going further, but will be allowed to move laterally.</doc>
		</enumentry>
		<enumentry native="PreventAndSlide" script="PreventAndSlide">
			<doc>Character will be prevented from going further, but also slide down the slope.</doc>
		</enumentry>
	</enum>
	<class native="ParticleForce" script="ParticleForce">
		<doc>Applies an arbitrary force to the particles.</doc>
		<ctor>
			<doc>Creates a new particle force evolver.</doc>
			<param name="desc" type="ParticleForceOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle force evolver.</doc>
		</ctor>
		<property name="Options" type="ParticleForceOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the evolver.</doc>
		</property>
	</class>
	<enum native="CharacterCollisionFlag" script="CharacterCollisionFlag">
		<doc>Reports in which directions is the character colliding with other objects.</doc>
		<enumentry native="Sides" script="Sides">
			<doc>Character is colliding with its sides.</doc>
		</enumentry>
		<enumentry native="Up" script="Up">
			<doc>Character is colliding with the ceiling.</doc>
		</enumentry>
		<enumentry native="Down" script="Down">
			<doc>Character is colliding with the ground.</doc>
		</enumentry>
	</enum>
	<struct native="GUIContentImages" script="GUIContentImages">
		<doc>Contains separate GUI content images for every possible GUI element state.</doc>
		<ctor>
		</ctor>
		<ctor>
			<param name="image" type="SpriteTexture">
			</param>
		</ctor>
		<field name="normal" type="SpriteTexture">
		</field>
		<field name="hover" type="SpriteTexture">
		</field>
		<field name="active" type="SpriteTexture">
		</field>
		<field name="focused" type="SpriteTexture">
		</field>
		<field name="normalOn" type="SpriteTexture">
		</field>
		<field name="hoverOn" type="SpriteTexture">
		</field>
		<field name="activeOn" type="SpriteTexture">
		</field>
		<field name="focusedOn" type="SpriteTexture">
		</field>
	</struct>
	<struct native="ControllerCollision" script="ControllerCollision">
		<doc>Contains data about a collision of a character controller and another object.</doc>
		<field name="position" type="Vector3">
			<doc>Contact position.</doc>
		</field>
		<field name="normal" type="Vector3">
			<doc>Contact normal.</doc>
		</field>
		<field name="motionDir" type="Vector3">
			<doc>Direction of motion after the hit.</doc>
		</field>
		<field name="motionAmount" type="float">
			<doc>Magnitude of motion after the hit.</doc>
		</field>
	</struct>
	<struct native="ControllerColliderCollision" script="ControllerColliderCollision">
		<doc>Contains data about a collision of a character controller and a collider.</doc>
		<field name="collider" type="Collider">
			<doc>Component of the controller that was touched. Can be null if the controller has no component parent, in which case check #colliderRaw.</doc>
		</field>
		<field name="triangleIndex" type="int">
			<doc>Touched triangle index for mesh colliders.</doc>
		</field>
		<field name="position" type="Vector3">
			<doc>Contact position.</doc>
		</field>
		<field name="normal" type="Vector3">
			<doc>Contact normal.</doc>
		</field>
		<field name="motionDir" type="Vector3">
			<doc>Direction of motion after the hit.</doc>
		</field>
		<field name="motionAmount" type="float">
			<doc>Magnitude of motion after the hit.</doc>
		</field>
	</struct>
	<class native="RendererMeshData" script="MeshData">
		<doc>Contains mesh vertex and index data used for initializing, updating and reading mesh data from Mesh.</doc>
		<ctor>
			<param name="numVertices" type="int">
			</param>
			<param name="numIndices" type="int">
			</param>
			<param name="layout" type="VertexLayout">
			</param>
			<param name="indexType" type="IndexType">
			</param>
		</ctor>
		<property name="Positions" type="Vector3" getter="getPositions" setter="setPositions" static="false">
			<doc>An array of all vertex positions. Only valid if the vertex layout contains vertex positions.</doc>
		</property>
		<property name="Normals" type="Vector3" getter="getNormals" setter="setNormals" static="false">
			<doc>An array of all vertex normals. Only valid if the vertex layout contains vertex normals.</doc>
		</property>
		<property name="Tangents" type="Vector4" getter="getTangents" setter="setTangents" static="false">
			<doc>An array of all vertex tangents. Only valid if the vertex layout contains vertex tangents.</doc>
		</property>
		<property name="Colors" type="Color" getter="getColors" setter="setColors" static="false">
			<doc>An array of all vertex colors. Only valid if the vertex layout contains vertex colors.</doc>
		</property>
		<property name="UV0" type="Vector2" getter="getUV0" setter="setUV0" static="false">
			<doc>An array of all vertex texture coordinates in the UV0 channel. Only valid if the vertex layout contains UV0 coordinates.</doc>
		</property>
		<property name="UV1" type="Vector2" getter="getUV1" setter="setUV1" static="false">
			<doc>An array of all vertex texture coordinates in the UV1 channel. Only valid if the vertex layout contains UV1 coordinates.</doc>
		</property>
		<property name="BoneWeights" type="BoneWeight" getter="getBoneWeights" setter="setBoneWeights" static="false">
			<doc>An array of all vertex bone weights. Only valid if the vertex layout contains bone weights.</doc>
		</property>
		<property name="Indices" type="int" getter="getIndices" setter="setIndices" static="false">
			<doc>An array of all indices.</doc>
		</property>
		<property name="VertexCount" type="int" getter="getVertexCount" setter="" static="false">
			<doc>Returns the number of vertices contained in the mesh.</doc>
		</property>
		<property name="IndexCount" type="int" getter="getIndexCount" setter="" static="false">
			<doc>Returns the number of indices contained in the mesh.</doc>
		</property>
	</class>
	<enum native="SpriteAnimationPlayback" script="SpriteAnimationPlayback">
		<doc>Type of playback to use for an animation of a SpriteTexture.</doc>
		<enumentry native="None" script="None">
			<doc>Do not animate.</doc>
		</enumentry>
		<enumentry native="Normal" script="Normal">
			<doc>Animate once until the end of the animation is reached.</doc>
		</enumentry>
		<enumentry native="Loop" script="Loop">
			<doc>Animate to the end of the animation then loop around.</doc>
		</enumentry>
		<enumentry native="PingPong" script="PingPong">
			<doc>Loop the animation but reverse playback when the end is reached.</doc>
		</enumentry>
	</enum>
	<struct native="ControllerControllerCollision" script="ControllerControllerCollision">
		<doc>Contains data about a collision between two character controllers.</doc>
		<field name="controller" type="CharacterController">
			<doc>Component of the controller that was touched. Can be null if the controller has no component parent, in which case check #controllerRaw.</doc>
		</field>
		<field name="position" type="Vector3">
			<doc>Contact position.</doc>
		</field>
		<field name="normal" type="Vector3">
			<doc>Contact normal.</doc>
		</field>
		<field name="motionDir" type="Vector3">
			<doc>Direction of motion after the hit.</doc>
		</field>
		<field name="motionAmount" type="float">
			<doc>Magnitude of motion after the hit.</doc>
		</field>
	</struct>
	<struct native="LightProbeInfo" script="LightProbeInfo">
		<doc>Information about a single probe in the light probe volume.</doc>
		<field name="handle" type="int">
		</field>
		<field name="position" type="Vector3">
		</field>
	</struct>
	<enum native="JointBody" script="JointBody">
		<doc>Specifies first or second body referenced by a Joint.</doc>
		<enumentry native="Target" script="Target">
			<doc>Body the joint is influencing.</doc>
		</enumentry>
		<enumentry native="Anchor" script="Anchor">
			<doc>Body the joint is attached to (if any).</doc>
		</enumentry>
	</enum>
	<struct native="Spring" script="Spring">
		<doc>Controls spring parameters for a physics joint limits. If a limit is soft (body bounces back due to restition when the limit is reached) the spring will pull the body back towards the limit using the specified parameters.</doc>
		<ctor>
			<doc>Constructs a spring with no force.</doc>
		</ctor>
		<ctor>
			<doc>Constructs a spring.</doc>
			<param name="stiffness" type="float">
				<doc>Spring strength. Force proportional to the position error.</doc>
			</param>
			<param name="damping" type="float">
				<doc>Damping strength. Force propertional to the velocity error.</doc>
			</param>
		</ctor>
		<field name="stiffness" type="float">
			<doc>Spring strength. Force proportional to the position error.</doc>
		</field>
		<field name="damping" type="float">
			<doc>Damping strength. Force propertional to the velocity error.</doc>
		</field>
	</struct>
	<struct native="PARTICLE_FORCE_DESC" script="ParticleForceOptions">
		<doc>Structure used for initializing a ParticleForce object.</doc>
		<ctor>
		</ctor>
		<field name="force" type="Vector3Distribution">
			<doc>Determines the force of the particles evaluated over particle lifetime.</doc>
		</field>
		<field name="worldSpace" type="bool">
			<doc>True if the force is provided in world space, false if in local space.</doc>
		</field>
	</struct>
	<struct native="LimitCommon" script="LimitCommon">
		<doc>Contains common values used by all Joint limit types.</doc>
		<ctor>
			<param name="contactDist" type="float">
			</param>
		</ctor>
		<ctor>
			<param name="spring" type="Spring">
			</param>
			<param name="restitution" type="float">
			</param>
		</ctor>
		<field name="contactDist" type="float">
			<doc>Distance from the limit at which it becomes active. Allows the solver to activate earlier than the limit is reached to avoid breaking the limit.</doc>
		</field>
		<field name="restitution" type="float">
			<doc>Controls how do objects react when the limit is reached, values closer to zero specify non-ellastic collision, while those closer to one specify more ellastic (i.e bouncy) collision. Must be in [0, 1] range.</doc>
		</field>
		<field name="spring" type="Spring">
			<doc>Spring that controls how are the bodies pulled back towards the limit when they breach it.</doc>
		</field>
	</struct>
	<struct native="LimitLinearRange" script="LimitLinearRange">
		<doc>Represents a joint limit between two distance values. Lower value must be less than the upper value.</doc>
		<ctor>
			<doc>Constructs an empty limit.</doc>
		</ctor>
		<ctor>
			<doc>Constructs a hard limit. Once the limit is reached the movement of the attached bodies will come to a stop.</doc>
			<param name="lower" type="float">
				<doc>Lower distance of the limit. Must be less than <paramref name="upper"/>.</doc>
			</param>
			<param name="upper" type="float">
				<doc>Upper distance of the limit. Must be more than <paramref name="lower"/>.</doc>
			</param>
			<param name="contactDist" type="float">
				<doc>Distance from the limit at which it becomes active. Allows the solver to activate earlier than the limit is reached to avoid breaking the limit. Specify -1 for the default.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Constructs a soft limit. Once the limit is reached the bodies will bounce back according to the resitution parameter and will be pulled back towards the limit by the provided spring.</doc>
			<param name="lower" type="float">
				<doc>Lower distance of the limit. Must be less than <paramref name="upper"/>.</doc>
			</param>
			<param name="upper" type="float">
				<doc>Upper distance of the limit. Must be more than <paramref name="lower"/>.</doc>
			</param>
			<param name="spring" type="Spring">
				<doc>Spring that controls how are the bodies pulled back towards the limit when they breach it.</doc>
			</param>
			<param name="restitution" type="float">
				<doc>Controls how do objects react when the limit is reached, values closer to zero specify non-ellastic collision, while those closer to one specify more ellastic (i.e bouncy) collision. Must be in [0, 1] range.</doc>
			</param>
		</ctor>
		<field name="lower" type="float">
			<doc>Lower distance of the limit. Must be less than #upper.</doc>
		</field>
		<field name="upper" type="float">
			<doc>Upper distance of the limit. Must be more than #lower.</doc>
		</field>
		<field name="contactDist" type="float">
			<doc>Distance from the limit at which it becomes active. Allows the solver to activate earlier than the limit is reached to avoid breaking the limit.</doc>
		</field>
		<field name="restitution" type="float">
			<doc>Controls how do objects react when the limit is reached, values closer to zero specify non-ellastic collision, while those closer to one specify more ellastic (i.e bouncy) collision. Must be in [0, 1] range.</doc>
		</field>
		<field name="spring" type="Spring">
			<doc>Spring that controls how are the bodies pulled back towards the limit when they breach it.</doc>
		</field>
	</struct>
	<struct native="LimitLinear" script="LimitLinear">
		<doc>Represents a joint limit between zero a single distance value.</doc>
		<ctor>
			<doc>Constructs an empty limit.</doc>
		</ctor>
		<ctor>
			<doc>Constructs a hard limit. Once the limit is reached the movement of the attached bodies will come to a stop.</doc>
			<param name="extent" type="float">
				<doc>Distance at which the limit becomes active.</doc>
			</param>
			<param name="contactDist" type="float">
				<doc>Distance from the limit at which it becomes active. Allows the solver to activate earlier than the limit is reached to avoid breaking the limit. Specify -1 for the default.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Constructs a soft limit. Once the limit is reached the bodies will bounce back according to the resitution parameter and will be pulled back towards the limit by the provided spring.</doc>
			<param name="extent" type="float">
				<doc>Distance at which the limit becomes active.</doc>
			</param>
			<param name="spring" type="Spring">
				<doc>Spring that controls how are the bodies pulled back towards the limit when they breach it.</doc>
			</param>
			<param name="restitution" type="float">
				<doc>Controls how do objects react when the limit is reached, values closer to zero specify non-ellastic collision, while those closer to one specify more ellastic (i.e bouncy) collision. Must be in [0, 1] range.</doc>
			</param>
		</ctor>
		<field name="extent" type="float">
			<doc>Distance at which the limit becomes active.</doc>
		</field>
		<field name="contactDist" type="float">
			<doc>Distance from the limit at which it becomes active. Allows the solver to activate earlier than the limit is reached to avoid breaking the limit.</doc>
		</field>
		<field name="restitution" type="float">
			<doc>Controls how do objects react when the limit is reached, values closer to zero specify non-ellastic collision, while those closer to one specify more ellastic (i.e bouncy) collision. Must be in [0, 1] range.</doc>
		</field>
		<field name="spring" type="Spring">
			<doc>Spring that controls how are the bodies pulled back towards the limit when they breach it.</doc>
		</field>
	</struct>
	<struct native="LimitConeRange" script="LimitConeRange">
		<doc>Represents a joint limit that contraints movement to within an elliptical cone.</doc>
		<ctor>
			<doc>Constructs a limit with a 45 degree cone.</doc>
		</ctor>
		<ctor>
			<doc>Constructs a hard limit. Once the limit is reached the movement of the attached bodies will come to a stop.</doc>
			<param name="yLimitAngle" type="Radian">
				<doc>Y angle of the cone. Movement is constrainted between 0 and this angle on the Y axis.</doc>
			</param>
			<param name="zLimitAngle" type="Radian">
				<doc>Z angle of the cone. Movement is constrainted between 0 and this angle on the Z axis.</doc>
			</param>
			<param name="contactDist" type="float">
				<doc>Distance from the limit at which it becomes active. Allows the solver to activate earlier than the limit is reached to avoid breaking the limit. Specify -1 for the default.</doc>
			</param>
		</ctor>
		<ctor>
			<doc>Constructs a soft limit. Once the limit is reached the bodies will bounce back according to the resitution parameter and will be pulled back towards the limit by the provided spring.</doc>
			<param name="yLimitAngle" type="Radian">
				<doc>Y angle of the cone. Movement is constrainted between 0 and this angle on the Y axis.</doc>
			</param>
			<param name="zLimitAngle" type="Radian">
				<doc>Z angle of the cone. Movement is constrainted between 0 and this angle on the Z axis.</doc>
			</param>
			<param name="spring" type="Spring">
				<doc>Spring that controls how are the bodies pulled back towards the limit when they breach it.</doc>
			</param>
			<param name="restitution" type="float">
				<doc>Controls how do objects react when the limit is reached, values closer to zero specify non-ellastic collision, while those closer to one specify more ellastic (i.e bouncy) collision. Must be in [0, 1] range.</doc>
			</param>
		</ctor>
		<field name="yLimitAngle" type="Radian">
			<doc>Y angle of the cone. Movement is constrainted between 0 and this angle on the Y axis.</doc>
		</field>
		<field name="zLimitAngle" type="Radian">
			<doc>Z angle of the cone. Movement is constrainted between 0 and this angle on the Z axis.</doc>
		</field>
		<field name="contactDist" type="float">
			<doc>Distance from the limit at which it becomes active. Allows the solver to activate earlier than the limit is reached to avoid breaking the limit.</doc>
		</field>
		<field name="restitution" type="float">
			<doc>Controls how do objects react when the limit is reached, values closer to zero specify non-ellastic collision, while those closer to one specify more ellastic (i.e bouncy) collision. Must be in [0, 1] range.</doc>
		</field>
		<field name="spring" type="Spring">
			<doc>Spring that controls how are the bodies pulled back towards the limit when they breach it.</doc>
		</field>
	</struct>
	<class native="ParticleEmitterCircleShape" script="ParticleEmitterCircleShape">
		<doc>Particle emitter shape that emits particles from a circle. Using the thickness parameter you can control whether to emit only from circle edge, the entire surface or just a part of the surface. Using the arc parameter you can emit from a specific angular portion of the circle.</doc>
		<ctor>
			<doc>Creates a new particle emitter circle shape.</doc>
			<param name="desc" type="ParticleCircleShapeOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle emitter circle shape.</doc>
		</ctor>
		<property name="Options" type="ParticleCircleShapeOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the shape.</doc>
		</property>
	</class>
	<enum native="D6JointAxis" script="D6JointAxis">
		<doc>Specifies axes that the D6 joint can constrain motion on.</doc>
		<enumentry native="X" script="X">
			<doc>Movement on the X axis.</doc>
		</enumentry>
		<enumentry native="Y" script="Y">
			<doc>Movement on the Y axis.</doc>
		</enumentry>
		<enumentry native="Z" script="Z">
			<doc>Movement on the Z axis.</doc>
		</enumentry>
		<enumentry native="Twist" script="Twist">
			<doc>Rotation around the X axis.</doc>
		</enumentry>
		<enumentry native="SwingY" script="SwingY">
			<doc>Rotation around the Y axis.</doc>
		</enumentry>
		<enumentry native="SwingZ" script="SwingZ">
			<doc>Rotation around the Z axis.</doc>
		</enumentry>
		<enumentry native="Count" script="Count">
		</enumentry>
	</enum>
	<enum native="D6JointMotion" script="D6JointMotion">
		<doc>Specifies type of constraint placed on a specific axis.</doc>
		<enumentry native="Locked" script="Locked">
			<doc>Axis is immovable.</doc>
		</enumentry>
		<enumentry native="Limited" script="Limited">
			<doc>Axis will be constrained by the specified limits.</doc>
		</enumentry>
		<enumentry native="Free" script="Free">
			<doc>Axis will not be constrained.</doc>
		</enumentry>
		<enumentry native="Count" script="Count">
		</enumentry>
	</enum>
	<enum native="D6JointDriveType" script="D6JointDriveType">
		<doc>Type of drives that can be used for moving or rotating bodies attached to the joint.</doc>
		<enumentry native="X" script="X">
			<doc>Linear movement on the X axis using the linear drive model.</doc>
		</enumentry>
		<enumentry native="Y" script="Y">
			<doc>Linear movement on the Y axis using the linear drive model.</doc>
		</enumentry>
		<enumentry native="Z" script="Z">
			<doc>Linear movement on the Z axis using the linear drive model.</doc>
		</enumentry>
		<enumentry native="Swing" script="Swing">
			<doc>Rotation around the Y axis using the twist/swing angular drive model. Should not be used together with SLERP mode.</doc>
		</enumentry>
		<enumentry native="Twist" script="Twist">
			<doc>Rotation around the Z axis using the twist/swing angular drive model. Should not be used together with SLERP mode.</doc>
		</enumentry>
		<enumentry native="SLERP" script="SLERP">
			<doc>Rotation using spherical linear interpolation. Uses the SLERP angular drive mode which performs rotation by interpolating the quaternion values directly over the shortest path (applies to all three axes, which they all must be unlocked).</doc>
		</enumentry>
		<enumentry native="Count" script="Count">
			<doc>Rotation using spherical linear interpolation. Uses the SLERP angular drive mode which performs rotation by interpolating the quaternion values directly over the shortest path (applies to all three axes, which they all must be unlocked).</doc>
		</enumentry>
	</enum>
	<struct native="D6JointDrive" script="D6JointDrive">
		<doc>Specifies parameters for a drive that will attempt to move the joint bodies to the specified drive position and velocity.</doc>
		<ctor>
		</ctor>
		<field name="stiffness" type="float">
			<doc>Spring strength. Force proportional to the position error.</doc>
		</field>
		<field name="damping" type="float">
			<doc>Damping strength. Force propertional to the velocity error.</doc>
		</field>
		<field name="forceLimit" type="float">
			<doc>Maximum force the drive can apply.</doc>
		</field>
		<field name="acceleration" type="bool">
			<doc>If true the drive will generate acceleration instead of forces. Acceleration drives are easier to tune as they account for the masses of the actors to which the joint is attached.</doc>
		</field>
	</struct>
	<enum native="SphericalJointFlag" script="SphericalJointFlag">
		<doc>Flags that control options for the spherical joint</doc>
		<enumentry native="Limit" script="Limit">
			<doc>Enables the cone range limit.</doc>
		</enumentry>
	</enum>
	<class native="CJoint" script="Joint">
		<doc>Base class for all Joint types. Joints constrain how two rigidbodies move relative to one another (for example a door hinge). One of the bodies in the joint must always be movable (non-kinematic).</doc>
		<method native="getBody" script="GetBody" static="false">
			<doc>Determines a body managed by the joint. One of the bodies must be movable (non-kinematic).</doc>
			<param name="body" type="JointBody">
			</param>
			<returns type="Rigidbody">
			</returns>
		</method>
		<method native="setBody" script="SetBody" static="false">
			<doc>Determines a body managed by the joint. One of the bodies must be movable (non-kinematic).</doc>
			<param name="body" type="JointBody">
			</param>
			<param name="value" type="Rigidbody">
			</param>
		</method>
		<method native="getPosition" script="GetPosition" static="false">
			<doc>Returns the position relative to the body, at which the body is anchored to the joint.</doc>
			<param name="body" type="JointBody">
			</param>
			<returns type="Vector3">
			</returns>
		</method>
		<method native="getRotation" script="GetRotation" static="false">
			<doc>Returns the rotation relative to the body, at which the body is anchored to the joint.</doc>
			<param name="body" type="JointBody">
			</param>
			<returns type="Quaternion">
			</returns>
		</method>
		<method native="setTransform" script="SetTransform" static="false">
			<doc>Sets the position and rotation relative to the body, at which the body is anchored to the joint.</doc>
			<param name="body" type="JointBody">
			</param>
			<param name="position" type="Vector3">
			</param>
			<param name="rotation" type="Quaternion">
			</param>
		</method>
		<property name="BreakForce" type="float" getter="getBreakForce" setter="setBreakForce" static="false">
			<doc>Determines the maximum force the joint can apply before breaking. Broken joints no longer participate in physics simulation.</doc>
		</property>
		<property name="BreakTorque" type="float" getter="getBreakTorque" setter="setBreakTorque" static="false">
			<doc>Determines the maximum torque the joint can apply before breaking. Broken joints no longer participate in physics simulation.</doc>
		</property>
		<property name="EnableCollision" type="bool" getter="getEnableCollision" setter="setEnableCollision" static="false">
			<doc>Determines whether collision between the two bodies managed by the joint are enabled.</doc>
		</property>
		<event native="onJointBreak" script="OnJointBreak" static="false">
			<doc>Triggered when the joint&apos;s break force or torque is exceeded.</doc>
		</event>
	</class>
	<class native="ParticleVelocity" script="ParticleVelocity">
		<doc>Applies linear velocity to the particles.</doc>
		<ctor>
			<doc>Creates a new particle velocity evolver.</doc>
			<param name="desc" type="ParticleVelocityOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle velocity evolver.</doc>
		</ctor>
		<property name="Options" type="ParticleVelocityOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the evolver.</doc>
		</property>
	</class>
	<class native="CD6Joint" script="D6Joint">
		<doc>Represents the most customizable type of joint. This joint type can be used to create all other built-in joint types, and to design your own custom ones, but is less intuitive to use. Allows a specification of a linear constraint (for example for slider), twist constraint (rotating around X) and swing constraint (rotating around Y and Z). It also allows you to constrain limits to only specific axes or completely lock specific axes.</doc>
		<method native="getMotion" script="GetMotion" static="false">
			<doc>Returns motion constraint for the specified axis.</doc>
			<param name="axis" type="D6JointAxis">
			</param>
			<returns type="D6JointMotion">
			</returns>
		</method>
		<method native="setMotion" script="SetMotion" static="false">
			<doc>Allows you to constrain motion of the specified axis. Be aware that when setting drives for a specific axis you must also take care not to constrain its motion in a conflicting way (for example you cannot add a drive that moves the joint on X axis, and then lock the X axis).
Unlocking translations degrees of freedom allows the bodies to move along the subset of the unlocked axes. (for example unlocking just one translational axis is the equivalent of a slider joint.)
Angular degrees of freedom are partitioned as twist (around X axis) and swing (around Y and Z axes). Different effects can be achieves by unlocking their various combinations: - If a single degree of angular freedom is unlocked it should be the twist degree as it has extra options for that case (for example for a hinge joint). - If both swing degrees are unlocked but twist is locked the result is a zero-twist joint. - If one swing and one twist degree of freedom are unlocked the result is a zero-swing joint (for example an arm attached at the elbow) - If all angular degrees of freedom are unlocked the result is the same as the spherical joint.</doc>
			<param name="axis" type="D6JointAxis">
			</param>
			<param name="motion" type="D6JointMotion">
			</param>
		</method>
		<method native="getDrive" script="GetDrive" static="false">
			<doc>Determines a drive that will attempt to move the specified degree(s) of freedom to the wanted position and velocity.</doc>
			<param name="type" type="D6JointDriveType">
			</param>
			<returns type="D6JointDrive">
			</returns>
		</method>
		<method native="setDrive" script="SetDrive" static="false">
			<doc>Determines a drive that will attempt to move the specified degree(s) of freedom to the wanted position and velocity.</doc>
			<param name="type" type="D6JointDriveType">
			</param>
			<param name="drive" type="D6JointDrive">
			</param>
		</method>
		<method native="setDriveTransform" script="SetDriveTransform" static="false">
			<doc>Sets the drive&apos;s target position and rotation relative to the joint&apos;s first body.</doc>
			<param name="position" type="Vector3">
			</param>
			<param name="rotation" type="Quaternion">
			</param>
		</method>
		<method native="setDriveVelocity" script="SetDriveVelocity" static="false">
			<doc>Sets the drive&apos;s target linear and angular velocities.</doc>
			<param name="linear" type="Vector3">
			</param>
			<param name="angular" type="Vector3">
			</param>
		</method>
		<property name="Twist" type="Radian" getter="getTwist" setter="" static="false">
			<doc>Returns the current rotation of the joint around the X axis.</doc>
		</property>
		<property name="SwingY" type="Radian" getter="getSwingY" setter="" static="false">
			<doc>Returns the current rotation of the joint around the Y axis.</doc>
		</property>
		<property name="SwingZ" type="Radian" getter="getSwingZ" setter="" static="false">
			<doc>Returns the current rotation of the joint around the Z axis.</doc>
		</property>
		<property name="LimitLinear" type="LimitLinear" getter="getLimitLinear" setter="setLimitLinear" static="false">
			<doc>Determines the linear limit used for constraining translation degrees of freedom.</doc>
		</property>
		<property name="LimitTwist" type="LimitAngularRange" getter="getLimitTwist" setter="setLimitTwist" static="false">
			<doc>Determines the angular limit used for constraining the twist (rotation around X) degree of freedom.</doc>
		</property>
		<property name="LimitSwing" type="LimitConeRange" getter="getLimitSwing" setter="setLimitSwing" static="false">
			<doc>Determines the cone limit used for constraining the swing (rotation around Y and Z) degree of freedom.</doc>
		</property>
		<property name="DrivePosition" type="Vector3" getter="getDrivePosition" setter="" static="false">
			<doc>Returns the drive&apos;s target position relative to the joint&apos;s first body.</doc>
		</property>
		<property name="DriveRotation" type="Quaternion" getter="getDriveRotation" setter="" static="false">
			<doc>Returns the drive&apos;s target rotation relative to the joint&apos;s first body.</doc>
		</property>
		<property name="DriveLinearVelocity" type="Vector3" getter="getDriveLinearVelocity" setter="" static="false">
			<doc>Returns the drive&apos;s target linear velocity.</doc>
		</property>
		<property name="DriveAngularVelocity" type="Vector3" getter="getDriveAngularVelocity" setter="" static="false">
			<doc>Returns the drive&apos;s target angular velocity.</doc>
		</property>
	</class>
	<class native="CDecal" script="Decal">
		<doc>Wraps Decal as a Component.</doc>
		<property name="Material" type="RRef&lt;Material&gt;" getter="getMaterial" setter="setMaterial" static="false">
			<doc>Determines the material to use when rendering the decal.</doc>
		</property>
		<property name="Size" type="Vector2" getter="getSize" setter="setSize" static="false">
			<doc>Width and height of the decal.</doc>
		</property>
		<property name="MaxDistance" type="float" getter="getMaxDistance" setter="setMaxDistance" static="false">
			<doc>Determines the maximum distance (from its origin) at which the decal is displayed.</doc>
		</property>
		<property name="Layer" type="ulong" getter="getLayer" setter="setLayer" static="false">
			<doc>Determines the layer that controls whether a system is considered visible in a specific camera. Layer must match camera layer bitfield in order for the camera to render the decal.</doc>
		</property>
		<property name="LayerMask" type="int" getter="getLayerMask" setter="setLayerMask" static="false">
			<doc>Bitfield that allows you to mask on which objects will the decal be projected onto. Only objects with the matching layers will be projected onto. Note that decal layer mask only supports 32-bits and objects with layers in bits &gt;= 32 will always be projected onto.</doc>
		</property>
	</class>
	<enum native="DistanceJointFlag" script="DistanceJointFlag">
		<doc>Controls distance joint options.</doc>
		<enumentry native="MinDistance" script="MinDistance">
			<doc>Enables minimum distance limit.</doc>
		</enumentry>
		<enumentry native="MaxDistance" script="MaxDistance">
			<doc>Enables maximum distance limit.</doc>
		</enumentry>
		<enumentry native="Spring" script="Spring">
			<doc>Enables spring when maintaining limits.</doc>
		</enumentry>
	</enum>
	<class native="CDistanceJoint" script="DistanceJoint">
		<doc>A joint that maintains an upper or lower (or both) bound on the distance between two bodies.</doc>
		<method native="setFlag" script="SetFlag" static="false">
			<doc>Enables or disables a flag that controls joint behaviour.</doc>
			<param name="flag" type="DistanceJointFlag">
			</param>
			<param name="enabled" type="bool">
			</param>
		</method>
		<method native="hasFlag" script="HasFlag" static="false">
			<doc>Checks whether a certain joint flag is enabled.</doc>
			<param name="flag" type="DistanceJointFlag">
			</param>
			<returns type="bool">
			</returns>
		</method>
		<property name="Distance" type="float" getter="getDistance" setter="" static="false">
			<doc>Returns the current distance between the two joint bodies.</doc>
		</property>
		<property name="MinDistance" type="float" getter="getMinDistance" setter="setMinDistance" static="false">
			<doc>Determines the minimum distance the bodies are allowed to be at, they will get no closer. You must enable min distance flag in order for this limit to be applied.</doc>
		</property>
		<property name="MaxDistance" type="float" getter="getMaxDistance" setter="setMaxDistance" static="false">
			<doc>Determines the maximum distance the bodies are allowed to be at, they will get no further. You must enable max distance flag in order for this limit to be applied.</doc>
		</property>
		<property name="Tolerance" type="float" getter="getTolerance" setter="setTolerance" static="false">
			<doc>Determines the error tolerance of the joint at which the joint becomes active. This value slightly extends the lower and upper limit.</doc>
		</property>
		<property name="Spring" type="Spring" getter="getSpring" setter="setSpring" static="false">
			<doc>Determines a spring that controls how the joint responds when a limit is reached. You must enable the spring flag on the joint in order for this to be recognized.</doc>
		</property>
	</class>
	<class native="CFixedJoint" script="FixedJoint">
		<doc>Physics joint that will maintain a fixed distance and orientation between its two attached bodies.</doc>
	</class>
	<enum native="RigidbodyFlag" script="RigidbodyFlag">
		<doc>Flags that control options of a Rigidbody object.</doc>
		<enumentry native="None" script="None">
			<doc>No options.</doc>
		</enumentry>
		<enumentry native="AutoTensors" script="AutoTensors">
			<doc>Automatically calculate center of mass transform and inertia tensors from child shapes (colliders).</doc>
		</enumentry>
		<enumentry native="AutoMass" script="AutoMass">
			<doc>Calculate mass distribution from child shapes (colliders). Only relevant when auto-tensors is on.</doc>
		</enumentry>
		<enumentry native="CCD" script="CCD">
			<doc>Enables continous collision detection. This can prevent fast moving bodies from tunneling through each other. This must also be enabled globally in Physics otherwise the flag will be ignored.</doc>
		</enumentry>
	</enum>
	<enum native="HingeJointFlag" script="HingeJointFlag">
		<doc>Flags that control hinge joint options.</doc>
		<enumentry native="Limit" script="Limit">
			<doc>Joint limit is enabled.</doc>
		</enumentry>
		<enumentry native="Drive" script="Drive">
			<doc>Joint drive is enabled.</doc>
		</enumentry>
	</enum>
	<struct native="HingeJointDrive" script="HingeJointDrive">
		<doc>Properties of a drive that drives the joint&apos;s angular velocity towards a paricular value.</doc>
		<ctor>
		</ctor>
		<field name="speed" type="float">
			<doc>Target speed of the joint.</doc>
		</field>
		<field name="forceLimit" type="float">
			<doc>Maximum torque the drive is allowed to apply .</doc>
		</field>
		<field name="gearRatio" type="float">
			<doc>Scales the velocity of the first body, and its response to drive torque is scaled down.</doc>
		</field>
		<field name="freeSpin" type="bool">
			<doc>If the joint is moving faster than the drive&apos;s target speed, the drive will try to break. If you don&apos;t want the breaking to happen set this to true.</doc>
		</field>
	</struct>
	<class native="CLight" script="Light">
		<doc>Illuminates a portion of the scene covered by the light.</doc>
		<property name="Type" type="LightType" getter="getType" setter="setType" static="false">
			<doc>Determines the type of the light.</doc>
		</property>
		<property name="Color" type="Color" getter="getColor" setter="setColor" static="false">
			<doc>Determines the color emitted by the light.</doc>
		</property>
		<property name="Intensity" type="float" getter="getIntensity" setter="setIntensity" static="false">
			<doc>Determines the power of the light source. This will be luminous flux for radial &amp; spot lights, luminance for directional lights with no area, and illuminance for directional lights with area (non-zero source radius).</doc>
		</property>
		<property name="UseAutoAttenuation" type="bool" getter="getUseAutoAttenuation" setter="setUseAutoAttenuation" static="false">
			<doc>If enabled the attenuation radius will automatically be controlled in order to provide reasonable light radius, depending on its intensity.</doc>
		</property>
		<property name="AttenuationRadius" type="float" getter="getAttenuationRadius" setter="setAttenuationRadius" static="false">
			<doc>Range at which the light contribution fades out to zero. Use setUseAutoAttenuation to provide a radius automatically dependant on light intensity. The radius will cut-off light contribution and therefore manually set very small radius can end up being very physically incorrect.</doc>
		</property>
		<property name="SourceRadius" type="float" getter="getSourceRadius" setter="setSourceRadius" static="false">
			<doc>Radius of the light source. If non-zero then this light represents an area light, otherwise it is a punctual light. Area lights have different attenuation then punctual lights, and their appearance in specular reflections is realistic. Shape of the area light depends on light type: - For directional light the shape is a disc projected on the hemisphere on the sky. This parameter represents angular radius (in degrees) of the disk and should be very small (think of how much space the Sun takes on the sky - roughly 0.25 degree radius). - For radial light the shape is a sphere and the source radius is the radius of the sphere. - For spot lights the shape is a disc oriented in the direction of the spot light and the source radius is the radius of the disc.</doc>
		</property>
		<property name="SpotAngle" type="Degree" getter="getSpotAngle" setter="setSpotAngle" static="false">
			<doc>Determines the total angle covered by a spot light.</doc>
		</property>
		<property name="SpotAngleFalloff" type="Degree" getter="getSpotFalloffAngle" setter="setSpotFalloffAngle" static="false">
			<doc>Determines the falloff angle covered by a spot light. Falloff angle determines at what point does light intensity starts quadratically falling off as the angle approaches the total spot angle.</doc>
		</property>
		<property name="CastsShadow" type="bool" getter="getCastsShadow" setter="setCastsShadow" static="false">
			<doc>Determines does this light cast shadows when rendered.</doc>
		</property>
		<property name="ShadowBias" type="float" getter="getShadowBias" setter="setShadowBias" static="false">
			<doc>Shadow bias determines offset at which the shadows are rendered from the shadow caster. Bias value of 0 means the shadow will be renderered exactly at the casters position. If your geometry has thin areas this will produce an artifact called shadow acne, in which case you can increase the shadow bias value to eliminate it. Note that increasing the shadow bias will on the other hand make the shadow be offset from the caster and may make the caster appear as if floating (Peter Panning artifact). Neither is perfect, so it is preferable to ensure all your geometry has thickness and keep the bias at zero, or even at negative values.
Default value is 0.5. Should be in rough range [-1, 1].</doc>
		</property>
		<property name="Bounds" type="Sphere" getter="getBounds" setter="" static="false">
			<doc>Returns world space bounds that completely encompass the light&apos;s area of influence.</doc>
		</property>
	</class>
	<class native="CLightProbeVolume" script="LightProbeVolume">
		<doc>Allows you to define a volume of light probes that will be used for indirect lighting. Lighting information in the scene will be interpolated from nearby probes to calculate the amount of indirect lighting at that position. It is up to the caller to place the light probes in areas where the lighting changes in order to yield the best results.
The volume can never have less than 4 probes.</doc>
		<method native="addProbe" script="AddProbe" static="false">
			<doc>Adds a new probe at the specified position and returns a handle to the probe. The position is relative to the volume origin.</doc>
			<param name="position" type="Vector3">
			</param>
			<returns type="int">
			</returns>
		</method>
		<method native="setProbePosition" script="SetProbePosition" static="false">
			<doc>Updates the position of the probe with the specified handle.</doc>
			<param name="handle" type="int">
			</param>
			<param name="position" type="Vector3">
			</param>
		</method>
		<method native="getProbePosition" script="GetProbePosition" static="false">
			<doc>Retrieves the position of the probe with the specified handle.</doc>
			<param name="handle" type="int">
			</param>
			<returns type="Vector3">
			</returns>
		</method>
		<method native="removeProbe" script="RemoveProbe" static="false">
			<doc>Removes the probe with the specified handle. Note that if this is one of the last four remaining probes in the volume it cannot be removed.</doc>
			<param name="handle" type="int">
			</param>
		</method>
		<method native="getProbes" script="GetProbes" static="false">
			<doc>Returns a list of positions of all light probes in the volume.</doc>
			<returns type="LightProbeInfo">
			</returns>
		</method>
		<method native="renderProbe" script="RenderProbe" static="false">
			<doc>Causes the information for this specific light probe to be updated. You generally want to call this when the probe is moved or the scene around the probe changes.</doc>
			<param name="handle" type="int">
			</param>
		</method>
		<method native="renderProbes" script="RenderProbes" static="false">
			<doc>Causes the information for all lights probes to be updated. You generally want to call this if you move the entire light volume or the scene around the volume changes.</doc>
		</method>
		<method native="resize" script="Resize" static="false">
			<doc>Resizes the light probe grid and inserts new light probes, if the new size is larger than previous size. New probes are inserted in a grid pattern matching the new size and density parameters.
Note that shrinking the volume will not remove light probes. In order to remove probes outside of the new volume call clip().
Resize will not change the positions of current light probes. If you wish to reset all probes to the currently set grid position, call reset().</doc>
			<param name="volume" type="AABox">
				<doc>Axis aligned volume to be covered by the light probes.</doc>
			</param>
			<param name="cellCount" type="Vector3I">
				<doc>Number of grid cells to split the volume into. Minimum number of 1, in which case each corner of the volume is represented by a single probe. Higher values subdivide the volume in an uniform way.</doc>
			</param>
		</method>
		<method native="clip" script="Clip" static="false">
			<doc>Removes any probes outside of the current grid volume.</doc>
		</method>
		<method native="reset" script="Reset" static="false">
			<doc>Resets all probes to match the original grid pattern. This will reset probe positions, as well as add/remove probes as necessary, essentially losing any custom changes to the probes.</doc>
		</method>
		<method native="resize" script="Resize" static="false">
			<doc>Resizes the light probe grid and inserts new light probes, if the new size is larger than previous size. New probes are inserted in a grid pattern matching the new size and density parameters.
Note that shrinking the volume will not remove light probes. In order to remove probes outside of the new volume call clip().
Resize will not change the positions of current light probes. If you wish to reset all probes to the currently set grid position, call reset().</doc>
			<param name="volume" type="AABox">
				<doc>Axis aligned volume to be covered by the light probes.</doc>
			</param>
			<param name="cellCount" type="Vector3I">
			</param>
		</method>
		<property name="GridVolume" type="AABox" getter="getGridVolume" setter="" static="false">
			<doc>Returns the volume that&apos;s used for adding probes in a uniform grid pattern.</doc>
		</property>
		<property name="CellCount" type="Vector3I" getter="getCellCount" setter="" static="false">
			<doc>Returns the cell count that&apos;s used for determining the density of probes within a grid volume.</doc>
		</property>
	</class>
	<class native="CMeshCollider" script="MeshCollider">
		<doc>A collider represented by an arbitrary mesh.</doc>
		<property name="Mesh" type="RRef&lt;PhysicsMesh&gt;" getter="getMesh" setter="setMesh" static="false">
			<doc>Sets a mesh that represents the collider geometry. This can be a generic triangle mesh, or and convex mesh. Triangle meshes are not supported as triggers, nor are they supported for colliders that are parts of a non-kinematic rigidbody.</doc>
		</property>
	</class>
	<class native="TColorDistribution&lt;ColorGradient&gt;" script="ColorDistribution">
		<doc>Specifies a color as a distribution, which can include a constant color, random color range or a color gradient.</doc>
		<ctor>
			<doc>Creates a new empty distribution.</doc>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that returns a constant color.</doc>
			<param name="color" type="Color">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that returns a random color in the specified range.</doc>
			<param name="minColor" type="Color">
			</param>
			<param name="maxColor" type="Color">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that evaluates a color gradient.</doc>
			<param name="gradient" type="ColorGradient">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that returns a random color in a range determined by two gradients.</doc>
			<param name="minGradient" type="ColorGradient">
			</param>
			<param name="maxGradient" type="ColorGradient">
			</param>
		</ctor>
		<method native="getMinConstant" script="GetMinConstant" static="false">
			<doc>Returns the constant value of the distribution, or the minimal value of a constant range. Undefined if the distribution is represented by a gradient.</doc>
			<returns type="Color">
			</returns>
		</method>
		<method native="getMaxConstant" script="GetMaxConstant" static="false">
			<doc>Returns the maximum value of a constant range. Only defined if the distribution represents a non-gradient range.</doc>
			<returns type="Color">
			</returns>
		</method>
		<method native="getMinGradient" script="GetMinGradient" static="false">
			<doc>Returns the gradient representing the distribution, or the first gradient representing a gradient range. Undefined if the distribution is represented by a constant or a non-gradient range.</doc>
			<returns type="ColorGradient">
			</returns>
		</method>
		<method native="getMaxGradient" script="GetMaxGradient" static="false">
			<doc>Returns the curve representing the second gradient of a gradient range. Only defined if the distribution represents a gradient range.</doc>
			<returns type="ColorGradient">
			</returns>
		</method>
		<property name="DistributionType" type="PropertyDistributionType" getter="getType" setter="" static="false">
			<doc>Returns the type of the represented distribution.</doc>
		</property>
	</class>
	<class native="TColorDistribution&lt;ColorGradientHDR&gt;" script="ColorHDRDistribution">
		<doc>Specifies a color as a distribution, which can include a constant color, random color range or a color gradient.</doc>
		<ctor>
			<doc>Creates a new empty distribution.</doc>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that returns a constant color.</doc>
			<param name="color" type="Color">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that returns a random color in the specified range.</doc>
			<param name="minColor" type="Color">
			</param>
			<param name="maxColor" type="Color">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that evaluates a color gradient.</doc>
			<param name="gradient" type="ColorGradientHDR">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that returns a random color in a range determined by two gradients.</doc>
			<param name="minGradient" type="ColorGradientHDR">
			</param>
			<param name="maxGradient" type="ColorGradientHDR">
			</param>
		</ctor>
		<method native="getMinConstant" script="GetMinConstant" static="false">
			<doc>Returns the constant value of the distribution, or the minimal value of a constant range. Undefined if the distribution is represented by a gradient.</doc>
			<returns type="Color">
			</returns>
		</method>
		<method native="getMaxConstant" script="GetMaxConstant" static="false">
			<doc>Returns the maximum value of a constant range. Only defined if the distribution represents a non-gradient range.</doc>
			<returns type="Color">
			</returns>
		</method>
		<method native="getMinGradient" script="GetMinGradient" static="false">
			<doc>Returns the gradient representing the distribution, or the first gradient representing a gradient range. Undefined if the distribution is represented by a constant or a non-gradient range.</doc>
			<returns type="ColorGradientHDR">
			</returns>
		</method>
		<method native="getMaxGradient" script="GetMaxGradient" static="false">
			<doc>Returns the curve representing the second gradient of a gradient range. Only defined if the distribution represents a gradient range.</doc>
			<returns type="ColorGradientHDR">
			</returns>
		</method>
		<property name="DistributionType" type="PropertyDistributionType" getter="getType" setter="" static="false">
			<doc>Returns the type of the represented distribution.</doc>
		</property>
	</class>
	<class native="TDistribution&lt;float&gt;" script="FloatDistribution">
		<doc>Specifies a value as a distribution, which can include a constant value, random range or a curve.</doc>
		<ctor>
			<doc>Creates a new empty distribution.</doc>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that returns a constant value.</doc>
			<param name="value" type="float">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that returns a random value in the specified range.</doc>
			<param name="minValue" type="float">
			</param>
			<param name="maxValue" type="float">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that evaluates a curve.</doc>
			<param name="curve" type="AnimationCurve">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that returns a random value in a range determined by two curves.</doc>
			<param name="minCurve" type="AnimationCurve">
			</param>
			<param name="maxCurve" type="AnimationCurve">
			</param>
		</ctor>
		<method native="getMinConstant" script="GetMinConstant" static="false">
			<doc>Returns the constant value of the distribution, or the minimal value of a constant range. Undefined if the distribution is represented by a curve.</doc>
			<returns type="float">
			</returns>
		</method>
		<method native="getMaxConstant" script="GetMaxConstant" static="false">
			<doc>Returns the maximum value of a constant range. Only defined if the distribution represents a non-curve range.</doc>
			<returns type="float">
			</returns>
		</method>
		<method native="getMinCurve" script="GetMinCurve" static="false">
			<doc>Returns the curve representing the distribution, or the first curve representing a curve range. Undefined if the distribution is represented by a constant or a non-curve range.</doc>
			<returns type="AnimationCurve">
			</returns>
		</method>
		<method native="getMaxCurve" script="GetMaxCurve" static="false">
			<doc>Returns the curve representing the second curve of a curve range. Only defined if the distribution represents a curve range.</doc>
			<returns type="AnimationCurve">
			</returns>
		</method>
		<method native="evaluate" script="Evaluate" static="false">
			<doc>Evaluates the value of the distribution.</doc>
			<param name="t" type="float">
				<doc>Time at which to evaluate the distribution. This is only relevant if the distribution contains curves.</doc>
			</param>
			<param name="factor" type="float">
				<doc>Value in range [0, 1] that determines how to interpolate between min/max value, if the distribution represents a range. Value of 0 will return the minimum value, while value of 1 will return the maximum value, and interpolate the values in-between.</doc>
			</param>
			<returns type="float">
				<doc>Evaluated value.</doc>
			</returns>
		</method>
		<method native="evaluate" script="Evaluate" static="false">
			<doc>Evaluates the value of the distribution.</doc>
			<param name="t" type="float">
				<doc>Time at which to evaluate the distribution. This is only relevant if the distribution contains curves.</doc>
			</param>
			<param name="factor" type="Random">
				<doc>Random number generator that determines the factor. Factor determines how to interpolate between min/max value, if the distribution represents a range.</doc>
			</param>
			<returns type="float">
				<doc>Evaluated value.</doc>
			</returns>
		</method>
		<property name="DistributionType" type="PropertyDistributionType" getter="getType" setter="" static="false">
			<doc>Returns the type of the represented distribution.</doc>
		</property>
	</class>
	<class native="TDistribution&lt;Vector3&gt;" script="Vector3Distribution">
		<doc>Specifies a value as a distribution, which can include a constant value, random range or a curve.</doc>
		<ctor>
			<doc>Creates a new empty distribution.</doc>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that returns a constant value.</doc>
			<param name="value" type="Vector3">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that returns a random value in the specified range.</doc>
			<param name="minValue" type="Vector3">
			</param>
			<param name="maxValue" type="Vector3">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that evaluates a curve.</doc>
			<param name="curve" type="Vector3Curve">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that returns a random value in a range determined by two curves.</doc>
			<param name="minCurve" type="Vector3Curve">
			</param>
			<param name="maxCurve" type="Vector3Curve">
			</param>
		</ctor>
		<method native="getMinConstant" script="GetMinConstant" static="false">
			<doc>Returns the constant value of the distribution, or the minimal value of a constant range. Undefined if the distribution is represented by a curve.</doc>
			<returns type="Vector3">
			</returns>
		</method>
		<method native="getMaxConstant" script="GetMaxConstant" static="false">
			<doc>Returns the maximum value of a constant range. Only defined if the distribution represents a non-curve range.</doc>
			<returns type="Vector3">
			</returns>
		</method>
		<method native="getMinCurve" script="GetMinCurve" static="false">
			<doc>Returns the curve representing the distribution, or the first curve representing a curve range. Undefined if the distribution is represented by a constant or a non-curve range.</doc>
			<returns type="Vector3Curve">
			</returns>
		</method>
		<method native="getMaxCurve" script="GetMaxCurve" static="false">
			<doc>Returns the curve representing the second curve of a curve range. Only defined if the distribution represents a curve range.</doc>
			<returns type="Vector3Curve">
			</returns>
		</method>
		<method native="evaluate" script="Evaluate" static="false">
			<doc>Evaluates the value of the distribution.</doc>
			<param name="t" type="float">
				<doc>Time at which to evaluate the distribution. This is only relevant if the distribution contains curves.</doc>
			</param>
			<param name="factor" type="float">
				<doc>Value in range [0, 1] that determines how to interpolate between min/max value, if the distribution represents a range. Value of 0 will return the minimum value, while value of 1 will return the maximum value, and interpolate the values in-between.</doc>
			</param>
			<returns type="Vector3">
				<doc>Evaluated value.</doc>
			</returns>
		</method>
		<method native="evaluate" script="Evaluate" static="false">
			<doc>Evaluates the value of the distribution.</doc>
			<param name="t" type="float">
				<doc>Time at which to evaluate the distribution. This is only relevant if the distribution contains curves.</doc>
			</param>
			<param name="factor" type="Random">
				<doc>Random number generator that determines the factor. Factor determines how to interpolate between min/max value, if the distribution represents a range.</doc>
			</param>
			<returns type="Vector3">
				<doc>Evaluated value.</doc>
			</returns>
		</method>
		<property name="DistributionType" type="PropertyDistributionType" getter="getType" setter="" static="false">
			<doc>Returns the type of the represented distribution.</doc>
		</property>
	</class>
	<class native="TDistribution&lt;Vector2&gt;" script="Vector2Distribution">
		<doc>Specifies a value as a distribution, which can include a constant value, random range or a curve.</doc>
		<ctor>
			<doc>Creates a new empty distribution.</doc>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that returns a constant value.</doc>
			<param name="value" type="Vector2">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that returns a random value in the specified range.</doc>
			<param name="minValue" type="Vector2">
			</param>
			<param name="maxValue" type="Vector2">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that evaluates a curve.</doc>
			<param name="curve" type="Vector2Curve">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new distribution that returns a random value in a range determined by two curves.</doc>
			<param name="minCurve" type="Vector2Curve">
			</param>
			<param name="maxCurve" type="Vector2Curve">
			</param>
		</ctor>
		<method native="getMinConstant" script="GetMinConstant" static="false">
			<doc>Returns the constant value of the distribution, or the minimal value of a constant range. Undefined if the distribution is represented by a curve.</doc>
			<returns type="Vector2">
			</returns>
		</method>
		<method native="getMaxConstant" script="GetMaxConstant" static="false">
			<doc>Returns the maximum value of a constant range. Only defined if the distribution represents a non-curve range.</doc>
			<returns type="Vector2">
			</returns>
		</method>
		<method native="getMinCurve" script="GetMinCurve" static="false">
			<doc>Returns the curve representing the distribution, or the first curve representing a curve range. Undefined if the distribution is represented by a constant or a non-curve range.</doc>
			<returns type="Vector2Curve">
			</returns>
		</method>
		<method native="getMaxCurve" script="GetMaxCurve" static="false">
			<doc>Returns the curve representing the second curve of a curve range. Only defined if the distribution represents a curve range.</doc>
			<returns type="Vector2Curve">
			</returns>
		</method>
		<method native="evaluate" script="Evaluate" static="false">
			<doc>Evaluates the value of the distribution.</doc>
			<param name="t" type="float">
				<doc>Time at which to evaluate the distribution. This is only relevant if the distribution contains curves.</doc>
			</param>
			<param name="factor" type="float">
				<doc>Value in range [0, 1] that determines how to interpolate between min/max value, if the distribution represents a range. Value of 0 will return the minimum value, while value of 1 will return the maximum value, and interpolate the values in-between.</doc>
			</param>
			<returns type="Vector2">
				<doc>Evaluated value.</doc>
			</returns>
		</method>
		<method native="evaluate" script="Evaluate" static="false">
			<doc>Evaluates the value of the distribution.</doc>
			<param name="t" type="float">
				<doc>Time at which to evaluate the distribution. This is only relevant if the distribution contains curves.</doc>
			</param>
			<param name="factor" type="Random">
				<doc>Random number generator that determines the factor. Factor determines how to interpolate between min/max value, if the distribution represents a range.</doc>
			</param>
			<returns type="Vector2">
				<doc>Evaluated value.</doc>
			</returns>
		</method>
		<property name="DistributionType" type="PropertyDistributionType" getter="getType" setter="" static="false">
			<doc>Returns the type of the represented distribution.</doc>
		</property>
	</class>
	<struct native="PARTICLE_TEXTURE_ANIMATION_DESC" script="ParticleTextureAnimationOptions">
		<doc>Structure used for initializing a ParticleTextureAnimation object.</doc>
		<ctor>
		</ctor>
		<field name="randomizeRow" type="bool">
			<doc>Randomly pick a row to use for animation when the particle is first spawned. This implies that only a single row of the grid will be used for individual particle&apos;s animation.</doc>
		</field>
		<field name="numCycles" type="int">
			<doc>Number of cycles to loop the animation during particle&apos;s lifetime.</doc>
		</field>
	</struct>
	<class native="ParticleTextureAnimation" script="ParticleTextureAnimation">
		<doc>Provides functionality for particle texture animation. Uses the sprite texture assigned to the particle&apos;s material to determine animation properties.</doc>
		<ctor>
			<doc>Creates a new particle texture animation evolver.</doc>
			<param name="desc" type="ParticleTextureAnimationOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle texture animation evolver.</doc>
		</ctor>
		<property name="Options" type="ParticleTextureAnimationOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the evolver.</doc>
		</property>
	</class>
	<class native="SceneInstance" script="SceneInstance">
		<doc>Contains information about an instantiated scene.</doc>
		<property name="Name" type="string" getter="getName" setter="" static="false">
			<doc>Name of the scene.</doc>
		</property>
		<property name="Root" type="SceneObject" getter="getRoot" setter="" static="false">
			<doc>Root object of the scene.</doc>
		</property>
		<property name="IsActive" type="bool" getter="isActive" setter="" static="false">
			<doc>Checks is the scene currently active. IF inactive the scene properties aside from the name are undefined.</doc>
		</property>
		<property name="Physics" type="PhysicsScene" getter="getPhysicsScene" setter="" static="false">
			<doc>Physical representation of the scene, as assigned by the physics sub-system. Exact implementation depends on the physics plugin used.</doc>
		</property>
	</class>
	<struct native="PARTICLE_ORBIT_DESC" script="ParticleOrbitOptions">
		<doc>Structure used for initializing a ParticleOrbit object.</doc>
		<ctor>
		</ctor>
		<field name="center" type="Vector3Distribution">
			<doc>Position of the center around which to orbit. Evaluated over particle system lifetime.</doc>
		</field>
		<field name="velocity" type="Vector3Distribution">
			<doc>Determines the speed of rotation around each axis. The speed is specified in &quot;turns&quot; where 0 = no rotation, 0.5 = 180 degree rotation and 1 = 360 degree rotation. Evaluated over particle lifetime.</doc>
		</field>
		<field name="radial" type="FloatDistribution">
			<doc>Speed at which to push or pull the particles towards/away from the center. Evaluated over particle lifetime.</doc>
		</field>
		<field name="worldSpace" type="bool">
			<doc>True if the properties provided are in world space, false if in local space.</doc>
		</field>
	</struct>
	<class native="ParticleOrbit" script="ParticleOrbit">
		<doc>Moves particles so that their sprites orbit their center according to the provided offset and rotation values.</doc>
		<ctor>
			<doc>Creates a new particle orbit evolver.</doc>
			<param name="desc" type="ParticleOrbitOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle orbit evolver.</doc>
		</ctor>
		<property name="Options" type="ParticleOrbitOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the evolver.</doc>
		</property>
	</class>
	<struct native="PARTICLE_VELOCITY_DESC" script="ParticleVelocityOptions">
		<doc>Structure used for initializing a ParticleVelocity object.</doc>
		<ctor>
		</ctor>
		<field name="velocity" type="Vector3Distribution">
			<doc>Determines the velocity of the particles evaluated over particle lifetime.</doc>
		</field>
		<field name="worldSpace" type="bool">
			<doc>True if the velocity is provided in world space, false if in local space.</doc>
		</field>
	</struct>
	<enum native="ParticleCollisionMode" script="ParticleCollisionMode">
		<doc>Types of collision modes that ParticleCollisions evolver can operate in.</doc>
		<enumentry native="Plane" script="Plane">
			<doc>Particles will collide with a user-provided set of planes.</doc>
		</enumentry>
		<enumentry native="World" script="World">
			<doc>Particles will collide with physics colliders in the scene.</doc>
		</enumentry>
	</enum>
	<struct native="PARTICLE_GRAVITY_DESC" script="ParticleGravityOptions">
		<doc>Structure used for initializing a ParticleGravity object.</doc>
		<ctor>
		</ctor>
		<field name="scale" type="float">
			<doc>Scale which to apply to the gravity value retrieved from the physics sub-system.</doc>
		</field>
	</struct>
	<enum native="ShaderParameterFlag" script="ShaderParameterFlag">
		<doc>Flags used to further describe a shader parameter.</doc>
		<enumentry native="None" script="None">
		</enumentry>
		<enumentry native="Internal" script="Internal">
			<doc>Parameter is for internal use by the renderer and isn&apos;t expected to be set by the user.</doc>
		</enumentry>
		<enumentry native="HideInInspector" script="HideInInspector">
			<doc>Parameter should not be displayed in the editor inspector.</doc>
		</enumentry>
		<enumentry native="HDR" script="HDR">
			<doc>Allows the color parameter to be edited using the HDR color picker.</doc>
		</enumentry>
	</enum>
	<struct native="PARTICLE_COLOR_DESC" script="ParticleColorOptions">
		<doc>Structure used for initializing a ParticleColor object.</doc>
		<field name="color" type="ColorDistribution">
			<doc>Determines the color of the particles evaluated over particle lifetime.</doc>
		</field>
	</struct>
	<class native="ParticleColor" script="ParticleColor">
		<doc>Changes the color of the particles over the particle lifetime.</doc>
		<ctor>
			<doc>Creates a new particle color evolver.</doc>
			<param name="desc" type="ParticleColorOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle color evolver.</doc>
		</ctor>
		<property name="Options" type="ParticleColorOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the evolver.</doc>
		</property>
	</class>
	<class native="ParticleSize" script="ParticleSize">
		<doc>Changes the size of the particles over the particle lifetime.</doc>
		<ctor>
			<doc>Creates a new particle size evolver.</doc>
			<param name="desc" type="ParticleSizeOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle size evolver.</doc>
		</ctor>
		<property name="Options" type="ParticleSizeOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the evolver.</doc>
		</property>
	</class>
	<struct native="PARTICLE_ROTATION_DESC" script="ParticleRotationOptions">
		<doc>Structure used for initializing a ParticleRotation object.</doc>
		<ctor>
		</ctor>
		<field name="rotation" type="FloatDistribution">
			<doc>Determines the rotation of the particles in degrees, applied around the particle&apos;s local Z axis. Only used if 3D rotation is disabled.</doc>
		</field>
		<field name="rotation3D" type="Vector3Distribution">
			<doc>Determines the rotation of the particles in degrees as Euler angles. Only used if 3D rotation is enabled.</doc>
		</field>
		<field name="use3DRotation" type="bool">
			<doc>Determines should the particle rotation be a single angle applied around a Z axis (if disabled), or a set of Euler angles that allow you to rotate around every axis (if enabled).</doc>
		</field>
	</struct>
	<class native="ParticleRotation" script="ParticleRotation">
		<doc>Rotates the particles over the particle lifetime.</doc>
		<ctor>
			<doc>Creates a new particle rotation evolver.</doc>
			<param name="desc" type="ParticleRotationOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle rotation evolver.</doc>
		</ctor>
		<property name="Options" type="ParticleRotationOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the evolver.</doc>
		</property>
	</class>
	<struct native="PARTICLE_COLLISIONS_DESC" script="ParticleCollisionsOptions">
		<doc>Structure used for initializing a ParticleCollisions object.</doc>
		<ctor>
		</ctor>
		<field name="mode" type="ParticleCollisionMode">
			<doc>Collision mode determining with which geometry the particles will interact with.</doc>
		</field>
		<field name="restitution" type="float">
			<doc>Determines the elasticity (bounciness) of the particle collision. Lower values make the collision less bouncy and higher values more.</doc>
		</field>
		<field name="dampening" type="float">
			<doc>Determines how much velocity should a particle lose after a collision, in percent of its current velocity. In range [0, 1].</doc>
		</field>
		<field name="lifetimeLoss" type="float">
			<doc>Determines how much should the particle lifetime be reduced after a collision, in percent of its original lifetime. In range [0, 1].</doc>
		</field>
		<field name="radius" type="float">
			<doc>Radius of every individual particle used for collisions, in meters.</doc>
		</field>
		<field name="layer" type="ulong">
			<doc>Physics layers that determine which objects will particle collide with. Only relevant when using the World collision mode.</doc>
		</field>
	</struct>
	<class native="ParticleCollisions" script="ParticleCollisions">
		<doc>Particle evolver that allows particles to collide with the world.</doc>
		<ctor>
			<doc>Creates a new particle collision evolver.</doc>
			<param name="desc" type="ParticleCollisionsOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle collision evolver.</doc>
		</ctor>
		<property name="Planes" type="Plane" getter="getPlanes" setter="setPlanes" static="false">
			<doc>Determines a set of planes to use when using the Plane collision mode. Planes are expected to be in world space.</doc>
		</property>
		<property name="PlaneObjects" type="SceneObject" getter="getPlaneObjects" setter="setPlaneObjects" static="false">
			<doc>Determines a set of objects whose transforms to derive the collision planes from. Objects can move in the world and collision planes will be updated automatically. Object&apos;s negative Z axis is considered to be plane normal.</doc>
		</property>
		<property name="Options" type="ParticleCollisionsOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the evolver.</doc>
		</property>
	</class>
	<class native="PhysicsMesh" script="PhysicsMesh">
		<doc>Represents a physics mesh that can be used with a MeshCollider. Physics mesh can be a generic triangle mesh or a convex mesh. Convex meshes are limited to 255 faces.</doc>
		<ctor>
			<doc>Creates a new physics mesh.</doc>
			<param name="meshData" type="MeshData">
				<doc>Index and vertices of the mesh data.</doc>
			</param>
			<param name="type" type="PhysicsMeshType">
				<doc>Type of the mesh. If convex the provided mesh geometry will be converted into a convex mesh (that might not be the same as the provided mesh data).</doc>
			</param>
		</ctor>
		<property name="Type" type="PhysicsMeshType" getter="getType" setter="" static="false">
			<doc>Returns the type of the physics mesh.</doc>
		</property>
		<property name="MeshData" type="MeshData" getter="getMeshData" setter="" static="false">
			<doc>Returns the mesh&apos;s indices and vertices.</doc>
		</property>
	</class>
	<enum native="ParticleEmissionModeType" script="ParticleEmissionModeType">
		<doc>Types of emission modes.</doc>
		<enumentry native="Random" script="Random">
			<doc>Position will be picked randomly on a shape.</doc>
		</enumentry>
		<enumentry native="Loop" script="Loop">
			<doc>Positions will loop around the shape in a predictable fashion.</doc>
		</enumentry>
		<enumentry native="PingPong" script="PingPong">
			<doc>Similar to Loop, except the order will be reversed when one loop iteration finishes.</doc>
		</enumentry>
		<enumentry native="Spread" script="Spread">
			<doc>All particles spawned on the shape at some instant (usually a frame) will be spread around the shape equally.</doc>
		</enumentry>
	</enum>
	<struct native="ParticleEmissionMode" script="ParticleEmissionMode">
		<doc>Controls how are particle positions on a shape chosen.</doc>
		<ctor>
		</ctor>
		<field name="type" type="ParticleEmissionModeType">
			<doc>Type that determines general behaviour.</doc>
		</field>
		<field name="speed" type="float">
			<doc>Speed along which particle generation should move around the shape, relevant for Loop and PingPing emission modes.</doc>
		</field>
		<field name="interval" type="float">
			<doc>Determines the minimum interval allowed between the generated particles. 0 specifies the particles can be generated anywhere on the shape.</doc>
		</field>
	</struct>
	<class native="ParticleEmitterShape" script="ParticleEmitterShape">
		<doc>Base class from all emitter shapes. Emitter shapes determine the position and direction of newly created particles.</doc>
	</class>
	<enum native="ParticleEmitterConeType" script="ParticleEmitterConeType">
		<doc>Determines the emission type for the cone particle emitter shape.</doc>
		<enumentry native="Base" script="Base">
			<doc>Emit particles only from the cone base.</doc>
		</enumentry>
		<enumentry native="Volume" script="Volume">
			<doc>Emit particles from the entire cone volume.</doc>
		</enumentry>
	</enum>
	<enum native="FontRenderMode" script="FontRenderMode">
		<doc>Determines how is a font rendered into the bitmap texture.</doc>
		<enumentry native="Smooth" script="Smooth">
		</enumentry>
		<enumentry native="Raster" script="Raster">
		</enumentry>
		<enumentry native="HintedSmooth" script="HintedSmooth">
		</enumentry>
		<enumentry native="HintedRaster" script="HintedRaster">
		</enumentry>
	</enum>
	<struct native="PARTICLE_CONE_SHAPE_DESC" script="ParticleConeShapeOptions">
		<doc>Information describing a ParticleEmitterConeShape.</doc>
		<ctor>
		</ctor>
		<field name="type" type="ParticleEmitterConeType">
			<doc>Determines where on the cone are the particles emitter from.</doc>
		</field>
		<field name="radius" type="float">
			<doc>Radius of the cone base.</doc>
		</field>
		<field name="angle" type="Degree">
			<doc>Angle of the cone.</doc>
		</field>
		<field name="length" type="float">
			<doc>Length of the cone. Irrelevant if emission type is Base.</doc>
		</field>
		<field name="thickness" type="float">
			<doc>Proportion of the volume that can emit particles. Thickness of 0 results in particles being emitted only from the edge of the cone, while thickness of 1 results in particles being emitted from the entire volume. In-between values will use a part of the volume.</doc>
		</field>
		<field name="arc" type="Degree">
			<doc>Angular portion of the cone from which to emit particles from, in degrees.</doc>
		</field>
		<field name="mode" type="ParticleEmissionMode">
			<doc>Determines how will particle positions on the shape be generated.</doc>
		</field>
	</struct>
	<class native="ParticleEmitterConeShape" script="ParticleEmitterConeShape">
		<doc>Particle emitter shape that emits particles from a cone. Particles can be created on cone base or volume, while controling the radial arc of the emitted portion of the volume, as well as thickness of the cone emission volume. All particles will have random normals within the distribution of the cone.</doc>
		<ctor>
			<doc>Creates a new particle emitter cone shape.</doc>
			<param name="desc" type="ParticleConeShapeOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle emitter cone shape.</doc>
		</ctor>
		<property name="Options" type="ParticleConeShapeOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the shape.</doc>
		</property>
	</class>
	<enum native="VertexLayout" script="VertexLayout">
		<doc>Available vertex layouts that specify what data is provided per-vertex in a mesh. Combinations other than those provided are allowed.</doc>
		<enumentry native="PU" script="PU">
		</enumentry>
		<enumentry native="Position" script="Position">
		</enumentry>
		<enumentry native="Color" script="Color">
		</enumentry>
		<enumentry native="Normal" script="Normal">
		</enumentry>
		<enumentry native="UV1" script="UV1">
		</enumentry>
		<enumentry native="UV0" script="UV0">
		</enumentry>
		<enumentry native="BoneWeights" script="BoneWeights">
		</enumentry>
		<enumentry native="Tangent" script="Tangent">
		</enumentry>
		<enumentry native="PC" script="PC">
		</enumentry>
		<enumentry native="PCU" script="PCU">
		</enumentry>
		<enumentry native="PCN" script="PCN">
		</enumentry>
		<enumentry native="PCNU" script="PCNU">
		</enumentry>
		<enumentry native="PCNT" script="PCNT">
		</enumentry>
		<enumentry native="PCNTU" script="PCNTU">
		</enumentry>
		<enumentry native="PN" script="PN">
		</enumentry>
		<enumentry native="PNU" script="PNU">
		</enumentry>
		<enumentry native="PNT" script="PNT">
		</enumentry>
		<enumentry native="PNTU" script="PNTU">
		</enumentry>
	</enum>
	<struct native="PARTICLE_SPHERE_SHAPE_DESC" script="ParticleSphereShapeOptions">
		<doc>Information describing a ParticleEmitterSphereShape.</doc>
		<ctor>
		</ctor>
		<field name="radius" type="float">
			<doc>Radius of the sphere.</doc>
		</field>
		<field name="thickness" type="float">
			<doc>Proportion of the volume that can emit particles. Thickness of 0 results in particles being emitted only from the edge of the volume, while thickness of 1 results in particles being emitted from the entire volume. In-between values will use a part of the volume.</doc>
		</field>
	</struct>
	<class native="CSphericalJoint" script="SphericalJoint">
		<doc>A spherical joint removes all translational degrees of freedom but allows all rotational degrees of freedom. Essentially this ensures that the anchor points of the two bodies are always coincident. Bodies are allowed to rotate around the anchor points, and their rotatation can be limited by an elliptical cone.</doc>
		<method native="setFlag" script="SetFlag" static="false">
			<doc>Enables or disables a flag that controls the joint&apos;s behaviour.</doc>
			<param name="flag" type="SphericalJointFlag">
			</param>
			<param name="enabled" type="bool">
			</param>
		</method>
		<method native="hasFlag" script="HasFlag" static="false">
			<doc>Checks is the specified flag enabled.</doc>
			<param name="flag" type="SphericalJointFlag">
			</param>
			<returns type="bool">
			</returns>
		</method>
		<property name="Limit" type="LimitConeRange" getter="getLimit" setter="setLimit" static="false">
			<doc>Determines the limit of the joint. This clamps the rotation inside an eliptical angular cone. You must enable limit flag on the joint in order for this to be recognized.</doc>
		</property>
	</class>
	<class native="CReflectionProbe" script="ReflectionProbe">
		<doc>Specifies a location at which a pre-computed texture containing scene radiance will be generated. This texture will then be used by the renderer to provide specular reflections.</doc>
		<method native="capture" script="Capture" static="false">
			<doc>Captures the scene at the current location and generates a filtered reflection cubemap. No action is taken if a custom texture is set.</doc>
		</method>
		<property name="Type" type="ReflectionProbeType" getter="getType" setter="setType" static="false">
			<doc>Changes the type of the probe.</doc>
		</property>
		<property name="Radius" type="float" getter="getRadius" setter="setRadius" static="false">
			<doc>Sets the radius of a sphere reflection probe.</doc>
		</property>
		<property name="Extents" type="Vector3" getter="getExtents" setter="setExtents" static="false">
			<doc>Sets the extents of a box reflection probe. Determines range of influence.</doc>
		</property>
		<property name="CustomTexture" type="RRef&lt;Texture&gt;" getter="getCustomTexture" setter="setCustomTexture" static="false">
			<doc>Allows you assign a custom texture to use as a reflection map. This will disable automatic generation of reflections. To re-enable auto-generation call this with a null parameter.</doc>
		</property>
	</class>
	<class native="ParticleEmitterSphereShape" script="ParticleEmitterSphereShape">
		<doc>Particle emitter shape that emits particles from a sphere. Particles can be emitted from sphere surface, the entire volume or a proportion of the volume depending on the thickness parameter. All particles will have normals pointing outwards in a spherical direction.</doc>
		<ctor>
			<doc>Creates a new particle emitter sphere shape.</doc>
			<param name="desc" type="ParticleSphereShapeOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle emitter sphere shape.</doc>
		</ctor>
		<property name="Options" type="ParticleSphereShapeOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the shape.</doc>
		</property>
	</class>
	<struct native="PARTICLE_HEMISPHERE_SHAPE_DESC" script="ParticleHemisphereShapeOptions">
		<doc>Information describing a ParticleEmitterHemisphereShape.</doc>
		<ctor>
		</ctor>
		<field name="radius" type="float">
			<doc>Radius of the hemisphere.</doc>
		</field>
		<field name="thickness" type="float">
			<doc>Proportion of the volume that can emit particles. Thickness of 0 results in particles being emitted only from the edge of the volume, while thickness of 1 results in particles being emitted from the entire volume. In-between values will use a part of the volume.</doc>
		</field>
	</struct>
	<class native="ParticleEmitterHemisphereShape" script="ParticleEmitterHemisphereShape">
		<doc>Particle emitter shape that emits particles from a hemisphere. Particles can be emitted from the hemisphere surface, the entire volume or a proportion of the volume depending on the thickness parameter. All particles will have normals pointing outwards in a spherical direction.</doc>
		<ctor>
			<doc>Creates a new particle emitter sphere shape.</doc>
			<param name="desc" type="ParticleHemisphereShapeOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle emitter sphere shape.</doc>
		</ctor>
		<property name="Options" type="ParticleHemisphereShapeOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the shape.</doc>
		</property>
	</class>
	<class native="Shader" script="Shader">
		<doc>Contains definitions of GPU programs used for rendering, as well as a set of global parameters to control those programs.</doc>
		<property name="VariationParams" type="ShaderVariationParamInfo" getter="getVariationParams" setter="" static="false">
			<doc>Returns the list of all variation parameters supported by this shader, possible values of each parameter and other meta-data.</doc>
		</property>
		<property name="Parameters" type="ShaderParameter" getter="getParameters" setter="" static="false">
			<doc>Returns information about all parameters available in the shader.</doc>
		</property>
	</class>
	<enum native="ParticleEmitterBoxType" script="ParticleEmitterBoxType">
		<doc>Determines the emission type for the cone particle emitter shape.</doc>
		<enumentry native="Volume" script="Volume">
			<doc>Particles will be emitted from the entire volume.</doc>
		</enumentry>
		<enumentry native="Surface" script="Surface">
			<doc>Particles will be emitted only from box surface.</doc>
		</enumentry>
		<enumentry native="Edge" script="Edge">
			<doc>Particles will be emitted only from box edge.</doc>
		</enumentry>
	</enum>
	<struct native="PARTICLE_BOX_SHAPE_DESC" script="ParticleBoxShapeOptions">
		<doc>Information describing a ParticleEmitterBoxShape.</doc>
		<ctor>
		</ctor>
		<field name="type" type="ParticleEmitterBoxType">
			<doc>Determines from which portion of the box should particles be emitted from.</doc>
		</field>
		<field name="extents" type="Vector3">
			<doc>Extends of the box.</doc>
		</field>
	</struct>
	<class native="ParticleEmitterBoxShape" script="ParticleEmitterBoxShape">
		<doc>Particle emitter shape that emits particles from an axis aligned box. Particles can be emitted from box volume, surface or edges. All particles have their normals set to positive Z direction.</doc>
		<ctor>
			<doc>Creates a new particle emitter box shape.</doc>
			<param name="desc" type="ParticleBoxShapeOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle emitter box shape.</doc>
		</ctor>
		<property name="Options" type="ParticleBoxShapeOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the shape.</doc>
		</property>
	</class>
	<struct native="PARTICLE_LINE_SHAPE_DESC" script="ParticleLineShapeOptions">
		<doc>Information describing a ParticleEmitterLineShape.</doc>
		<ctor>
		</ctor>
		<field name="length" type="float">
			<doc>Length of the line.</doc>
		</field>
		<field name="mode" type="ParticleEmissionMode">
			<doc>Determines how will particle positions on the shape be generated.</doc>
		</field>
	</struct>
	<class native="ParticleEmitterLineShape" script="ParticleEmitterLineShape">
		<doc>Particle emitter shape that emits particles from a line segment.</doc>
		<ctor>
			<doc>Creates a new particle emitter edge shape.</doc>
			<param name="desc" type="ParticleLineShapeOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle emitter edge shape.</doc>
		</ctor>
		<property name="Options" type="ParticleLineShapeOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the shape.</doc>
		</property>
	</class>
	<struct native="PARTICLE_RECT_SHAPE_DESC" script="ParticleRectShapeOptions">
		<doc>Information describing a ParticleEmitterRectShape.</doc>
		<field name="extents" type="Vector2">
			<doc>Extents of the rectangle.</doc>
		</field>
	</struct>
	<class native="ParticleEmitterRectShape" script="ParticleEmitterRectShape">
		<doc>Particle emitter shape that emits particles from the surface of a rectangle.</doc>
		<ctor>
			<doc>Creates a new particle emitter rectangle shape.</doc>
			<param name="desc" type="ParticleRectShapeOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle emitter rectangle shape.</doc>
		</ctor>
		<property name="Options" type="ParticleRectShapeOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the shape.</doc>
		</property>
	</class>
	<enum native="ParticleEmitterMeshType" script="ParticleEmitterMeshType">
		<doc>Determines the emission type for the mesh particle emitter shape.</doc>
		<enumentry native="Vertex" script="Vertex">
			<doc>Particles will be emitted from mesh vertices.</doc>
		</enumentry>
		<enumentry native="Edge" script="Edge">
			<doc>Particles will be emitted from mesh edges.</doc>
		</enumentry>
		<enumentry native="Triangle" script="Triangle">
			<doc>Particles will be emitted from mesh triangles.</doc>
		</enumentry>
	</enum>
	<struct native="PARTICLE_STATIC_MESH_SHAPE_DESC" script="ParticleStaticMeshShapeOptions">
		<doc>Information describing a ParticleEmitterStaticMeshShape.</doc>
		<ctor>
		</ctor>
		<field name="type" type="ParticleEmitterMeshType">
			<doc>Determines from which portion of the mesh are the particles emitted from.</doc>
		</field>
		<field name="sequential" type="bool">
			<doc>When enabled the particles will be emitted sequentially from mesh vertices in the order they are defined. Only relevant for the Vertex emit mode.</doc>
		</field>
		<field name="mesh" type="RRef&lt;Mesh&gt;">
			<doc>Mesh to spawn particles on. Must at least contain per-vertex position data encoded as 3D float vectors. Can optionally contain per-vertex normals encoded as 3D float vectors or as 4-byte unsigned-normalized format.</doc>
		</field>
	</struct>
	<struct native="PARTICLE_SKINNED_MESH_SHAPE_DESC" script="ParticleSkinnedMeshShapeOptions">
		<doc>Information describing a ParticleEmitterSkinnedMeshShape.</doc>
		<ctor>
		</ctor>
		<field name="type" type="ParticleEmitterMeshType">
			<doc>Determines from which portion of the mesh are the particles emitted from.</doc>
		</field>
		<field name="sequential" type="bool">
			<doc>When enabled the particles will be emitted sequentially from mesh vertices in the order they are defined. Only relevant for the Vertex emit mode.</doc>
		</field>
		<field name="renderable" type="Renderable">
			<doc>Renderable object containing a mesh to spawn particles on, as well as the attached Animation object resposible for performing skinned animation. Mesh must at least contain per-vertex position data encoded as 3D float vectors, blend indices encoded in 4-byte format, and blend weights encoded a 4D float vectors. Can optionally contain per-vertex normals encoded as 3D float vectors or as 4-byte unsigned-normalized format.</doc>
		</field>
	</struct>
	<class native="ParticleEmitterSkinnedMeshShape" script="ParticleEmitterSkinnedMeshShape">
		<doc>Particle emitter shape that emits particles from a surface of a skinned (animated) mesh. Particles can be emitted from mesh vertices, edges or triangles. If information about normals exists, particles will also inherit the normals.</doc>
		<ctor>
			<doc>Creates a new particle emitter skinned mesh shape.</doc>
			<param name="desc" type="ParticleSkinnedMeshShapeOptions">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new particle emitter skinned mesh shape.</doc>
		</ctor>
		<property name="Options" type="ParticleSkinnedMeshShapeOptions" getter="getOptions" setter="setOptions" static="false">
			<doc>Options describing the shape.</doc>
		</property>
	</class>
	<struct native="ParticleBurst" script="ParticleBurst">
		<doc>Specifies a burst of particles that occurs at a certain time point.</doc>
		<ctor>
		</ctor>
		<ctor>
			<param name="time" type="float">
			</param>
			<param name="count" type="FloatDistribution">
			</param>
			<param name="cycles" type="int">
			</param>
			<param name="interval" type="float">
			</param>
		</ctor>
		<field name="time" type="float">
			<doc>Time at which to trigger the burst, in seconds.</doc>
		</field>
		<field name="count" type="FloatDistribution">
			<doc>Number of particles to emit when the burst triggers.</doc>
		</field>
		<field name="cycles" type="int">
			<doc>Determines how many times to trigger the burst. If 0 the burst will trigger infinitely. Use <see cref="interval"/> to to control the time between each cycle.</doc>
		</field>
		<field name="interval" type="float">
			<doc>Controls how much time needs to pass before triggering another burst cycle, in seconds.</doc>
		</field>
	</struct>
	<class native="ParticleEmitter" script="ParticleEmitter">
		<doc>Handles spawning of new particles using the specified parameters and shape.</doc>
		<ctor>
			<doc>Creates a new emitter.</doc>
		</ctor>
		<property name="Shape" type="ParticleEmitterShape" getter="getShape" setter="setShape" static="false">
			<doc>Shape over which to emit the particles.</doc>
		</property>
		<property name="EmissionRate" type="FloatDistribution" getter="getEmissionRate" setter="setEmissionRate" static="false">
			<doc>Determines the number of particles that are emitted every second.</doc>
		</property>
		<property name="EmissionBursts" type="ParticleBurst" getter="getEmissionBursts" setter="setEmissionBursts" static="false">
			<doc>Determines discrete intervals to emit particles.</doc>
		</property>
		<property name="InitialLifetime" type="FloatDistribution" getter="getInitialLifetime" setter="setInitialLifetime" static="false">
			<doc>Determines the lifetime of particles when they are initially spawned, in seconds.</doc>
		</property>
		<property name="InitialSpeed" type="FloatDistribution" getter="getInitialSpeed" setter="setInitialSpeed" static="false">
			<doc>Sets the initial speed of the particles, in meters/second. The speed is applied along the particle&apos;s velocity direction, which is determined by the emission shape and potentially other properties.</doc>
		</property>
		<property name="InitialSize" type="FloatDistribution" getter="getInitialSize" setter="setInitialSize" static="false">
			<doc>Determines the size of the particles when initially spawned. The size is applied uniformly in all dimensions. Only used if 3D size is disabled.</doc>
		</property>
		<property name="InitialSize3D" type="Vector3Distribution" getter="getInitialSize3D" setter="setInitialSize3D" static="false">
			<doc>Determines the size of the particles when initially spawned. Size can be specified for each dimension separately. Only used if 3D size is enabled.</doc>
		</property>
		<property name="Use3DSize" type="bool" getter="getUse3DSize" setter="setUse3DSize" static="false">
			<doc>Determines should the initial particle size be applied uniformly (if disabled), or evaluated separately for each dimension (if enabled).</doc>
		</property>
		<property name="InitialRotation" type="FloatDistribution" getter="getInitialRotation" setter="setInitialRotation" static="false">
			<doc>Determines the rotation of the particles when initially spawned, in degrees. The rotation is applied around the particle&apos;s local Z axis. Only used if 3D rotation is disabled.</doc>
		</property>
		<property name="InitialRotation3D" type="Vector3Distribution" getter="getInitialRotation3D" setter="setInitialRotation3D" static="false">
			<doc>Determines the rotation of the particles when initially spawned, in Euler angles. Only used if 3D rotation is enabled.</doc>
		</property>
		<property name="Use3DRotation" type="bool" getter="getUse3DRotation" setter="setUse3DRotation" static="false">
			<doc>Determines should the initial particle rotation be a single angle applied around a Z axis (if disabled), or a set of Euler angles that allow you to rotate around every axis (if enabled).</doc>
		</property>
		<property name="InitialColor" type="ColorDistribution" getter="getInitialColor" setter="setInitialColor" static="false">
			<doc>Determines the initial color (in RGB channels) and transparency (in A channel) of particles.</doc>
		</property>
		<property name="RandomOffset" type="float" getter="getRandomOffset" setter="setRandomOffset" static="false">
			<doc>Determines a range of values determining a random offset to apply to particle position after it has been emitted. Offset will be randomly selected in all three axes in range [-value, value].</doc>
		</property>
		<property name="FlipU" type="float" getter="getFlipU" setter="setFlipU" static="false">
			<doc>Determines should particle U texture coordinate be randomly flipped, mirroring the image. The value represents a percent of particles that should be flipped, in range [0, 1].</doc>
		</property>
		<property name="FlipV" type="float" getter="getFlipV" setter="setFlipV" static="false">
			<doc>Determines should particle V texture coordinate be randomly flipped, mirroring the image. The value represents a percent of particles that should be flipped, in range [0, 1].</doc>
		</property>
	</class>
	<enum native="ParticleOrientation" script="ParticleOrientation">
		<doc>Possible orientations when rendering billboard particles.</doc>
		<enumentry native="ViewPlane" script="ViewPlane">
			<doc>Orient towards view (camera) plane.</doc>
		</enumentry>
		<enumentry native="ViewPosition" script="ViewPosition">
			<doc>Orient towards view (camera) position.</doc>
		</enumentry>
		<enumentry native="Plane" script="Plane">
			<doc>Orient with a user-provided axis.</doc>
		</enumentry>
	</enum>
	<enum native="ParticleSimulationSpace" script="ParticleSimulationSpace">
		<doc>Space in which to spawn/transform particles.</doc>
		<enumentry native="Local" script="Local">
			<doc>Particles will always remain local to their transform parent. This means if the transform parent moves so will all the particles.</doc>
		</enumentry>
		<enumentry native="World" script="World">
			<doc>Particles will be placed in world space. This means they will spawn at the location of the transform parent, but are no longer affected by its transform after spawn (e.g. smoke rising from a moving train).</doc>
		</enumentry>
	</enum>
	<enum native="ParticleSortMode" script="ParticleSortMode">
		<doc>Determines how to sort particles before rendering.</doc>
		<enumentry native="None" script="None">
			<doc>Do not sort the particles.</doc>
		</enumentry>
		<enumentry native="Distance" script="Distance">
			<doc>Sort by distance from the camera, furthest to nearest.</doc>
		</enumentry>
		<enumentry native="OldToYoung" script="OldToYoung">
			<doc>Sort by age, oldest to youngest.</doc>
		</enumentry>
		<enumentry native="YoungToOld" script="YoungToOld">
			<doc>Sort by age, youngest to oldest.</doc>
		</enumentry>
	</enum>
	<class native="ParticleDepthCollisionSettings" script="ParticleDepthCollisionSettings">
		<doc>Controls depth buffer collisions for GPU simulated particles.</doc>
		<ctor>
		</ctor>
		<property name="Enabled" type="bool" getter="getenabled" setter="setenabled" static="false">
			<doc>Determines if depth collisions are enabled.</doc>
		</property>
		<property name="Restitution" type="float" getter="getrestitution" setter="setrestitution" static="false">
			<doc>Determines the elasticity (bounciness) of the particle collision. Lower values make the collision less bouncy and higher values more.</doc>
		</property>
		<property name="Dampening" type="float" getter="getdampening" setter="setdampening" static="false">
			<doc>Determines how much velocity should a particle lose after a collision, in percent of its current velocity. In range [0, 1].</doc>
		</property>
		<property name="RadiusScale" type="float" getter="getradiusScale" setter="setradiusScale" static="false">
			<doc>Scale which to apply to particle size in order to determine the collision radius.</doc>
		</property>
	</class>
	<class native="ParticleVectorFieldSettings" script="ParticleVectorFieldSettings">
		<doc>Settings used for controlling a vector field in a GPU simulated particle system.</doc>
		<property name="VectorField" type="RRef&lt;VectorField&gt;" getter="getvectorField" setter="setvectorField" static="false">
			<doc>Vector field resource used for influencing the particles.</doc>
		</property>
		<property name="Intensity" type="float" getter="getintensity" setter="setintensity" static="false">
			<doc>Intensity of the forces and velocities applied by the vector field.</doc>
		</property>
		<property name="Tightness" type="float" getter="gettightness" setter="settightness" static="false">
			<doc>Determines how closely does the particle velocity follow the vectors in the field. If set to 1 particles will be snapped to the exact velocity of the value in the field, and if set to 0 the field will not influence particle velocities directly.</doc>
		</property>
		<property name="Scale" type="Vector3" getter="getscale" setter="setscale" static="false">
			<doc>Scale to apply to the vector field bounds. This is multiplied with the bounds of the vector field resource.</doc>
		</property>
		<property name="Offset" type="Vector3" getter="getoffset" setter="setoffset" static="false">
			<doc>Amount of to move the vector field by relative to the parent particle system. This is added to the bounds provided in the vector field resource.</doc>
		</property>
		<property name="Rotation" type="Quaternion" getter="getrotation" setter="setrotation" static="false">
			<doc>Initial rotation of the vector field.</doc>
		</property>
		<property name="RotationRate" type="Vector3Distribution" getter="getrotationRate" setter="setrotationRate" static="false">
			<doc>Determines the amount to rotate the vector field every second, in degrees, around XYZ axis respectively. Evaluated over the particle system lifetime.</doc>
		</property>
		<property name="TilingX" type="bool" getter="gettilingX" setter="settilingX" static="false">
			<doc>Determines should the field influence particles outside of the field bounds. If true the field will be tiled infinitely in the X direction.</doc>
		</property>
		<property name="TilingY" type="bool" getter="gettilingY" setter="settilingY" static="false">
			<doc>Determines should the field influence particles outside of the field bounds. If true the field will be tiled infinitely in the Y direction.</doc>
		</property>
		<property name="TilingZ" type="bool" getter="gettilingZ" setter="settilingZ" static="false">
			<doc>Determines should the field influence particles outside of the field bounds. If true the field will be tiled infinitely in the Z direction.</doc>
		</property>
	</class>
	<class native="ParticleSystemSettings" script="ParticleSystemSettings">
		<doc>Generic settings used for controlling a ParticleSystem.</doc>
		<property name="Material" type="RRef&lt;Material&gt;" getter="getmaterial" setter="setmaterial" static="false">
			<doc>Material to render the particles with.</doc>
		</property>
		<property name="Mesh" type="RRef&lt;Mesh&gt;" getter="getmesh" setter="setmesh" static="false">
			<doc>Mesh used for representing individual particles when using the Mesh rendering mode.</doc>
		</property>
		<property name="SimulationSpace" type="ParticleSimulationSpace" getter="getsimulationSpace" setter="setsimulationSpace" static="false">
			<doc>Determines in which space are particles in.</doc>
		</property>
		<property name="Orientation" type="ParticleOrientation" getter="getorientation" setter="setorientation" static="false">
			<doc>Determines how are particles oriented when rendering.</doc>
		</property>
		<property name="Duration" type="float" getter="getduration" setter="setduration" static="false">
			<doc>Determines the time period during which the system runs, in seconds. This effects evaluation of distributions with curves using particle system time for evaluation.</doc>
		</property>
		<property name="IsLooping" type="bool" getter="getisLooping" setter="setisLooping" static="false">
			<doc>Determines should the particle system time wrap around once it reaches its duration.</doc>
		</property>
		<property name="MaxParticles" type="int" getter="getmaxParticles" setter="setmaxParticles" static="false">
			<doc>Determines the maximum number of particles that can ever be active in this system. This number is ignored if GPU simulation is enabled, and instead particle count is instead only limited by the size of the internal buffers (shared between all particle systems).</doc>
		</property>
		<property name="GpuSimulation" type="bool" getter="getgpuSimulation" setter="setgpuSimulation" static="false">
			<doc>If true the particle system will be simulated on the GPU. This allows much higher particle counts at lower performance cost. GPU simulation ignores any provided evolvers and instead uses ParticleGpuSimulationSettings to customize the GPU simulation.</doc>
		</property>
		<property name="RenderMode" type="ParticleRenderMode" getter="getrenderMode" setter="setrenderMode" static="false">
			<doc>Determines how is each particle represented on the screen.</doc>
		</property>
		<property name="OrientationLockY" type="bool" getter="getorientationLockY" setter="setorientationLockY" static="false">
			<doc>Determines should the particles only be allowed to orient themselves around the Y axis, or freely. Ignored if using the Plane orientation mode.</doc>
		</property>
		<property name="OrientationPlaneNormal" type="Vector3" getter="getorientationPlaneNormal" setter="setorientationPlaneNormal" static="false">
			<doc>Determines a normal of the plane to orient particles towards. Only used if particle orientation mode is set to ParticleOrientation::Plane.</doc>
		</property>
		<property name="SortMode" type="ParticleSortMode" getter="getsortMode" setter="setsortMode" static="false">
			<doc>Determines how (and if) are particles sorted. Sorting controls in what order are particles rendered. If GPU simulation is enabled only distance based sorting is supported.</doc>
		</property>
		<property name="UseAutomaticSeed" type="bool" getter="getuseAutomaticSeed" setter="setuseAutomaticSeed" static="false">
			<doc>Determines should an automatic seed be used for the internal random number generator. This ensures the particle system yields different results each time it is ran.</doc>
		</property>
		<property name="ManualSeed" type="int" getter="getmanualSeed" setter="setmanualSeed" static="false">
			<doc>Determines the seed to use for the internal random number generator. Allows you to guarantee identical behaviour between different runs. Only relevant if automatic seed is disabled.</doc>
		</property>
		<property name="UseAutomaticBounds" type="bool" getter="getuseAutomaticBounds" setter="setuseAutomaticBounds" static="false">
			<doc>Determines should the particle system bounds be automatically calculated, or should the fixed value provided be used. Bounds are used primarily for culling purposes. Note that automatic bounds are not supported when GPU simulation is enabled.</doc>
		</property>
		<property name="CustomBounds" type="AABox" getter="getcustomBounds" setter="setcustomBounds" static="false">
			<doc>Custom bounds to use them <see cref="useAutomaticBounds"/> is disabled. The bounds are in the simulation space of the particle system.</doc>
		</property>
	</class>
	<class native="ParticleGpuSimulationSettings" script="ParticleGpuSimulationSettings">
		<doc>Settings used for controlling particle system GPU simulation.</doc>
		<property name="VectorField" type="ParticleVectorFieldSettings" getter="getvectorField" setter="setvectorField" static="false">
		</property>
		<property name="ColorOverLifetime" type="ColorDistribution" getter="getcolorOverLifetime" setter="setcolorOverLifetime" static="false">
			<doc>Determines particle color, evaluated over the particle lifetime.</doc>
		</property>
		<property name="SizeScaleOverLifetime" type="Vector2Distribution" getter="getsizeScaleOverLifetime" setter="setsizeScaleOverLifetime" static="false">
			<doc>Determines particle size, evaluated over the particle lifetime. Multiplied by the initial particle size.</doc>
		</property>
		<property name="Acceleration" type="Vector3" getter="getacceleration" setter="setacceleration" static="false">
			<doc>Constant acceleration to apply for each step of the simulation.</doc>
		</property>
		<property name="Drag" type="float" getter="getdrag" setter="setdrag" static="false">
			<doc>Amount of resistance to apply in the direction opposite of the particle&apos;s velocity.</doc>
		</property>
		<property name="DepthCollision" type="ParticleDepthCollisionSettings" getter="getdepthCollision" setter="setdepthCollision" static="false">
			<doc>Settings controlling particle depth buffer collisions.</doc>
		</property>
	</class>
	<class native="CParticleSystem" script="ParticleSystem">
		<doc>Controls spawning, evolution and rendering of particles. Particles can be 2D or 3D, with a variety of rendering options. Particle system should be used for rendering objects that cannot properly be represented using static or animated meshes, like liquids, smoke or flames.
The particle system requires you to specify at least one ParticleEmitter, which controls how are new particles generated. You will also want to specify one or more ParticleEvolver%s, which change particle properties over time.</doc>
		<method native="_togglePreviewMode" script="TogglePreviewMode" static="false">
			<doc>Enables or disabled preview mode. Preview mode allows the particle system to play while the game is not running, primarily for preview purposes in the editor. Returns true if the preview mode was enabled, false if it was disabled or enabling preview failed.</doc>
			<param name="enabled" type="bool">
			</param>
			<returns type="bool">
			</returns>
		</method>
		<property name="Settings" type="ParticleSystemSettings" getter="getSettings" setter="setSettings" static="false">
			<doc>Determines general purpose settings that apply to the particle system.</doc>
		</property>
		<property name="GpuSimulationSettings" type="ParticleGpuSimulationSettings" getter="getGpuSimulationSettings" setter="setGpuSimulationSettings" static="false">
			<doc>Determines settings that control particle GPU simulation.</doc>
		</property>
		<property name="Emitters" type="ParticleEmitter" getter="getEmitters" setter="setEmitters" static="false">
			<doc>Set of objects that determine initial position, normal and other properties of newly spawned particles. Each particle system must have at least one emitter.</doc>
		</property>
		<property name="Evolvers" type="ParticleEvolver" getter="getEvolvers" setter="setEvolvers" static="false">
			<doc>Set of objects that determine how particle properties change during their lifetime. Evolvers only affect CPU simulated particles.</doc>
		</property>
		<property name="Layer" type="ulong" getter="getLayer" setter="setLayer" static="false">
			<doc>Determines the layer bitfield that controls whether a system is considered visible in a specific camera. Layer must match camera layer in order for the camera to render the component.</doc>
		</property>
	</class>
	<class native="CPlaneCollider" script="PlaneCollider">
		<doc>A collider with plane geometry. Plane colliders cannot be a part of non-kinematic rigidbodies.</doc>
		<property name="Normal" type="Vector3" getter="getNormal" setter="setNormal" static="false">
			<doc>Normal vector that determines the local orientation of the plane.</doc>
		</property>
		<property name="Distance" type="float" getter="getDistance" setter="setDistance" static="false">
			<doc>Determines the distance of the plane from the local origin, along its normal vector.</doc>
		</property>
	</class>
	<enum native="ReflectionProbeType" script="ReflectionProbeType">
		<doc>Probe type that determines the shape of the probe and how is it interpreted by the renderer.</doc>
		<enumentry native="Box" script="Box">
			<doc>Reflection probe cubemap is generated, and box extents are used for calculating influence ranges and box geometry.</doc>
		</enumentry>
		<enumentry native="Sphere" script="Sphere">
			<doc>Reflection probe cubemap is generated, but sphere is used for calculating the influence radius and proxy geometry.</doc>
		</enumentry>
	</enum>
	<class native="CRenderable" script="Renderable">
		<doc>Renderable represents any visible object in the scene. It has a mesh, bounds and a set of materials. Renderer will render any Renderable objects visible by a camera.</doc>
		<method native="setMaterial" script="SetMaterial" static="false">
			<doc>Sets a material that will be used for rendering a sub-mesh with the specified index. If a sub-mesh doesn&apos;t have a specific material set then the primary material will be used.</doc>
			<param name="idx" type="int">
			</param>
			<param name="material" type="RRef&lt;Material&gt;">
			</param>
		</method>
		<method native="setMaterial" script="SetMaterial" static="false">
			<doc>Sets a material that will be used for rendering a sub-mesh with the specified index. If a sub-mesh doesn&apos;t have a specific material set then the primary material will be used.</doc>
			<param name="material" type="RRef&lt;Material&gt;">
			</param>
		</method>
		<method native="getMaterial" script="GetMaterial" static="false">
			<doc>Returns the material used for rendering a sub-mesh with the specified index.</doc>
			<param name="idx" type="int">
			</param>
			<returns type="RRef&lt;Material&gt;">
			</returns>
		</method>
		<property name="Mesh" type="RRef&lt;Mesh&gt;" getter="getMesh" setter="setMesh" static="false">
			<doc>Determines the mesh to render. All sub-meshes of the mesh will be rendered, and you may set individual materials for each sub-mesh.</doc>
		</property>
		<property name="Materials" type="RRef&lt;Material&gt;" getter="getMaterials" setter="setMaterials" static="false">
			<doc>Determines all materials used for rendering this renderable. Each of the materials is used for rendering a single sub-mesh. If number of materials is larger than number of sub-meshes, they will be ignored. If lower, the remaining materials will be removed.</doc>
		</property>
		<property name="CullDistance" type="float" getter="getCullDistanceFactor" setter="setCullDistanceFactor" static="false">
			<doc>Factor to be applied to the cull distance set in the camera&apos;s render settings.</doc>
		</property>
		<property name="WriteVelocity" type="bool" getter="getWriteVelocity" setter="setWriteVelocity" static="false">
			<doc>If enabled this renderable will write per-pixel velocity information when rendered. This is required for effects such as temporal anti-aliasing and motion blur, but comes with a minor performance overhead. If you are not using those effects you can disable this for a performance gain.</doc>
		</property>
		<property name="Layers" type="ulong" getter="getLayer" setter="setLayer" static="false">
			<doc>Determines the layer bitfield that controls whether a renderable is considered visible in a specific camera. Renderable layer must match camera layer in order for the camera to render the component.</doc>
		</property>
		<property name="Bounds" type="Bounds" getter="getBounds" setter="" static="false">
			<doc>Gets world bounds of the mesh rendered by this object.</doc>
		</property>
	</class>
	<enum native="ForceMode" script="ForceMode">
		<doc>Type of force or torque that can be applied to a rigidbody.</doc>
		<enumentry native="Force" script="Force">
			<doc>Value applied is a force.</doc>
		</enumentry>
		<enumentry native="Impulse" script="Impulse">
			<doc>Value applied is an impulse (a direct change in its linear or angular momentum).</doc>
		</enumentry>
		<enumentry native="Velocity" script="Velocity">
			<doc>Value applied is velocity.</doc>
		</enumentry>
		<enumentry native="Acceleration" script="Acceleration">
			<doc>Value applied is accelearation.</doc>
		</enumentry>
	</enum>
	<class native="CRigidbody" script="Rigidbody">
		<doc>Rigidbody is a dynamic physics object that can be moved using forces (or directly). It will interact with other static and dynamic physics objects in the scene accordingly (it will push other non-kinematic rigidbodies, and collide with static objects).
The shape and mass of a rigidbody is governed by its colliders. You must attach at least one collider for the rigidbody to be valid.</doc>
		<method native="move" script="Move" static="false">
			<doc>Moves the rigidbody to a specific position. This method will ensure physically correct movement, meaning the body will collide with other objects along the way.</doc>
			<param name="position" type="Vector3">
			</param>
		</method>
		<method native="rotate" script="Rotate" static="false">
			<doc>Rotates the rigidbody. This method will ensure physically correct rotation, meaning the body will collide with other objects along the way.</doc>
			<param name="rotation" type="Quaternion">
			</param>
		</method>
		<method native="sleep" script="Sleep" static="false">
			<doc>Forces the object to sleep. Useful if you know the object will not move in any significant way for a while.</doc>
		</method>
		<method native="wakeUp" script="WakeUp" static="false">
			<doc>Wakes an object up. Useful if you modified properties of this object, and potentially surrounding objects which might result in the object being moved by physics (although the physics system will automatically wake the object up for majority of such cases).</doc>
		</method>
		<method native="addForce" script="AddForce" static="false">
			<doc>Applies a force to the center of the mass of the rigidbody. This will produce linear momentum.</doc>
			<param name="force" type="Vector3">
				<doc>Force to apply.</doc>
			</param>
			<param name="mode" type="ForceMode">
				<doc>Determines what is the type of <paramref name="force"/>.</doc>
			</param>
		</method>
		<method native="addTorque" script="AddTorque" static="false">
			<doc>Applies a torque to the rigidbody. This will produce angular momentum.</doc>
			<param name="torque" type="Vector3">
				<doc>Torque to apply.</doc>
			</param>
			<param name="mode" type="ForceMode">
				<doc>Determines what is the type of <paramref name="torque"/>.</doc>
			</param>
		</method>
		<method native="addForceAtPoint" script="AddForceAtPoint" static="false">
			<doc>Applies a force to a specific point on the rigidbody. This will in most cases produce both linear and angular momentum.</doc>
			<param name="force" type="Vector3">
				<doc>Force to apply.</doc>
			</param>
			<param name="position" type="Vector3">
				<doc>World position to apply the force at.</doc>
			</param>
			<param name="mode" type="PointForceMode">
				<doc>Determines what is the type of <paramref name="force"/>.</doc>
			</param>
		</method>
		<method native="getVelocityAtPoint" script="GetVelocityAtPoint" static="false">
			<doc>Returns the total (linear + angular) velocity at a specific point.</doc>
			<param name="point" type="Vector3">
				<doc>Point in world space.</doc>
			</param>
			<returns type="Vector3">
				<doc>Total velocity of the point.</doc>
			</returns>
		</method>
		<property name="Mass" type="float" getter="getMass" setter="setMass" static="false">
			<doc>Determines the mass of the object and all of its collider shapes. Only relevant if RigidbodyFlag::AutoMass or RigidbodyFlag::AutoTensors is turned off. Value of zero means the object is immovable (but can be rotated).</doc>
		</property>
		<property name="IsKinematic" type="bool" getter="getIsKinematic" setter="setIsKinematic" static="false">
			<doc>Determines if the body is kinematic. Kinematic body will not move in response to external forces (for example gravity, or another object pushing it), essentially behaving like collider. Unlike a collider though, you can still move the object and have other dynamic objects respond correctly (meaning it will push other objects).</doc>
		</property>
		<property name="IsSleeping" type="bool" getter="isSleeping" setter="" static="false">
			<doc>Checks if the body is sleeping. Objects that aren&apos;t moved/rotated for a while are put to sleep to reduce load on the physics system.</doc>
		</property>
		<property name="SleepThreshold" type="float" getter="getSleepThreshold" setter="setSleepThreshold" static="false">
			<doc>Determines a threshold of force and torque under which the object will be considered to be put to sleep.</doc>
		</property>
		<property name="UseGravity" type="bool" getter="getUseGravity" setter="setUseGravity" static="false">
			<doc>Determines whether or not the rigidbody will have the global gravity force applied to it.</doc>
		</property>
		<property name="Velocity" type="Vector3" getter="getVelocity" setter="setVelocity" static="false">
			<doc>Determines the linear velocity of the body.</doc>
		</property>
		<property name="AngularVelocity" type="Vector3" getter="getAngularVelocity" setter="setAngularVelocity" static="false">
			<doc>Determines the angular velocity of the body.</doc>
		</property>
		<property name="Drag" type="float" getter="getDrag" setter="setDrag" static="false">
			<doc>Determines the linear drag of the body. Higher drag values means the object resists linear movement more.</doc>
		</property>
		<property name="AngularDrag" type="float" getter="getAngularDrag" setter="setAngularDrag" static="false">
			<doc>Determines the angular drag of the body. Higher drag values means the object resists angular movement more.</doc>
		</property>
		<property name="InertiaTensor" type="Vector3" getter="getInertiaTensor" setter="setInertiaTensor" static="false">
			<doc>Determines the inertia tensor in local mass space. Inertia tensor determines how difficult is to rotate the object. Values of zero in the inertia tensor mean the object will be unable to rotate around a specific axis. Only relevant if RigidbodyFlag::AutoTensors is turned off.</doc>
		</property>
		<property name="MaxAngularVelocity" type="float" getter="getMaxAngularVelocity" setter="setMaxAngularVelocity" static="false">
			<doc>Determines the maximum angular velocity of the rigidbody. Velocity will be clamped to this value.</doc>
		</property>
		<property name="CenterOfMassPosition" type="Vector3" getter="getCenterOfMassPosition" setter="setCenterOfMassPosition" static="false">
			<doc>Determines the rigidbody&apos;s center of mass position. Only relevant if RigibodyFlag::AutoTensors is turned off.</doc>
		</property>
		<property name="CenterOfMassRotation" type="Quaternion" getter="getCenterOfMassRotation" setter="setCenterOfMassRotation" static="false">
			<doc>Determines the rigidbody&apos;s center of mass rotation. Only relevant if RigibodyFlag::AutoTensors is turned off.</doc>
		</property>
		<property name="PositionSolverCount" type="int" getter="getPositionSolverCount" setter="setPositionSolverCount" static="false">
			<doc>Determines the number of iterations to use when solving for position. Higher values can improve precision and numerical stability of the simulation.</doc>
		</property>
		<property name="VelocitySolverCount" type="int" getter="getVelocitySolverCount" setter="setVelocitySolverCount" static="false">
			<doc>Determines the number of iterations to use when solving for velocity. Higher values can improve precision and numerical stability of the simulation.</doc>
		</property>
		<property name="CollisionReportMode" type="CollisionReportMode" getter="getCollisionReportMode" setter="setCollisionReportMode" static="false">
			<doc>Sets a value that determines which (if any) collision events are reported.</doc>
		</property>
		<property name="Flags" type="RigidbodyFlag" getter="getFlags" setter="setFlags" static="false">
			<doc>Flags that control the behaviour of the rigidbody.</doc>
		</property>
		<event native="onCollisionBegin" script="OnCollisionBegin" static="false">
			<doc>Triggered when one of the colliders owned by the rigidbody starts colliding with another object.</doc>
			<param name="p0" type="CollisionData">
			</param>
		</event>
		<event native="onCollisionStay" script="OnCollisionStay" static="false">
			<doc>Triggered when a previously colliding collider stays in collision. Triggered once per frame.</doc>
			<param name="p0" type="CollisionData">
			</param>
		</event>
		<event native="onCollisionEnd" script="OnCollisionEnd" static="false">
			<doc>Triggered when one of the colliders owned by the rigidbody stops colliding with another object.</doc>
			<param name="p0" type="CollisionData">
			</param>
		</event>
	</class>
	<class native="CSkybox" script="Skybox">
		<doc>Allows you to specify an environment map to use for sampling radiance of the sky.</doc>
		<property name="Texture" type="RRef&lt;Texture&gt;" getter="getTexture" setter="setTexture" static="false">
			<doc>Determines an environment map to use for sampling skybox radiance. Must be a cube-map texture, and should ideally contain HDR data.</doc>
		</property>
		<property name="Brightness" type="float" getter="getBrightness" setter="setBrightness" static="false">
			<doc>Brightness multiplier that will be applied to skybox values before they&apos;re being used. Allows you to make the skybox more or less bright. Equal to one by default.</doc>
		</property>
	</class>
	<enum native="SliderJointFlag" script="SliderJointFlag">
		<doc>Flag that controls slider joint&apos;s behaviour.</doc>
		<enumentry native="Limit" script="Limit">
			<doc>Enables the linear range limit.</doc>
		</enumentry>
	</enum>
	<class native="CSliderJoint" script="SliderJoint">
		<doc>Joint that removes all but a single translational degree of freedom. Bodies are allowed to move along a single axis.</doc>
		<method native="setFlag" script="SetFlag" static="false">
			<doc>Enables or disables a flag that controls the joint&apos;s behaviour.</doc>
			<param name="flag" type="SliderJointFlag">
			</param>
			<param name="enabled" type="bool">
			</param>
		</method>
		<method native="hasFlag" script="HasFlag" static="false">
			<doc>Checks is the specified flag enabled.</doc>
			<param name="flag" type="SliderJointFlag">
			</param>
			<returns type="bool">
			</returns>
		</method>
		<property name="Position" type="float" getter="getPosition" setter="" static="false">
			<doc>Returns the current position of the slider.</doc>
		</property>
		<property name="Speed" type="float" getter="getSpeed" setter="" static="false">
			<doc>Returns the current speed of the slider.</doc>
		</property>
		<property name="Limit" type="LimitLinearRange" getter="getLimit" setter="setLimit" static="false">
			<doc>Determines a limit that constrains the movement of the joint to a specific minimum and maximum distance. You must enable the limit flag on the joint in order for this to be recognized.</doc>
		</property>
	</class>
	<class native="CSphereCollider" script="SphereCollider">
		<doc>A collider with sphere geometry.</doc>
		<property name="Radius" type="float" getter="getRadius" setter="setRadius" static="false">
			<doc>Determines the radius of the sphere geometry.</doc>
		</property>
		<property name="Center" type="Vector3" getter="getCenter" setter="setCenter" static="false">
			<doc>Determines position of the sphere shape, relative to the component&apos;s scene object.</doc>
		</property>
	</class>
	<class native="SpriteTexture" script="SpriteTexture">
		<doc>Texture that references a part of a larger texture by specifying an UV subset. When the sprite texture is rendererd only the portion of the texture specified by the UV subset will be rendered. This allows you to use the same texture for multiple sprites (texture atlasing). Sprite textures also allow you to specify sprite sheet animation by varying which portion of the UV is selected over time.</doc>
		<ctor>
			<doc>Creates a new sprite texture that references the entire area of the provided texture.</doc>
			<param name="texture" type="RRef&lt;Texture&gt;">
			</param>
		</ctor>
		<ctor>
			<doc>Creates a new sprite texture that references a sub-area of the provided texture.</doc>
			<param name="uvOffset" type="Vector2">
			</param>
			<param name="uvScale" type="Vector2">
			</param>
			<param name="texture" type="RRef&lt;Texture&gt;">
			</param>
		</ctor>
		<property name="Texture" type="RRef&lt;Texture&gt;" getter="getTexture" setter="setTexture" static="false">
			<doc>Determines the internal texture that the sprite texture references.</doc>
		</property>
		<property name="Width" type="int" getter="getWidth" setter="" static="false">
			<doc>Returns width of the sprite texture in pixels.</doc>
		</property>
		<property name="Height" type="int" getter="getHeight" setter="" static="false">
			<doc>Returns height of the sprite texture in pixels.</doc>
		</property>
		<property name="FrameWidth" type="int" getter="getFrameWidth" setter="" static="false">
			<doc>Returns width of a single animation frame sprite texture in pixels. If the texture has no animation this is the same as getWidth().</doc>
		</property>
		<property name="FrameHeight" type="int" getter="getFrameHeight" setter="" static="false">
			<doc>Returns height of a single animation frame sprite texture in pixels. If the texture has no animation this is the same as getHeight().</doc>
		</property>
		<property name="Offset" type="Vector2" getter="getOffset" setter="setOffset" static="false">
			<doc>Determines the offset into the referenced texture where the sprite starts. The offset is in UV coordinates, in range [0, 1].</doc>
		</property>
		<property name="Scale" type="Vector2" getter="getScale" setter="setScale" static="false">
			<doc>Determines the size of the sprite in the referenced texture. Size is in UV coordinates, range [0, 1].</doc>
		</property>
		<property name="Animation" type="SpriteSheetGridAnimation" getter="getAnimation" setter="setAnimation" static="false">
			<doc>Sets properties describing sprite animation. The animation splits the sprite area into a grid of sub-images which can be evaluated over time. In order to view the animation you must also enable playback through setAnimationPlayback().</doc>
		</property>
		<property name="AnimationPlayback" type="SpriteAnimationPlayback" getter="getAnimationPlayback" setter="setAnimationPlayback" static="false">
			<doc>Determines if and how should the sprite animation play.</doc>
		</property>
	</class>
	<struct native="SubResource" script="SubResource">
		<doc>Contains a resource that was imported from a file that contains multiple resources (for example an animation from an FBX file).</doc>
		<field name="name" type="string">
			<doc>Unique name of the sub-resource.</doc>
		</field>
		<field name="value" type="Resource">
			<doc>Contents of the sub-resource.</doc>
		</field>
	</struct>
	<class native="Importer" script="Importer">
		<doc>Module responsible for importing various asset types and converting them to types usable by the engine.</doc>
		<method native="import" script="Import" static="false">
			<doc>Imports a resource at the specified location, and returns the loaded data. If file contains more than one resource only the primary resource is imported (for example an FBX a mesh would be imported, but animations ignored).</doc>
			<param name="inputFilePath" type="string">
				<doc>Pathname of the input file.</doc>
			</param>
			<param name="importOptions" type="ImportOptions">
				<doc>(optional) Options for controlling the import. Caller must ensure import options actually match the type of the importer used for the file type.</doc>
			</param>
			<param name="UUID" type="UUID">
				<doc>Specific UUID to assign to the resource. If not specified a randomly generated UUID will be assigned.</doc>
			</param>
			<returns type="Resource">
				<doc>Imported resource.</doc>
			</returns>
		</method>
		<method native="importAsync" script="ImportAsync" static="false">
			<doc>Same as import(), except it imports a resource without blocking the main thread. The resulting resource will be placed in the returned AsyncOp object when the import ends.</doc>
			<param name="inputFilePath" type="string">
			</param>
			<param name="importOptions" type="ImportOptions">
			</param>
			<param name="UUID" type="UUID">
			</param>
			<returns type="AsyncOp&lt;RRefBase&gt;">
			</returns>
		</method>
		<method native="importAll" script="ImportAll" static="false">
			<doc>Imports a resource at the specified location, and returns the loaded data. This method returns all imported resources, which is relevant for files that can contain multiple resources (for example an FBX which may contain both a mesh and animations).</doc>
			<param name="inputFilePath" type="string">
				<doc>Pathname of the input file.</doc>
			</param>
			<param name="importOptions" type="ImportOptions">
				<doc>(optional) Options for controlling the import. Caller must ensure import options actually match the type of the importer used for the file type.</doc>
			</param>
			<returns type="MultiResource">
				<doc>A list of all imported resources. The primary resource is always the first returned resource.</doc>
			</returns>
		</method>
		<method native="importAllAsync" script="ImportAllAsync" static="false">
			<doc>Same as importAll(), except it imports a resource without blocking the main thread. The returned AsyncOp will contain a list of the imported resources, after the import ends.</doc>
			<param name="inputFilePath" type="string">
			</param>
			<param name="importOptions" type="ImportOptions">
			</param>
			<returns type="AsyncOp&lt;MultiResource&gt;">
			</returns>
		</method>
		<method native="supportsFileType" script="SupportsFileType" static="false">
			<doc>Checks if we can import a file with the specified extension.</doc>
			<param name="extension" type="string">
				<doc>The extension without the leading dot.</doc>
			</param>
			<returns type="bool">
			</returns>
		</method>
		<method native="import" script="Import" static="false">
			<doc>Imports a resource at the specified location, and returns the loaded data. If file contains more than one resource only the primary resource is imported (for example an FBX a mesh would be imported, but animations ignored).</doc>
			<param name="inputFilePath" type="string">
				<doc>Pathname of the input file.</doc>
			</param>
			<param name="importOptions" type="ImportOptions">
				<doc>(optional) Options for controlling the import. Caller must ensure import options actually match the type of the importer used for the file type.</doc>
			</param>
			<param name="UUID" type="UUID">
			</param>
			<returns type="Resource">
				<doc>Imported resource.</doc>
			</returns>
		</method>
		<method native="import" script="Import" static="false">
			<doc>Imports a resource at the specified location, and returns the loaded data. If file contains more than one resource only the primary resource is imported (for example an FBX a mesh would be imported, but animations ignored).</doc>
			<param name="inputFilePath" type="string">
				<doc>Pathname of the input file.</doc>
			</param>
			<param name="importOptions" type="ImportOptions">
			</param>
			<param name="UUID" type="UUID">
			</param>
			<returns type="Resource">
				<doc>Imported resource.</doc>
			</returns>
		</method>
		<method native="importAsync" script="ImportAsync" static="false">
			<doc>Same as import(), except it imports a resource without blocking the main thread. The resulting resource will be placed in the returned AsyncOp object when the import ends.</doc>
			<param name="inputFilePath" type="string">
			</param>
			<param name="importOptions" type="ImportOptions">
			</param>
			<param name="UUID" type="UUID">
			</param>
			<returns type="AsyncOp&lt;RRefBase&gt;">
			</returns>
		</method>
		<method native="importAsync" script="ImportAsync" static="false">
			<doc>Same as import(), except it imports a resource without blocking the main thread. The resulting resource will be placed in the returned AsyncOp object when the import ends.</doc>
			<param name="inputFilePath" type="string">
			</param>
			<param name="importOptions" type="ImportOptions">
			</param>
			<param name="UUID" type="UUID">
			</param>
			<returns type="AsyncOp&lt;RRefBase&gt;">
			</returns>
		</method>
		<method native="importAll" script="ImportAll" static="false">
			<doc>Imports a resource at the specified location, and returns the loaded data. This method returns all imported resources, which is relevant for files that can contain multiple resources (for example an FBX which may contain both a mesh and animations).</doc>
			<param name="inputFilePath" type="string">
				<doc>Pathname of the input file.</doc>
			</param>
			<param name="importOptions" type="ImportOptions">
			</param>
			<returns type="MultiResource">
				<doc>A list of all imported resources. The primary resource is always the first returned resource.</doc>
			</returns>
		</method>
		<method native="importAllAsync" script="ImportAllAsync" static="false">
			<doc>Same as importAll(), except it imports a resource without blocking the main thread. The returned AsyncOp will contain a list of the imported resources, after the import ends.</doc>
			<param name="inputFilePath" type="string">
			</param>
			<param name="importOptions" type="ImportOptions">
			</param>
			<returns type="AsyncOp&lt;MultiResource&gt;">
			</returns>
		</method>
	</class>
	<enum native="CollisionMeshType" script="CollisionMeshType">
		<doc>Controls what type of collision mesh should be imported during mesh import.</doc>
		<enumentry native="None" script="None">
			<doc>No collision mesh will be imported.</doc>
		</enumentry>
		<enumentry native="Normal" script="Normal">
			<doc>Normal triangle mesh will be imported.</doc>
		</enumentry>
		<enumentry native="Convex" script="Convex">
			<doc>A convex hull will be generated from the source mesh.</doc>
		</enumentry>
	</enum>
	<class native="AnimationSplitInfo" script="AnimationSplitInfo">
		<doc>Information about how to split an AnimationClip into multiple separate clips.</doc>
		<ctor>
		</ctor>
		<ctor>
			<param name="name" type="string">
			</param>
			<param name="startFrame" type="int">
			</param>
			<param name="endFrame" type="int">
			</param>
			<param name="isAdditive" type="bool">
			</param>
		</ctor>
		<property name="Name" type="string" getter="getname" setter="setname" static="false">
		</property>
		<property name="StartFrame" type="int" getter="getstartFrame" setter="setstartFrame" static="false">
		</property>
		<property name="EndFrame" type="int" getter="getendFrame" setter="setendFrame" static="false">
		</property>
		<property name="IsAdditive" type="bool" getter="getisAdditive" setter="setisAdditive" static="false">
		</property>
	</class>
	<class native="MeshImportOptions" script="MeshImportOptions">
		<doc>Contains import options you may use to control how is a mesh imported from some external format into engine format.</doc>
		<ctor>
			<doc>Creates a new import options object that allows you to customize how are meshes imported.</doc>
		</ctor>
		<property name="CpuCached" type="bool" getter="getcpuCached" setter="setcpuCached" static="false">
			<doc>Determines whether the texture data is also stored in CPU memory.</doc>
		</property>
		<property name="ImportNormals" type="bool" getter="getimportNormals" setter="setimportNormals" static="false">
			<doc>Determines should mesh normals be imported if available.</doc>
		</property>
		<property name="ImportTangents" type="bool" getter="getimportTangents" setter="setimportTangents" static="false">
			<doc>Determines should mesh tangents and bitangents be imported if available.</doc>
		</property>
		<property name="ImportBlendShapes" type="bool" getter="getimportBlendShapes" setter="setimportBlendShapes" static="false">
			<doc>Determines should mesh blend shapes be imported if available.</doc>
		</property>
		<property name="ImportSkin" type="bool" getter="getimportSkin" setter="setimportSkin" static="false">
			<doc>Determines should mesh skin data like bone weights, indices and bind poses be imported if available.</doc>
		</property>
		<property name="ImportAnimation" type="bool" getter="getimportAnimation" setter="setimportAnimation" static="false">
			<doc>Determines should animation clips be imported if available.</doc>
		</property>
		<property name="ReduceKeyFrames" type="bool" getter="getreduceKeyFrames" setter="setreduceKeyFrames" static="false">
			<doc>Enables or disables keyframe reduction. Keyframe reduction will reduce the number of key-frames in an animation clip by removing identical keyframes, and therefore reducing the size of the clip.</doc>
		</property>
		<property name="ImportRootMotion" type="bool" getter="getimportRootMotion" setter="setimportRootMotion" static="false">
			<doc>Enables or disables import of root motion curves. When enabled, any animation curves in imported animations affecting the root bone will be available through a set of separate curves in AnimationClip, and they won&apos;t be evaluated through normal animation process. Instead it is expected that the user evaluates the curves manually and applies them as required.</doc>
		</property>
		<property name="ImportScale" type="float" getter="getimportScale" setter="setimportScale" static="false">
			<doc>Uniformly scales the imported mesh by the specified value.</doc>
		</property>
		<property name="CollisionMeshType" type="CollisionMeshType" getter="getcollisionMeshType" setter="setcollisionMeshType" static="false">
			<doc>Determines what type (if any) of collision mesh should be imported. If enabled the collision mesh will be available as a sub-resource returned by the importer (along with the normal mesh).</doc>
		</property>
		<property name="AnimationSplits" type="AnimationSplitInfo" getter="getanimationSplits" setter="setanimationSplits" static="false">
			<doc>Animation split infos that determine how will the source animation clip be split. If no splits are present the data will be imported as one clip, but if splits are present the data will be split according to the split infos. Split infos only affect the primary animation clip, other clips will not be split.</doc>
		</property>
		<property name="AnimationEvents" type="ImportedAnimationEvents" getter="getanimationEvents" setter="setanimationEvents" static="false">
			<doc>Set of events that will be added to the animation clip, if animation import is enabled.</doc>
		</property>
	</class>
	<enum native="ShadingLanguageFlag" script="ShadingLanguageFlags">
		<doc>Supported types of low-level shading languages.</doc>
		<enumentry native="HLSL" script="HLSL">
			<doc>High level shading language used by DirectX backend.</doc>
		</enumentry>
		<enumentry native="GLSL" script="GLSL">
			<doc>OpenGL shading language.</doc>
		</enumentry>
		<enumentry native="VKSL" script="VKSL">
			<doc>Variant of GLSL used for Vulkan.</doc>
		</enumentry>
		<enumentry native="MSL" script="MSL">
			<doc>Metal shading language.</doc>
		</enumentry>
		<enumentry native="All" script="All">
			<doc>Helper entry that includes all languages.</doc>
		</enumentry>
	</enum>
	<class native="ResourceManifest" script="ResourceManifest">
		<doc>Serializable class that contains UUID &lt;-&gt; file path mapping for resources.</doc>
		<method native="registerResource" script="RegisterResource" static="false">
			<doc>Registers a new resource in the manifest.</doc>
			<param name="uuid" type="UUID">
			</param>
			<param name="filePath" type="string">
			</param>
		</method>
		<method native="unregisterResource" script="UnregisterResource" static="false">
			<doc>Removes a resource from the manifest.</doc>
			<param name="uuid" type="UUID">
			</param>
		</method>
		<method native="uuidToFilePath" script="UuidToFilePath" static="false">
			<doc>Attempts to find a resource with the provided UUID and outputs the path to the resource if found. Returns true if UUID was found, false otherwise.</doc>
			<param name="uuid" type="UUID">
			</param>
			<param name="filePath" type="string">
			</param>
			<returns type="bool">
			</returns>
		</method>
		<method native="filePathToUUID" script="FilePathToUUID" static="false">
			<doc>Attempts to find a resource with the provided path and outputs the UUID to the resource if found. Returns true if path was found, false otherwise.</doc>
			<param name="filePath" type="string">
			</param>
			<param name="outUUID" type="UUID">
			</param>
			<returns type="bool">
			</returns>
		</method>
		<method native="uuidExists" script="UuidExists" static="false">
			<doc>Checks if provided UUID exists in the manifest.</doc>
			<param name="uuid" type="UUID">
			</param>
			<returns type="bool">
			</returns>
		</method>
		<method native="filePathExists" script="FilePathExists" static="false">
			<doc>Checks if the provided path exists in the manifest.</doc>
			<param name="filePath" type="string">
			</param>
			<returns type="bool">
			</returns>
		</method>
		<method native="save" script="Save" static="true">
			<doc>Saves the resource manifest to the specified location.</doc>
			<param name="manifest" type="ResourceManifest">
				<doc>Manifest to save.</doc>
			</param>
			<param name="path" type="string">
				<doc>Full pathname of the file to save the manifest in.</doc>
			</param>
			<param name="relativePath" type="string">
				<doc>If not empty, all pathnames in the manifest will be stored as if relative to this path.</doc>
			</param>
		</method>
		<method native="load" script="Load" static="true">
			<doc>Loads the resource manifest from the specified location.</doc>
			<param name="path" type="string">
				<doc>Full pathname of the file to load the manifest from.</doc>
			</param>
			<param name="relativePath" type="string">
				<doc>If not empty, all loaded pathnames will have this path prepended.</doc>
			</param>
			<returns type="ResourceManifest">
			</returns>
		</method>
		<ctor>
			<doc>Creates a new empty resource manifest. Provided name should be unique among manifests.</doc>
			<param name="name" type="string">
			</param>
		</ctor>
		<property name="Name" type="string" getter="getName" setter="" static="false">
			<doc>Returns an unique name of the resource manifest.</doc>
		</property>
	</class>
	<class native="TextureImportOptions" script="TextureImportOptions">
		<doc>Contains import options you may use to control how is a texture imported.</doc>
		<ctor>
			<doc>Creates a new import options object that allows you to customize how are textures imported.</doc>
		</ctor>
		<property name="Format" type="PixelFormat" getter="getformat" setter="setformat" static="false">
			<doc>Pixel format to import as.</doc>
		</property>
		<property name="GenerateMips" type="bool" getter="getgenerateMips" setter="setgenerateMips" static="false">
			<doc>Enables or disables mipmap generation for the texture.</doc>
		</property>
		<property name="MaxMip" type="int" getter="getmaxMip" setter="setmaxMip" static="false">
			<doc>Maximum mip level to generate when generating mipmaps. If 0 then maximum amount of mip levels will be generated.</doc>
		</property>
		<property name="CpuCached" type="bool" getter="getcpuCached" setter="setcpuCached" static="false">
			<doc>Determines whether the texture data is also stored in main memory, available for fast CPU access.</doc>
		</property>
		<property name="SRGB" type="bool" getter="getsRGB" setter="setsRGB" static="false">
			<doc>Determines whether the texture data should be treated as if its in sRGB (gamma) space. Such texture will be converted by hardware to linear space before use on the GPU.</doc>
		</property>
		<property name="Cubemap" type="bool" getter="getcubemap" setter="setcubemap" static="false">
			<doc>Determines should the texture be imported as a cubemap. See setCubemapSource to choose how will the source texture be converted to a cubemap.</doc>
		</property>
		<property name="CubemapSourceType" type="CubemapSourceType" getter="getcubemapSourceType" setter="setcubemapSourceType" static="false">
			<doc>Determines how should the source texture be interpreted when generating a cubemap. Only relevant when <see cref="cubemap"/> is set to true.</doc>
		</property>
	</class>
	<enum native="Language" script="Language">
		<doc>A set of all languages that localized strings can be translated to. Loosely based on ISO 639-1 two letter language codes.</doc>
		<enumentry native="Assamese" script="Assamese">
		</enumentry>
		<enumentry native="Herero" script="Herero">
		</enumentry>
		<enumentry native="Afar" script="Afar">
		</enumentry>
		<enumentry native="Abkhazian" script="Abkhazian">
		</enumentry>
		<enumentry native="Avestan" script="Avestan">
		</enumentry>
		<enumentry native="Afrikaans" script="Afrikaans">
		</enumentry>
		<enumentry native="Akan" script="Akan">
		</enumentry>
		<enumentry native="Amharic" script="Amharic">
		</enumentry>
		<enumentry native="Aragonese" script="Aragonese">
		</enumentry>
		<enumentry native="Arabic" script="Arabic">
		</enumentry>
		<enumentry native="Avaric" script="Avaric">
		</enumentry>
		<enumentry native="Aymara" script="Aymara">
		</enumentry>
		<enumentry native="Azerbaijani" script="Azerbaijani">
		</enumentry>
		<enumentry native="Bashkir" script="Bashkir">
		</enumentry>
		<enumentry native="Belarusian" script="Belarusian">
		</enumentry>
		<enumentry native="Bulgarian" script="Bulgarian">
		</enumentry>
		<enumentry native="Bihari" script="Bihari">
		</enumentry>
		<enumentry native="Bislama" script="Bislama">
		</enumentry>
		<enumentry native="Bambara" script="Bambara">
		</enumentry>
		<enumentry native="Bengali" script="Bengali">
		</enumentry>
		<enumentry native="Tibetan" script="Tibetan">
		</enumentry>
		<enumentry native="Breton" script="Breton">
		</enumentry>
		<enumentry native="Bosnian" script="Bosnian">
		</enumentry>
		<enumentry native="Catalan" script="Catalan">
		</enumentry>
		<enumentry native="Chechen" script="Chechen">
		</enumentry>
		<enumentry native="Chamorro" script="Chamorro">
		</enumentry>
		<enumentry native="Corsican" script="Corsican">
		</enumentry>
		<enumentry native="Cree" script="Cree">
		</enumentry>
		<enumentry native="Czech" script="Czech">
		</enumentry>
		<enumentry native="ChurchSlavic" script="ChurchSlavic">
		</enumentry>
		<enumentry native="Chuvash" script="Chuvash">
		</enumentry>
		<enumentry native="Welsh" script="Welsh">
		</enumentry>
		<enumentry native="Danish" script="Danish">
		</enumentry>
		<enumentry native="German" script="German">
		</enumentry>
		<enumentry native="Maldivian" script="Maldivian">
		</enumentry>
		<enumentry native="Bhutani" script="Bhutani">
		</enumentry>
		<enumentry native="Ewe" script="Ewe">
		</enumentry>
		<enumentry native="Greek" script="Greek">
		</enumentry>
		<enumentry native="EnglishUK" script="EnglishUK">
		</enumentry>
		<enumentry native="EnglishUS" script="EnglishUS">
		</enumentry>
		<enumentry native="Esperanto" script="Esperanto">
		</enumentry>
		<enumentry native="Spanish" script="Spanish">
		</enumentry>
		<enumentry native="Estonian" script="Estonian">
		</enumentry>
		<enumentry native="Basque" script="Basque">
		</enumentry>
		<enumentry native="Persian" script="Persian">
		</enumentry>
		<enumentry native="Fulah" script="Fulah">
		</enumentry>
		<enumentry native="Finnish" script="Finnish">
		</enumentry>
		<enumentry native="Fijian" script="Fijian">
		</enumentry>
		<enumentry native="Faroese" script="Faroese">
		</enumentry>
		<enumentry native="French" script="French">
		</enumentry>
		<enumentry native="WesternFrisian" script="WesternFrisian">
		</enumentry>
		<enumentry native="Irish" script="Irish">
		</enumentry>
		<enumentry native="ScottishGaelic" script="ScottishGaelic">
		</enumentry>
		<enumentry native="Galician" script="Galician">
		</enumentry>
		<enumentry native="Guarani" script="Guarani">
		</enumentry>
		<enumentry native="Gujarati" script="Gujarati">
		</enumentry>
		<enumentry native="Manx" script="Manx">
		</enumentry>
		<enumentry native="Hausa" script="Hausa">
		</enumentry>
		<enumentry native="Hebrew" script="Hebrew">
		</enumentry>
		<enumentry native="Hindi" script="Hindi">
		</enumentry>
		<enumentry native="HiriMotu" script="HiriMotu">
		</enumentry>
		<enumentry native="Croatian" script="Croatian">
		</enumentry>
		<enumentry native="Haitian" script="Haitian">
		</enumentry>
		<enumentry native="Hungarian" script="Hungarian">
		</enumentry>
		<enumentry native="Armenian" script="Armenian">
		</enumentry>
		<enumentry native="Interlingua" script="Interlingua">
		</enumentry>
		<enumentry native="Indonesian" script="Indonesian">
		</enumentry>
		<enumentry native="Interlingue" script="Interlingue">
		</enumentry>
		<enumentry native="Igbo" script="Igbo">
		</enumentry>
		<enumentry native="SichuanYi" script="SichuanYi">
		</enumentry>
		<enumentry native="Inupiak" script="Inupiak">
		</enumentry>
		<enumentry native="Ido" script="Ido">
		</enumentry>
		<enumentry native="Icelandic" script="Icelandic">
		</enumentry>
		<enumentry native="Italian" script="Italian">
		</enumentry>
		<enumentry native="Inuktitut" script="Inuktitut">
		</enumentry>
		<enumentry native="Japanese" script="Japanese">
		</enumentry>
		<enumentry native="Javanese" script="Javanese">
		</enumentry>
		<enumentry native="Georgian" script="Georgian">
		</enumentry>
		<enumentry native="Kongo" script="Kongo">
		</enumentry>
		<enumentry native="Kikuyu" script="Kikuyu">
		</enumentry>
		<enumentry native="Kuanyama" script="Kuanyama">
		</enumentry>
		<enumentry native="Kazakh" script="Kazakh">
		</enumentry>
		<enumentry native="Kalaallisut" script="Kalaallisut">
		</enumentry>
		<enumentry native="Cambodian" script="Cambodian">
		</enumentry>
		<enumentry native="Kannada" script="Kannada">
		</enumentry>
		<enumentry native="Korean" script="Korean">
		</enumentry>
		<enumentry native="Kanuri" script="Kanuri">
		</enumentry>
		<enumentry native="Kashmiri" script="Kashmiri">
		</enumentry>
		<enumentry native="Kurdish" script="Kurdish">
		</enumentry>
		<enumentry native="Komi" script="Komi">
		</enumentry>
		<enumentry native="Cornish" script="Cornish">
		</enumentry>
		<enumentry native="Kirghiz" script="Kirghiz">
		</enumentry>
		<enumentry native="Latin" script="Latin">
		</enumentry>
		<enumentry native="Luxembourgish" script="Luxembourgish">
		</enumentry>
		<enumentry native="Ganda" script="Ganda">
		</enumentry>
		<enumentry native="Limburgish" script="Limburgish">
		</enumentry>
		<enumentry native="Lingala" script="Lingala">
		</enumentry>
		<enumentry native="Laotian" script="Laotian">
		</enumentry>
		<enumentry native="Lithuanian" script="Lithuanian">
		</enumentry>
		<enumentry native="LubaKatanga" script="LubaKatanga">
		</enumentry>
		<enumentry native="Latvian" script="Latvian">
		</enumentry>
		<enumentry native="Malagasy" script="Malagasy">
		</enumentry>
		<enumentry native="Marshallese" script="Marshallese">
		</enumentry>
		<enumentry native="Maori" script="Maori">
		</enumentry>
		<enumentry native="Macedonian" script="Macedonian">
		</enumentry>
		<enumentry native="Malayalam" script="Malayalam">
		</enumentry>
		<enumentry native="Mongolian" script="Mongolian">
		</enumentry>
		<enumentry native="Moldavian" script="Moldavian">
		</enumentry>
		<enumentry native="Marathi" script="Marathi">
		</enumentry>
		<enumentry native="Malay" script="Malay">
		</enumentry>
		<enumentry native="Maltese" script="Maltese">
		</enumentry>
		<enumentry native="Burmese" script="Burmese">
		</enumentry>
		<enumentry native="Nauru" script="Nauru">
		</enumentry>
		<enumentry native="NorwegianBokmal" script="NorwegianBokmal">
		</enumentry>
		<enumentry native="Ndebele" script="Ndebele">
		</enumentry>
		<enumentry native="Nepali" script="Nepali">
		</enumentry>
		<enumentry native="Ndonga" script="Ndonga">
		</enumentry>
		<enumentry native="Dutch" script="Dutch">
		</enumentry>
		<enumentry native="NorwegianNynorsk" script="NorwegianNynorsk">
		</enumentry>
		<enumentry native="Norwegian" script="Norwegian">
		</enumentry>
		<enumentry native="Navaho" script="Navaho">
		</enumentry>
		<enumentry native="Nyanja" script="Nyanja">
		</enumentry>
		<enumentry native="Provencal" script="Provencal">
		</enumentry>
		<enumentry native="Ojibwa" script="Ojibwa">
		</enumentry>
		<enumentry native="Oromo" script="Oromo">
		</enumentry>
		<enumentry native="Oriya" script="Oriya">
		</enumentry>
		<enumentry native="Ossetic" script="Ossetic">
		</enumentry>
		<enumentry native="Punjabi" script="Punjabi">
		</enumentry>
		<enumentry native="Pali" script="Pali">
		</enumentry>
		<enumentry native="Polish" script="Polish">
		</enumentry>
		<enumentry native="Pushto" script="Pushto">
		</enumentry>
		<enumentry native="Portuguese" script="Portuguese">
		</enumentry>
		<enumentry native="Quechua" script="Quechua">
		</enumentry>
		<enumentry native="Romansh" script="Romansh">
		</enumentry>
		<enumentry native="Kirundi" script="Kirundi">
		</enumentry>
		<enumentry native="Romanian" script="Romanian">
		</enumentry>
		<enumentry native="Russian" script="Russian">
		</enumentry>
		<enumentry native="Kinyarwanda" script="Kinyarwanda">
		</enumentry>
		<enumentry native="Sanskrit" script="Sanskrit">
		</enumentry>
		<enumentry native="Sardinian" script="Sardinian">
		</enumentry>
		<enumentry native="Sindhi" script="Sindhi">
		</enumentry>
		<enumentry native="NorthernSami" script="NorthernSami">
		</enumentry>
		<enumentry native="Sangro" script="Sangro">
		</enumentry>
		<enumentry native="Sinhalese" script="Sinhalese">
		</enumentry>
		<enumentry native="Slovak" script="Slovak">
		</enumentry>
		<enumentry native="Slovenian" script="Slovenian">
		</enumentry>
		<enumentry native="Samoan" script="Samoan">
		</enumentry>
		<enumentry native="Shona" script="Shona">
		</enumentry>
		<enumentry native="Somali" script="Somali">
		</enumentry>
		<enumentry native="Albanian" script="Albanian">
		</enumentry>
		<enumentry native="Serbian" script="Serbian">
		</enumentry>
		<enumentry native="Swati" script="Swati">
		</enumentry>
		<enumentry native="Sesotho" script="Sesotho">
		</enumentry>
		<enumentry native="Sundanese" script="Sundanese">
		</enumentry>
		<enumentry native="Swedish" script="Swedish">
		</enumentry>
		<enumentry native="Swahili" script="Swahili">
		</enumentry>
		<enumentry native="Tamil" script="Tamil">
		</enumentry>
		<enumentry native="Telugu" script="Telugu">
		</enumentry>
		<enumentry native="Tajik" script="Tajik">
		</enumentry>
		<enumentry native="Thai" script="Thai">
		</enumentry>
		<enumentry native="Tigrinya" script="Tigrinya">
		</enumentry>
		<enumentry native="Turkmen" script="Turkmen">
		</enumentry>
		<enumentry native="Tagalog" script="Tagalog">
		</enumentry>
		<enumentry native="Setswana" script="Setswana">
		</enumentry>
		<enumentry native="Tonga" script="Tonga">
		</enumentry>
		<enumentry native="Turkish" script="Turkish">
		</enumentry>
		<enumentry native="Tsonga" script="Tsonga">
		</enumentry>
		<enumentry native="Tatar" script="Tatar">
		</enumentry>
		<enumentry native="Twi" script="Twi">
		</enumentry>
		<enumentry native="Tahitian" script="Tahitian">
		</enumentry>
		<enumentry native="Uighur" script="Uighur">
		</enumentry>
		<enumentry native="Ukrainian" script="Ukrainian">
		</enumentry>
		<enumentry native="Urdu" script="Urdu">
		</enumentry>
		<enumentry native="Uzbek" script="Uzbek">
		</enumentry>
		<enumentry native="Venda" script="Venda">
		</enumentry>
		<enumentry native="Vietnamese" script="Vietnamese">
		</enumentry>
		<enumentry native="Volapuk" script="Volapuk">
		</enumentry>
		<enumentry native="Walloon" script="Walloon">
		</enumentry>
		<enumentry native="Wolof" script="Wolof">
		</enumentry>
		<enumentry native="Xhosa" script="Xhosa">
		</enumentry>
		<enumentry native="Yiddish" script="Yiddish">
		</enumentry>
		<enumentry native="Yoruba" script="Yoruba">
		</enumentry>
		<enumentry native="Zhuang" script="Zhuang">
		</enumentry>
		<enumentry native="Chinese" script="Chinese">
		</enumentry>
		<enumentry native="Zulu" script="Zulu">
		</enumentry>
		<enumentry native="Count" script="Count">
		</enumentry>
	</enum>
	<class native="StringTable" script="StringTable">
		<doc>Used for string localization. Stores strings and their translations in various languages.</doc>
		<method native="contains" script="Contains" static="false">
			<doc>Checks does the string table contain the provided identifier.</doc>
			<param name="identifier" type="string">
				<doc>Identifier to look for.</doc>
			</param>
			<returns type="bool">
				<doc>True if the identifier exists in the table, false otherwise.</doc>
			</returns>
		</method>
		<method native="setString" script="SetString" static="false">
			<doc>Adds or modifies string translation for the specified language.</doc>
			<param name="identifier" type="string">
			</param>
			<param name="language" type="Language">
			</param>
			<param name="value" type="string">
			</param>
		</method>
		<method native="getString" script="GetString" static="false">
			<doc>Returns a string translation for the specified language. Returns the identifier itself if one doesn&apos;t exist.</doc>
			<param name="identifier" type="string">
			</param>
			<param name="language" type="Language">
			</param>
			<returns type="string">
			</returns>
		</method>
		<method native="removeString" script="RemoveString" static="false">
			<doc>Removes the string described by identifier, from all languages.</doc>
			<param name="identifier" type="string">
			</param>
		</method>
		<ctor>
			<doc>Creates a new empty string table resource.</doc>
		</ctor>
		<property name="NumStrings" type="int" getter="getNumStrings" setter="" static="false">
			<doc>Returns a total number of strings in the table.</doc>
		</property>
		<property name="Identifiers" type="string" getter="getIdentifiers" setter="" static="false">
			<doc>Returns all identifiers that the string table contains localized strings for.</doc>
		</property>
	</class>
	<class native="StringTableManager" script="StringTables">
		<doc>Manages string tables used for localizing text. Allows you to add and remove different tables and change the active language.</doc>
		<method native="getTable" script="GetTable" static="false">
			<doc>Returns the string table with the specified id. If the table doesn&apos;t exist new one is created.</doc>
			<param name="id" type="int">
				<doc>Identifier of the string table.</doc>
			</param>
			<returns type="RRef&lt;StringTable&gt;">
				<doc>String table with the specified identifier.</doc>
			</returns>
		</method>
		<method native="removeTable" script="RemoveTable" static="false">
			<doc>Removes the string table with the specified id.</doc>
			<param name="id" type="int">
				<doc>Identifier of the string table.</doc>
			</param>
		</method>
		<method native="setTable" script="SetTable" static="false">
			<doc>Registers a new string table or replaces an old one at the specified id.</doc>
			<param name="id" type="int">
				<doc>Identifier of the string table.</doc>
			</param>
			<param name="table" type="RRef&lt;StringTable&gt;">
				<doc>New string table to assign to the specified identifier.</doc>
			</param>
		</method>
		<property name="ActiveLanguage" type="Language" getter="getActiveLanguage" setter="setActiveLanguage" static="false">
			<doc>Determines the currently active language. Any newly created strings will use this value.</doc>
		</property>
	</class>
	<enum native="MeshUsage" script="MeshUsage">
		<doc>Planned usage for the mesh. These options usually affect performance and you should specify static if you don&apos;t plan on modifying the mesh often, otherwise specify dynamic.</doc>
		<enumentry native="MU_STATIC" script="Static">
			<doc>Specify for a mesh that is not often updated from the CPU.</doc>
		</enumentry>
		<enumentry native="MU_DYNAMIC" script="Dynamic">
			<doc>Specify for a mesh that is often updated from the CPU.</doc>
		</enumentry>
		<enumentry native="MU_CPUCACHED" script="CPUCached">
			<doc>All mesh data will also be cached in CPU memory, making it available for fast read access from the CPU. Can be combined with other usage flags.</doc>
		</enumentry>
	</enum>
	<class native="ShaderVariation" script="ShaderVariation">
		<doc>Contains information about a single variation of a Shader. Each variation can have a separate set of #defines that control shader compilation.</doc>
		<ctor>
		</ctor>
		<method native="getInt" script="GetInt" static="false">
			<doc>Returns the value of a signed integer parameter with the specified name. Returns 0 if the parameter cannot be found.</doc>
			<param name="name" type="string">
			</param>
			<returns type="int">
			</returns>
		</method>
		<method native="getUInt" script="GetUInt" static="false">
			<doc>Returns the value of a unsigned integer parameter with the specified name. Returns 0 if the parameter cannot be found.</doc>
			<param name="name" type="string">
			</param>
			<returns type="int">
			</returns>
		</method>
		<method native="getFloat" script="GetFloat" static="false">
			<doc>Returns the value of a float parameter with the specified name. Returns 0 if the parameter cannot be found.</doc>
			<param name="name" type="string">
			</param>
			<returns type="float">
			</returns>
		</method>
		<method native="getBool" script="GetBool" static="false">
			<doc>Returns the value of a boolean parameter with the specified name. Returns false if the parameter cannot be found.</doc>
			<param name="name" type="string">
			</param>
			<returns type="bool">
			</returns>
		</method>
		<method native="setInt" script="SetInt" static="false">
			<doc>Sets the value of the parameter for the provided name. Any previous value for a parameter with the same name will be overwritten.</doc>
			<param name="name" type="string">
			</param>
			<param name="value" type="int">
			</param>
		</method>
		<method native="setUInt" script="SetUInt" static="false">
			<doc>Sets the value of the parameter for the provided name. Any previous value for a parameter with the same name will be overwritten.</doc>
			<param name="name" type="string">
			</param>
			<param name="value" type="int">
			</param>
		</method>
		<method native="setFloat" script="SetFloat" static="false">
			<doc>Sets the value of the parameter for the provided name. Any previous value for a parameter with the same name will be overwritten.</doc>
			<param name="name" type="string">
			</param>
			<param name="value" type="float">
			</param>
		</method>
		<method native="setBool" script="SetBool" static="false">
			<doc>Sets the value of the parameter for the provided name. Any previous value for a parameter with the same name will be overwritten.</doc>
			<param name="name" type="string">
			</param>
			<param name="value" type="bool">
			</param>
		</method>
		<method native="removeParam" script="RemoveParam" static="false">
			<doc>Removes a parameter with the specified name.</doc>
			<param name="paramName" type="string">
			</param>
		</method>
		<method native="hasParam" script="HasParam" static="false">
			<doc>Checks if the variation has a parameter with the specified name.</doc>
			<param name="paramName" type="string">
			</param>
			<returns type="bool">
			</returns>
		</method>
		<method native="clearParams" script="ClearParams" static="false">
			<doc>Removes all parameters.</doc>
		</method>
		<property name="ParamNames" type="string" getter="getParamNames" setter="" static="false">
			<doc>Returns a list of names of all registered parameters.</doc>
		</property>
	</class>
	<class native="Material" script="Material">
		<doc>Material that controls how objects are rendered. It is represented by a shader and parameters used to set up that shader. It provides a simple interface for manipulating the parameters.</doc>
		<method native="clone" script="Clone" static="false">
			<doc>Creates a deep copy of the material and returns the new object.</doc>
			<returns type="RRef&lt;Material&gt;">
			</returns>
		</method>
		<method native="setFloat" script="SetFloat" static="false">
			<doc>Assigns a float value to the shader parameter with the specified name.
Optionally if the parameter is an array you may provide an array index to assign the value to.</doc>
			<param name="name" type="string">
			</param>
			<param name="value" type="float">
			</param>
			<param name="arrayIdx" type="int">
			</param>
		</method>
		<method native="setFloatCurve" script="SetFloatCurve" static="false">
			<param name="name" type="string">
			</param>
			<param name="value" type="AnimationCurve">
			</param>
			<param name="arrayIdx" type="int">
			</param>
		</method>
		<method native="setColor" script="SetColor" static="false">
			<doc>Assigns a color to the shader parameter with the specified name.
Optionally if the parameter is an array you may provide an array index to assign the value to.</doc>
			<param name="name" type="string">
			</param>
			<param name="value" type="Color">
			</param>
			<param name="arrayIdx" type="int">
			</param>
		</method>
		<method native="setColorGradient" script="SetColorGradient" static="false">
			<doc>Assigns a color gradient to the shader parameter with the specified name. The system will automatically evaluate the gradient with the passage of time and apply the evaluated value to the parameter.
Optionally if the parameter is an array you may provide an array index to assign the value to.</doc>
			<param name="name" type="string">
			</param>
			<param name="value" type="ColorGradientHDR">
			</param>
			<param name="arrayIdx" type="int">
			</param>
		</method>
		<method native="setVec2" script="SetVector2" static="false">
			<doc>Assigns a 2D vector to the shader parameter with the specified name.
Optionally if the parameter is an array you may provide an array index to assign the value to.</doc>
			<param name="name" type="string">
			</param>
			<param name="value" type="Vector2">
			</param>
			<param name="arrayIdx" type="int">
			</param>
		</method>
		<method native="setVec3" script="SetVector3" static="false">
			<doc>Assigns a 3D vector to the shader parameter with the specified name.
Optionally if the parameter is an array you may provide an array index to assign the value to.</doc>
			<param name="name" type="string">
			</param>
			<param name="value" type="Vector3">
			</param>
			<param name="arrayIdx" type="int">
			</param>
		</method>
		<method native="setVec4" script="SetVector4" static="false">
			<doc>Assigns a 4D vector to the shader parameter with the specified name.
Optionally if the parameter is an array you may provide an array index to assign the value to.</doc>
			<param name="name" type="string">
			</param>
			<param name="value" type="Vector4">
			</param>
			<param name="arrayIdx" type="int">
			</param>
		</method>
		<method native="setMat3" script="SetMatrix3" static="false">
			<doc>Assigns a 3x3 matrix to the shader parameter with the specified name.
Optionally if the parameter is an array you may provide an array index to assign the value to.</doc>
			<param name="name" type="string">
			</param>
			<param name="value" type="Matrix3">
			</param>
			<param name="arrayIdx" type="int">
			</param>
		</method>
		<method native="setMat4" script="SetMatrix4" static="false">
			<doc>Assigns a 4x4 matrix to the shader parameter with the specified name.
Optionally if the parameter is an array you may provide an array index to assign the value to.</doc>
			<param name="name" type="string">
			</param>
			<param name="value" type="Matrix4">
			</param>
			<param name="arrayIdx" type="int">
			</param>
		</method>
		<method native="getFloat" script="GetFloat" static="false">
			<doc>Returns a float value assigned with the parameter with the specified name. If a curve is assigned to this parameter, returns the curve value evaluated at time 0. Use getBoundParamType() to determine the type of the parameter.
Optionally if the parameter is an array you may provide an array index you which to retrieve.</doc>
			<param name="name" type="string">
			</param>
			<param name="arrayIdx" type="int">
			</param>
			<returns type="float">
			</returns>
		</method>
		<method native="getFloatCurve" script="GetFloatCurve" static="false">
			<doc>Returns a curve value assigned to the parameter with the specified name. If the parameter has a constant value bound instead of a curve then this method returns an empty curve. Use getBoundParamType() to determine the type of the parameter.
Optionally if the parameter is an array you may provide an array index you which to retrieve.</doc>
			<param name="name" type="string">
			</param>
			<param name="arrayIdx" type="int">
			</param>
			<returns type="AnimationCurve">
			</returns>
		</method>
		<method native="getColor" script="GetColor" static="false">
			<doc>Returns a color assigned with the parameter with the specified name. If a color gradient is assigned to this parameter, returns the gradient color evaluated at time 0. Use getBoundParamType() to determine the type of the parameter.
Optionally if the parameter is an array you may provide an array index you which to retrieve.</doc>
			<param name="name" type="string">
			</param>
			<param name="arrayIdx" type="int">
			</param>
			<returns type="Color">
			</returns>
		</method>
		<method native="getColorGradient" script="GetColorGradient" static="false">
			<doc>Returns a color gradient assigned with the parameter with the specified name. If the parameter has a constant value bound instead of a gradient then this method returns an empty gradient. Use getBoundParamType() to determine the type of the parameter.
Optionally if the parameter is an array you may provide an array index you which to retrieve.</doc>
			<param name="name" type="string">
			</param>
			<param name="arrayIdx" type="int">
			</param>
			<returns type="ColorGradientHDR">
			</returns>
		</method>
		<method native="getVec2" script="GetVector2" static="false">
			<doc>Returns a 2D vector assigned with the parameter with the specified name.
Optionally if the parameter is an array you may provide an array index you which to retrieve.</doc>
			<param name="name" type="string">
			</param>
			<param name="arrayIdx" type="int">
			</param>
			<returns type="Vector2">
			</returns>
		</method>
		<method native="getVec3" script="GetVector3" static="false">
			<doc>Returns a 3D vector assigned with the parameter with the specified name.
Optionally if the parameter is an array you may provide an array index you which to retrieve.</doc>
			<param name="name" type="string">
			</param>
			<param name="arrayIdx" type="int">
			</param>
			<returns type="Vector3">
			</returns>
		</method>
		<method native="getVec4" script="GetVector4" static="false">
			<doc>Returns a 4D vector assigned with the parameter with the specified name.
Optionally if the parameter is an array you may provide an array index you which to retrieve.</doc>
			<param name="name" type="string">
			</param>
			<param name="arrayIdx" type="int">
			</param>
			<returns type="Vector4">
			</returns>
		</method>
		<method native="getMat3" script="GetMatrix3" static="false">
			<doc>Returns a 3x3 matrix assigned with the parameter with the specified name.
Optionally if the parameter is an array you may provide an array index you which to retrieve.</doc>
			<param name="name" type="string">
			</param>
			<param name="arrayIdx" type="int">
			</param>
			<returns type="Matrix3">
			</returns>
		</method>
		<method native="getMat4" script="GetMatrix4" static="false">
			<doc>Returns a 4x4 matrix assigned with the parameter with the specified name.
Optionally if the parameter is an array you may provide an array index you which to retrieve.</doc>
			<param name="name" type="string">
			</param>
			<param name="arrayIdx" type="int">
			</param>
			<returns type="Matrix4">
			</returns>
		</method>
		<method native="isAnimated" script="IsAnimated" static="false">
			<doc>Checks does the data parameter with the specified name currently contains animated data. This could be an animation curve or a color gradient.</doc>
			<param name="name" type="string">
			</param>
			<param name="arrayIdx" type="int">
			</param>
			<returns type="bool">
			</returns>
		</method>
		<ctor>
			<doc>Creates a new empty material.</doc>
		</ctor>
		<ctor>
			<doc>Creates a new material with the specified shader.</doc>
			<param name="shader" type="RRef&lt;Shader&gt;">
			</param>
		</ctor>
		<property name="Shader" type="RRef&lt;Shader&gt;" getter="getShader" setter="setShader" static="false">
			<doc>Sets a shader that will be used by the material. Material will be initialized using all compatible techniques from the shader. Shader must be set before doing any other operations with the material.</doc>
		</property>
		<property name="Variation" type="ShaderVariation" getter="getVariation" setter="setVariation" static="false">
			<doc>Set of parameters that determine which subset of techniques in the assigned shader should be used. Only the techniques that have the provided parameters with the provided values will match. This will control which technique is considered the default technique and which subset of techniques are searched during a call to findTechnique().</doc>
		</property>
	</class>
	<struct native="ShaderVariationParamValue" script="ShaderVariationParamValue">
		<doc>Represents a single potential value of a shader variation parameter and optionally its name.</doc>
		<ctor>
		</ctor>
		<field name="name" type="string">
			<doc>Optional human-readable name describing what this particular value represents.</doc>
		</field>
		<field name="value" type="int">
			<doc>Integer value of the parameter.</doc>
		</field>
	</struct>
	<struct native="ShaderVariationParamInfo" script="ShaderVariationParamInfo">
		<doc>Represents a single shader variation parameter and a set of all possible values.</doc>
		<ctor>
		</ctor>
		<field name="name" type="string">
			<doc>Optional human-readable name describing the variation parameter.</doc>
		</field>
		<field name="identifier" type="string">
			<doc>BSL identifier for the parameter.</doc>
		</field>
		<field name="isInternal" type="bool">
			<doc>True if the parameter is for internal use by the renderer, and false if its intended to be set by the user.</doc>
		</field>
		<field name="values" type="ShaderVariationParamValue">
			<doc>A list of potential values this parameter can take on.</doc>
		</field>
	</struct>
	<class native="Physics" script="Physics">
		<doc>Provides global physics settings, factory methods for physics objects and scene queries.</doc>
		<method native="toggleCollision" script="ToggleCollision" static="false">
			<doc>Enables or disables collision between two layers. Each physics object can be assigned a specific layer, and here you can determine which layers can interact with each other.</doc>
			<param name="groupA" type="ulong">
			</param>
			<param name="groupB" type="ulong">
			</param>
			<param name="enabled" type="bool">
			</param>
		</method>
		<method native="isCollisionEnabled" script="IsCollisionEnabled" static="false">
			<doc>Checks if two collision layers are allowed to interact.</doc>
			<param name="groupA" type="ulong">
			</param>
			<param name="groupB" type="ulong">
			</param>
			<returns type="bool">
			</returns>
		</method>
		<property name="IsUpdateInProgress" type="bool" getter="_isUpdateInProgress" setter="" static="false">
			<doc>Checks is the physics simulation update currently in progress.</doc>
		</property>
	</class>
	<class native="PhysicsScene" script="PhysicsScene">
		<doc>Physical representation of a scene, allowing creation of new physical objects in the scene and queries against those objects. Objects created in different scenes cannot physically interact with eachother.</doc>
		<method native="rayCast" script="RayCast" static="false">
			<doc>Casts a ray into the scene and returns the closest found hit, if any.</doc>
			<param name="ray" type="Ray">
				<doc>Ray to cast into the scene.</doc>
			</param>
			<param name="hit" type="PhysicsQueryHit">
				<doc>Information recorded about a hit. Only valid if method returns true.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="bool">
				<doc>True if something was hit, false otherwise.</doc>
			</returns>
		</method>
		<method native="rayCast" script="RayCast" static="false">
			<doc>Casts a ray into the scene and returns the closest found hit, if any.</doc>
			<param name="origin" type="Vector3">
				<doc>Origin of the ray to cast into the scene.</doc>
			</param>
			<param name="unitDir" type="Vector3">
				<doc>Unit direction of the ray to cast into the scene.</doc>
			</param>
			<param name="hit" type="PhysicsQueryHit">
				<doc>Information recorded about a hit. Only valid if method returns true.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="bool">
				<doc>True if something was hit, false otherwise.</doc>
			</returns>
		</method>
		<method native="boxCast" script="BoxCast" static="false">
			<doc>Performs a sweep into the scene using a box and returns the closest found hit, if any.</doc>
			<param name="box" type="AABox">
				<doc>Box to sweep through the scene.</doc>
			</param>
			<param name="rotation" type="Quaternion">
				<doc>Orientation of the box.</doc>
			</param>
			<param name="unitDir" type="Vector3">
				<doc>Unit direction towards which to perform the sweep.</doc>
			</param>
			<param name="hit" type="PhysicsQueryHit">
				<doc>Information recorded about a hit. Only valid if method returns true.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="bool">
				<doc>True if something was hit, false otherwise.</doc>
			</returns>
		</method>
		<method native="sphereCast" script="SphereCast" static="false">
			<doc>Performs a sweep into the scene using a sphere and returns the closest found hit, if any.</doc>
			<param name="sphere" type="Sphere">
				<doc>Sphere to sweep through the scene.</doc>
			</param>
			<param name="unitDir" type="Vector3">
				<doc>Unit direction towards which to perform the sweep.</doc>
			</param>
			<param name="hit" type="PhysicsQueryHit">
				<doc>Information recorded about a hit. Only valid if method returns true.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="bool">
				<doc>True if something was hit, false otherwise.</doc>
			</returns>
		</method>
		<method native="capsuleCast" script="CapsuleCast" static="false">
			<doc>Performs a sweep into the scene using a capsule and returns the closest found hit, if any.</doc>
			<param name="capsule" type="Capsule">
				<doc>Capsule to sweep through the scene.</doc>
			</param>
			<param name="rotation" type="Quaternion">
				<doc>Orientation of the capsule.</doc>
			</param>
			<param name="unitDir" type="Vector3">
				<doc>Unit direction towards which to perform the sweep.</doc>
			</param>
			<param name="hit" type="PhysicsQueryHit">
				<doc>Information recorded about a hit. Only valid if method returns true.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="bool">
				<doc>True if something was hit, false otherwise.</doc>
			</returns>
		</method>
		<method native="convexCast" script="ConvexCast" static="false">
			<doc>Performs a sweep into the scene using a convex mesh and returns the closest found hit, if any.</doc>
			<param name="mesh" type="RRef&lt;PhysicsMesh&gt;">
				<doc>Mesh to sweep through the scene. Must be convex.</doc>
			</param>
			<param name="position" type="Vector3">
				<doc>Starting position of the mesh.</doc>
			</param>
			<param name="rotation" type="Quaternion">
				<doc>Orientation of the mesh.</doc>
			</param>
			<param name="unitDir" type="Vector3">
				<doc>Unit direction towards which to perform the sweep.</doc>
			</param>
			<param name="hit" type="PhysicsQueryHit">
				<doc>Information recorded about a hit. Only valid if method returns true.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="bool">
				<doc>True if something was hit, false otherwise.</doc>
			</returns>
		</method>
		<method native="rayCastAll" script="RayCastAll" static="false">
			<doc>Casts a ray into the scene and returns all found hits.</doc>
			<param name="ray" type="Ray">
				<doc>Ray to cast into the scene.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="PhysicsQueryHit">
				<doc>List of all detected hits.</doc>
			</returns>
		</method>
		<method native="rayCastAll" script="RayCastAll" static="false">
			<doc>Casts a ray into the scene and returns all found hits.</doc>
			<param name="origin" type="Vector3">
				<doc>Origin of the ray to cast into the scene.</doc>
			</param>
			<param name="unitDir" type="Vector3">
				<doc>Unit direction of the ray to cast into the scene.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="PhysicsQueryHit">
				<doc>List of all detected hits.</doc>
			</returns>
		</method>
		<method native="boxCastAll" script="BoxCastAll" static="false">
			<doc>Performs a sweep into the scene using a box and returns all found hits.</doc>
			<param name="box" type="AABox">
				<doc>Box to sweep through the scene.</doc>
			</param>
			<param name="rotation" type="Quaternion">
				<doc>Orientation of the box.</doc>
			</param>
			<param name="unitDir" type="Vector3">
				<doc>Unit direction towards which to perform the sweep.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="PhysicsQueryHit">
				<doc>List of all detected hits.</doc>
			</returns>
		</method>
		<method native="sphereCastAll" script="SphereCastAll" static="false">
			<doc>Performs a sweep into the scene using a sphere and returns all found hits.</doc>
			<param name="sphere" type="Sphere">
				<doc>Sphere to sweep through the scene.</doc>
			</param>
			<param name="unitDir" type="Vector3">
				<doc>Unit direction towards which to perform the sweep.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="PhysicsQueryHit">
				<doc>List of all detected hits.</doc>
			</returns>
		</method>
		<method native="capsuleCastAll" script="CapsuleCastAll" static="false">
			<doc>Performs a sweep into the scene using a capsule and returns all found hits.</doc>
			<param name="capsule" type="Capsule">
				<doc>Capsule to sweep through the scene.</doc>
			</param>
			<param name="rotation" type="Quaternion">
				<doc>Orientation of the capsule.</doc>
			</param>
			<param name="unitDir" type="Vector3">
				<doc>Unit direction towards which to perform the sweep.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="PhysicsQueryHit">
				<doc>List of all detected hits.</doc>
			</returns>
		</method>
		<method native="convexCastAll" script="ConvexCastAll" static="false">
			<doc>Performs a sweep into the scene using a convex mesh and returns all found hits.</doc>
			<param name="mesh" type="RRef&lt;PhysicsMesh&gt;">
				<doc>Mesh to sweep through the scene. Must be convex.</doc>
			</param>
			<param name="position" type="Vector3">
				<doc>Starting position of the mesh.</doc>
			</param>
			<param name="rotation" type="Quaternion">
				<doc>Orientation of the mesh.</doc>
			</param>
			<param name="unitDir" type="Vector3">
				<doc>Unit direction towards which to perform the sweep.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="PhysicsQueryHit">
				<doc>List of all detected hits.</doc>
			</returns>
		</method>
		<method native="rayCastAny" script="RayCastAny" static="false">
			<doc>Casts a ray into the scene and checks if it has hit anything. This can be significantly more efficient than other types of cast* calls.</doc>
			<param name="ray" type="Ray">
				<doc>Ray to cast into the scene.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="bool">
				<doc>True if something was hit, false otherwise.</doc>
			</returns>
		</method>
		<method native="rayCastAny" script="RayCastAny" static="false">
			<doc>Casts a ray into the scene and checks if it has hit anything. This can be significantly more efficient than other types of cast* calls.</doc>
			<param name="origin" type="Vector3">
				<doc>Origin of the ray to cast into the scene.</doc>
			</param>
			<param name="unitDir" type="Vector3">
				<doc>Unit direction of the ray to cast into the scene.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="bool">
				<doc>True if something was hit, false otherwise.</doc>
			</returns>
		</method>
		<method native="boxCastAny" script="BoxCastAny" static="false">
			<doc>Performs a sweep into the scene using a box and checks if it has hit anything. This can be significantly more efficient than other types of cast* calls.</doc>
			<param name="box" type="AABox">
				<doc>Box to sweep through the scene.</doc>
			</param>
			<param name="rotation" type="Quaternion">
				<doc>Orientation of the box.</doc>
			</param>
			<param name="unitDir" type="Vector3">
				<doc>Unit direction towards which to perform the sweep.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="bool">
				<doc>True if something was hit, false otherwise.</doc>
			</returns>
		</method>
		<method native="sphereCastAny" script="SphereCastAny" static="false">
			<doc>Performs a sweep into the scene using a sphere and checks if it has hit anything. This can be significantly more efficient than other types of cast* calls.</doc>
			<param name="sphere" type="Sphere">
				<doc>Sphere to sweep through the scene.</doc>
			</param>
			<param name="unitDir" type="Vector3">
				<doc>Unit direction towards which to perform the sweep.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="bool">
				<doc>True if something was hit, false otherwise.</doc>
			</returns>
		</method>
		<method native="capsuleCastAny" script="CapsuleCastAny" static="false">
			<doc>Performs a sweep into the scene using a capsule and checks if it has hit anything. This can be significantly more efficient than other types of cast* calls.</doc>
			<param name="capsule" type="Capsule">
				<doc>Capsule to sweep through the scene.</doc>
			</param>
			<param name="rotation" type="Quaternion">
				<doc>Orientation of the capsule.</doc>
			</param>
			<param name="unitDir" type="Vector3">
				<doc>Unit direction towards which to perform the sweep.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="bool">
				<doc>True if something was hit, false otherwise.</doc>
			</returns>
		</method>
		<method native="convexCastAny" script="ConvexCastAny" static="false">
			<doc>Performs a sweep into the scene using a convex mesh and checks if it has hit anything. This can be significantly more efficient than other types of cast* calls.</doc>
			<param name="mesh" type="RRef&lt;PhysicsMesh&gt;">
				<doc>Mesh to sweep through the scene. Must be convex.</doc>
			</param>
			<param name="position" type="Vector3">
				<doc>Starting position of the mesh.</doc>
			</param>
			<param name="rotation" type="Quaternion">
				<doc>Orientation of the mesh.</doc>
			</param>
			<param name="unitDir" type="Vector3">
				<doc>Unit direction towards which to perform the sweep.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<param name="max" type="float">
				<doc>Maximum distance at which to perform the query. Hits past this distance will not be detected.</doc>
			</param>
			<returns type="bool">
				<doc>True if something was hit, false otherwise.</doc>
			</returns>
		</method>
		<method native="boxOverlap" script="BoxOverlap" static="false">
			<doc>Returns a list of all colliders in the scene that overlap the provided box.</doc>
			<param name="box" type="AABox">
				<doc>Box to check for overlap.</doc>
			</param>
			<param name="rotation" type="Quaternion">
				<doc>Orientation of the box.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<returns type="Collider">
				<doc>List of all colliders that overlap the box.</doc>
			</returns>
		</method>
		<method native="sphereOverlap" script="SphereOverlap" static="false">
			<doc>Returns a list of all colliders in the scene that overlap the provided sphere.</doc>
			<param name="sphere" type="Sphere">
				<doc>Sphere to check for overlap.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<returns type="Collider">
				<doc>List of all colliders that overlap the sphere.</doc>
			</returns>
		</method>
		<method native="capsuleOverlap" script="CapsuleOverlap" static="false">
			<doc>Returns a list of all colliders in the scene that overlap the provided capsule.</doc>
			<param name="capsule" type="Capsule">
				<doc>Capsule to check for overlap.</doc>
			</param>
			<param name="rotation" type="Quaternion">
				<doc>Orientation of the capsule.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<returns type="Collider">
				<doc>List of all colliders that overlap the capsule.</doc>
			</returns>
		</method>
		<method native="convexOverlap" script="ConvexOverlap" static="false">
			<doc>Returns a list of all colliders in the scene that overlap the provided convex mesh.</doc>
			<param name="mesh" type="RRef&lt;PhysicsMesh&gt;">
				<doc>Mesh to check for overlap. Must be convex.</doc>
			</param>
			<param name="position" type="Vector3">
				<doc>Position of the mesh.</doc>
			</param>
			<param name="rotation" type="Quaternion">
				<doc>Orientation of the mesh.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<returns type="Collider">
				<doc>List of all colliders that overlap the mesh.</doc>
			</returns>
		</method>
		<method native="boxOverlapAny" script="BoxOverlapAny" static="false">
			<doc>Checks if the provided box overlaps any other collider in the scene.</doc>
			<param name="box" type="AABox">
				<doc>Box to check for overlap.</doc>
			</param>
			<param name="rotation" type="Quaternion">
				<doc>Orientation of the box.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<returns type="bool">
				<doc>True if there is overlap with another object, false otherwise.</doc>
			</returns>
		</method>
		<method native="sphereOverlapAny" script="SphereOverlapAny" static="false">
			<doc>Checks if the provided sphere overlaps any other collider in the scene.</doc>
			<param name="sphere" type="Sphere">
				<doc>Sphere to check for overlap.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<returns type="bool">
				<doc>True if there is overlap with another object, false otherwise.</doc>
			</returns>
		</method>
		<method native="capsuleOverlapAny" script="CapsuleOverlapAny" static="false">
			<doc>Checks if the provided capsule overlaps any other collider in the scene.</doc>
			<param name="capsule" type="Capsule">
				<doc>Capsule to check for overlap.</doc>
			</param>
			<param name="rotation" type="Quaternion">
				<doc>Orientation of the capsule.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<returns type="bool">
				<doc>True if there is overlap with another object, false otherwise.</doc>
			</returns>
		</method>
		<method native="convexOverlapAny" script="ConvexOverlapAny" static="false">
			<doc>Checks if the provided convex mesh overlaps any other collider in the scene.</doc>
			<param name="mesh" type="RRef&lt;PhysicsMesh&gt;">
				<doc>Mesh to check for overlap. Must be convex.</doc>
			</param>
			<param name="position" type="Vector3">
				<doc>Position of the mesh.</doc>
			</param>
			<param name="rotation" type="Quaternion">
				<doc>Orientation of the mesh.</doc>
			</param>
			<param name="layer" type="ulong">
				<doc>Layers to consider for the query. This allows you to ignore certain groups of objects.</doc>
			</param>
			<returns type="bool">
				<doc>True if there is overlap with another object, false otherwise.</doc>
			</returns>
		</method>
		<method native="addBroadPhaseRegion" script="AddPhysicsRegion" static="false">
			<doc>Adds a new physics region. Certain physics options require you to set up regions in which physics objects are allowed to be in, and objects outside of these regions will not be handled by physics. You do not need to set up these regions by default.</doc>
			<param name="region" type="AABox">
			</param>
			<returns type="int">
			</returns>
		</method>
		<method native="removeBroadPhaseRegion" script="RemovePhysicsRegion" static="false">
			<doc>Removes a physics region.</doc>
			<param name="handle" type="int">
			</param>
		</method>
		<method native="clearBroadPhaseRegions" script="ClearPhysicsRegions" static="false">
			<doc>Removes all physics regions.</doc>
		</method>
		<property name="Gravity" type="Vector3" getter="getGravity" setter="setGravity" static="false">
			<doc>Determines the global gravity value for all objects in the scene.</doc>
		</property>
	</class>
	<class native="PhysicsMaterial" script="PhysicsMaterial">
		<doc>Material that controls how two physical objects interact with each other. Materials of both objects are used during their interaction and their combined values are used.</doc>
		<ctor>
			<doc>Creates a new physics material.</doc>
			<param name="staticFriction" type="float">
				<doc>Controls friction when two in-contact objects are not moving lateral to each other (for example how difficult is to get an object moving from a static state while it is in contact other object(s)).</doc>
			</param>
			<param name="dynamicFriction" type="float">
				<doc>Sets dynamic friction of the material. Controls friction when two in-contact objects are moving lateral to each other (for example how quickly does an object slow down when sliding along another object).</doc>
			</param>
			<param name="restitution" type="float">
				<doc>Controls &quot;bounciness&quot; of an object during a collision. Value of 1 means the collision is elastic, and value of 0 means the value is inelastic. Must be in [0, 1] range.</doc>
			</param>
		</ctor>
		<property name="StaticFriction" type="float" getter="getStaticFriction" setter="setStaticFriction" static="false">
			<doc>Controls friction when two in-contact objects are not moving lateral to each other (for example how difficult it is to get an object moving from a static state while it is in contact with other object(s)).</doc>
		</property>
		<property name="DynamicFriction" type="float" getter="getDynamicFriction" setter="setDynamicFriction" static="false">
			<doc>Controls friction when two in-contact objects are moving lateral to each other (for example how quickly does an object slow down when sliding along another object).</doc>
		</property>
		<property name="Restitution" type="float" getter="getRestitutionCoefficient" setter="setRestitutionCoefficient" static="false">
			<doc>Controls &quot;bounciness&quot; of an object during a collision. Value of 1 means the collision is elastic, and value of 0 means the value is inelastic. Must be in [0, 1] range.</doc>
		</property>
	</class>
	<enum native="ResourceLoadFlag" script="ResourceLoadFlag">
		<doc>Flags that can be used to control resource loading.</doc>
		<enumentry native="None" script="None">
			<doc>No flags.</doc>
		</enumentry>
		<enumentry native="LoadDependencies" script="LoadDependencies">
			<doc>If enabled all resources referenced by the root resource will be loaded as well.</doc>
		</enumentry>
		<enumentry native="KeepInternalRef" script="KeepInternalRef">
			<doc>If enabled the resource system will keep an internal reference to the resource so it doesn&apos;t get destroyed when it goes out of scope. You can call Resources::release() to release the internal reference. Each call to load will create a new internal reference and therefore must be followed by the same number of release calls. If dependencies are being loaded, they will not have internal references created regardless of this parameter.</doc>
		</enumentry>
		<enumentry native="KeepSourceData" script="KeepSourceData">
			<doc>Determines if the loaded resource keeps original data loaded. Sometime resources will process loaded data and discard the original (e.g. uncompressing audio on load). This flag can prevent the resource from discarding the original data. The original data might be required for saving the resource (via Resources::save), but will use up extra memory. Normally you want to keep this enabled if you plan on saving the resource to disk.</doc>
		</enumentry>
		<enumentry native="Default" script="Default">
			<doc>Default set of flags used for resource loading.</doc>
		</enumentry>
	</enum>
	<class native="Resources" script="Resources">
		<doc>Manager for dealing with all engine resources. It allows you to save new resources and load existing ones.</doc>
		<method native="load" script="Load" static="false">
			<doc>Loads the resource from a given path. Returns an empty handle if resource can&apos;t be loaded. Resource is loaded synchronously.</doc>
			<param name="filePath" type="string">
				<doc>File path to the resource to load. This can be absolute or relative to the working folder.</doc>
			</param>
			<param name="loadFlags" type="ResourceLoadFlag">
				<doc>Flags used to control the load process.</doc>
			</param>
			<returns type="Resource">
			</returns>
		</method>
		<method native="loadAsync" script="LoadAsync" static="false">
			<doc>Loads the resource asynchronously. Initially returned resource handle will be invalid until resource loading is done. Use ResourceHandle&lt;T&gt;::isLoaded to check if resource has been loaded, or ResourceHandle&lt;T&gt;::blockUntilLoaded to wait until load completes.</doc>
			<param name="filePath" type="string">
				<doc>Full pathname of the file.</doc>
			</param>
			<param name="loadFlags" type="ResourceLoadFlag">
				<doc>Flags used to control the load process.</doc>
			</param>
			<returns type="RRefBase">
			</returns>
		</method>
		<method native="loadFromUUID" script="LoadFromUUID" static="false">
			<doc>Loads the resource with the given UUID. Returns an empty handle if resource can&apos;t be loaded.</doc>
			<param name="uuid" type="UUID">
				<doc>UUID of the resource to load.</doc>
			</param>
			<param name="async" type="bool">
				<doc>If true resource will be loaded asynchronously. Handle to non-loaded resource will be returned immediately while loading will continue in the background.</doc>
			</param>
			<param name="loadFlags" type="ResourceLoadFlag">
				<doc>Flags used to control the load process.</doc>
			</param>
			<returns type="RRefBase">
			</returns>
		</method>
		<method native="release" script="Release" static="false">
			<doc>Releases an internal reference to the resource held by the resources system. This allows the resource to be unloaded when it goes out of scope, if the resource was loaded with <see cref="keepInternalReference"/> parameter.
Alternatively you can also skip manually calling release() and call unloadAllUnused() which will unload all resources that do not have any external references, but you lose the fine grained control of what will be unloaded.</doc>
			<param name="resource" type="RRefBase">
				<doc>Handle of the resource to release.</doc>
			</param>
		</method>
		<method native="unloadAllUnused" script="UnloadAllUnused" static="false">
			<doc>Finds all resources that aren&apos;t being referenced outside of the resources system and unloads them.</doc>
		</method>
		<method native="unloadAll" script="UnloadAll" static="false">
			<doc>Forces unload of all resources, whether they are being used or not.</doc>
		</method>
		<method native="save" script="Save" static="false">
			<doc>Saves the resource at the specified location.</doc>
			<param name="resource" type="Resource">
				<doc>Handle to the resource.</doc>
			</param>
			<param name="filePath" type="string">
				<doc>Full pathname of the file to save as.</doc>
			</param>
			<param name="overwrite" type="bool">
				<doc>If true, any existing resource at the specified location will be overwritten.</doc>
			</param>
			<param name="compress" type="bool">
				<doc>Should the resource be compressed before saving. Some resources have data that is already compressed and this option will be ignored for such resources.</doc>
			</param>
		</method>
		<method native="save" script="Save" static="false">
			<doc>Saves an existing resource to its previous location.</doc>
			<param name="resource" type="Resource">
				<doc>Handle to the resource.</doc>
			</param>
			<param name="compress" type="bool">
				<doc>Should the resource be compressed before saving. Some resources have data that is already compressed and this option will be ignored for such resources.</doc>
			</param>
		</method>
		<method native="getDependencies" script="GetDependencies" static="false">
			<doc>Returns a list of dependencies from the resources at the specified path. Resource will not be loaded or parsed, but instead the saved list of dependencies will be read from the file and returned.</doc>
			<param name="filePath" type="string">
				<doc>Full path to the resource to get dependencies for.</doc>
			</param>
			<returns type="UUID">
				<doc>List of dependencies represented as UUIDs.</doc>
			</returns>
		</method>
		<method native="isLoaded" script="IsLoaded" static="false">
			<doc>Checks is the resource with the specified UUID loaded.</doc>
			<param name="uuid" type="UUID">
				<doc>UUID of the resource to check.</doc>
			</param>
			<param name="checkInProgress" type="bool">
				<doc>Should this method also check resources that are in progress of being asynchronously loaded.</doc>
			</param>
			<returns type="bool">
				<doc>True if loaded or loading in progress, false otherwise.</doc>
			</returns>
		</method>
		<method native="getLoadProgress" script="GetLoadProgress" static="false">
			<doc>Returns the loading progress of a resource that&apos;s being asynchronously loaded.</doc>
			<param name="resource" type="RRefBase">
				<doc>Resource whose load progress to check.</doc>
			</param>
			<param name="includeDependencies" type="bool">
				<doc>If false the progress will reflect the load progress only for this inidividual resource. If true the progress will reflect load progress of this resource and all of its dependencies.</doc>
			</param>
			<returns type="float">
				<doc>Load progress in range [0, 1].</doc>
			</returns>
		</method>
		<method native="registerResourceManifest" script="RegisterResourceManifest" static="false">
			<doc>Allows you to set a resource manifest containing UUID &lt;-&gt; file path mapping that is used when resolving resource references.</doc>
			<param name="manifest" type="ResourceManifest">
			</param>
		</method>
		<method native="unregisterResourceManifest" script="UnregisterResourceManifest" static="false">
			<doc>Unregisters a resource manifest previously registered with registerResourceManifest().</doc>
			<param name="manifest" type="ResourceManifest">
			</param>
		</method>
		<method native="getResourceManifest" script="GetResourceManifest" static="false">
			<doc>Allows you to retrieve resource manifest containing UUID &lt;-&gt; file path mapping that is used when resolving resource references.</doc>
			<param name="name" type="string">
			</param>
			<returns type="ResourceManifest">
			</returns>
		</method>
		<method native="getFilePathFromUUID" script="GetFilePathFromUUID" static="false">
			<doc>Attempts to retrieve file path from the provided UUID. Returns true if successful, false otherwise.</doc>
			<param name="uuid" type="UUID">
			</param>
			<param name="filePath" type="string">
			</param>
			<returns type="bool">
			</returns>
		</method>
		<method native="getUUIDFromFilePath" script="GetUUIDFromFilePath" static="false">
			<doc>Attempts to retrieve UUID from the provided file path. Returns true if successful, false otherwise.</doc>
			<param name="path" type="string">
			</param>
			<param name="uuid" type="UUID">
			</param>
			<returns type="bool">
			</returns>
		</method>
		<event native="onResourceLoaded" script="OnResourceLoaded" static="false">
			<doc>Called when the resource has been successfully loaded.</doc>
			<param name="p0" type="RRefBase">
			</param>
		</event>
		<event native="onResourceDestroyed" script="OnResourceDestroyed" static="false">
			<doc>Called when the resource has been destroyed. Provides UUID of the destroyed resource.</doc>
			<param name="p0" type="UUID">
			</param>
		</event>
		<event native="onResourceModified" script="OnResourceModified" static="false">
			<doc>Called when the internal resource the handle is pointing to has changed.</doc>
			<param name="p0" type="RRefBase">
			</param>
		</event>
	</class>
	<struct native="KerningPair" script="KerningPair">
		<doc>Kerning pair representing larger or smaller offset between a specific pair of characters.</doc>
		<field name="otherCharId" type="int">
		</field>
		<field name="amount" type="int">
		</field>
	</struct>
	<struct native="CharDesc" script="CharDesc">
		<doc>Describes a single character in a font of a specific size.</doc>
		<field name="charId" type="int">
			<doc>Character ID, corresponding to a Unicode key.</doc>
		</field>
		<field name="page" type="int">
			<doc>Index of the texture the character is located on.</doc>
		</field>
		<field name="uvX" type="float">
			<doc>Texture coordinates of the character in the page texture.</doc>
		</field>
		<field name="uvY" type="float">
			<doc>Texture coordinates of the character in the page texture.</doc>
		</field>
		<field name="uvWidth" type="float">
			<doc>Width/height of the character in texture coordinates.</doc>
		</field>
		<field name="uvHeight" type="float">
			<doc>Width/height of the character in texture coordinates.</doc>
		</field>
		<field name="width" type="int">
			<doc>Width/height of the character in pixels.</doc>
		</field>
		<field name="height" type="int">
			<doc>Width/height of the character in pixels.</doc>
		</field>
		<field name="xOffset" type="int">
			<doc>Offset for the visible portion of the character in pixels.</doc>
		</field>
		<field name="yOffset" type="int">
			<doc>Offset for the visible portion of the character in pixels.</doc>
		</field>
		<field name="xAdvance" type="int">
			<doc>Determines how much to advance the pen after writing this character, in pixels.</doc>
		</field>
		<field name="yAdvance" type="int">
			<doc>Determines how much to advance the pen after writing this character, in pixels.</doc>
		</field>
		<field name="kerningPairs" type="KerningPair">
			<doc>Pairs that determine if certain character pairs should be closer or father together. for example &quot;AV&quot; combination.</doc>
		</field>
	</struct>
	<class native="Font" script="Font">
		<doc>Font resource containing data about textual characters and how to render text. Contains one or multiple font bitmaps, each for a specific size.</doc>
		<method native="getBitmap" script="GetBitmap" static="false">
			<doc>Returns font bitmap for a specific font size.</doc>
			<param name="size" type="int">
				<doc>Size of the bitmap in points.</doc>
			</param>
			<returns type="FontBitmap">
				<doc>Bitmap object if it exists, false otherwise.</doc>
			</returns>
		</method>
		<method native="getClosestSize" script="GetClosestSize" static="false">
			<doc>Finds the available font bitmap size closest to the provided size.</doc>
			<param name="size" type="int">
				<doc>Size of the bitmap in points.</doc>
			</param>
			<returns type="int">
				<doc>Nearest available bitmap size.</doc>
			</returns>
		</method>
	</class>
	<struct native="CharRange" script="CharRange">
		<doc>Represents a range of character code.</doc>
		<ctor>
		</ctor>
		<ctor>
			<param name="start" type="int">
			</param>
			<param name="end" type="int">
			</param>
		</ctor>
		<field name="start" type="int">
		</field>
		<field name="end" type="int">
		</field>
	</struct>
	<class native="FontImportOptions" script="FontImportOptions">
		<doc>Import options that allow you to control how is a font imported.</doc>
		<ctor>
			<doc>Creates a new import options object that allows you to customize how are fonts imported.</doc>
		</ctor>
		<property name="FontSizes" type="int" getter="getfontSizes" setter="setfontSizes" static="false">
			<doc>Determines font sizes that are to be imported. Sizes are in points.</doc>
		</property>
		<property name="CharIndexRanges" type="CharRange" getter="getcharIndexRanges" setter="setcharIndexRanges" static="false">
			<doc>Determines character index ranges to import. Ranges are defined as unicode numbers.</doc>
		</property>
		<property name="Dpi" type="int" getter="getdpi" setter="setdpi" static="false">
			<doc>Determines dots per inch scale that will be used when rendering the characters.</doc>
		</property>
		<property name="RenderMode" type="FontRenderMode" getter="getrenderMode" setter="setrenderMode" static="false">
			<doc>Determines the render mode used for rendering the characters into a bitmap.</doc>
		</property>
		<property name="Bold" type="bool" getter="getbold" setter="setbold" static="false">
			<doc>Determines whether the bold font style should be used when rendering.</doc>
		</property>
		<property name="Italic" type="bool" getter="getitalic" setter="setitalic" static="false">
			<doc>Determines whether the italic font style should be used when rendering.</doc>
		</property>
	</class>
	<enum native="TextHorzAlign" script="TextHorzAlign">
		<doc>Specifies how is text horizontally aligned within its bounds.</doc>
		<enumentry native="THA_Left" script="Left">
		</enumentry>
		<enumentry native="THA_Center" script="Center">
		</enumentry>
		<enumentry native="THA_Right" script="Right">
		</enumentry>
	</enum>
	<enum native="TextVertAlign" script="TextVertAlign">
		<doc>Specifies how is text vertically aligned within its bounds.</doc>
		<enumentry native="TVA_Top" script="Top">
		</enumentry>
		<enumentry native="TVA_Center" script="Center">
		</enumentry>
		<enumentry native="TVA_Bottom" script="Bottom">
		</enumentry>
	</enum>
	<enum native="GUIElementState" script="GUIElementState">
		<doc>Type of GUI element states.</doc>
		<enumentry native="HoverOn" script="HoverOn">
			<doc>Same as Hover, if the element is also in the &quot;on&quot; state.</doc>
		</enumentry>
		<enumentry native="Normal" script="Normal">
			<doc>Normal state when element is not being iteracted with.</doc>
		</enumentry>
		<enumentry native="NormalOn" script="NormalOn">
			<doc>Same as Normal, if the element is also in the &quot;on&quot; state.</doc>
		</enumentry>
		<enumentry native="Hover" script="Hover">
			<doc>State when pointer is hovering over the element.</doc>
		</enumentry>
		<enumentry native="Active" script="Active">
			<doc>State when element is being clicked.</doc>
		</enumentry>
		<enumentry native="FocusedHover" script="FocusedHover">
			<doc>State when the element has input focus and pointer is hovering over the element.</doc>
		</enumentry>
		<enumentry native="Focused" script="Focused">
			<doc>State when the element has input focus and pointer is not hovering over the element.</doc>
		</enumentry>
		<enumentry native="ActiveOn" script="ActiveOn">
			<doc>Same as Active, if the element is also in the &quot;on&quot; state.</doc>
		</enumentry>
		<enumentry native="FocusedOn" script="FocusedOn">
			<doc>Same as Focused, if the element is also in the &quot;on&quot; state.</doc>
		</enumentry>
		<enumentry native="FocusedHoverOn" script="FocusedHoverOn">
			<doc>Same as FocusedHover, if the element is also in the &quot;on&quot; state.</doc>
		</enumentry>
	</enum>
	<struct native="GUIContent" script="GUIContent">
		<doc>Holds data used for displaying content in a GUIElement. Content can consist of a string, image, a tooltip or none of those.</doc>
		<ctor>
			<doc>Constructs an empty content.</doc>
		</ctor>
		<ctor>
			<doc>Constructs content with just a string.</doc>
			<param name="text" type="LocString">
			</param>
		</ctor>
		<ctor>
			<doc>Constructs content with a string and a tooltip.</doc>
			<param name="text" type="LocString">
			</param>
			<param name="tooltip" type="LocString">
			</param>
		</ctor>
		<ctor>
			<doc>Constructs content with just an image.</doc>
			<param name="image" type="GUIContentImages">
			</param>
		</ctor>
		<ctor>
			<doc>Constructs content with an image and a tooltip.</doc>
			<param name="image" type="GUIContentImages">
			</param>
			<param name="tooltip" type="LocString">
			</param>
		</ctor>
		<ctor>
			<doc>Constructs content with a string and an image.</doc>
			<param name="text" type="LocString">
			</param>
			<param name="image" type="GUIContentImages">
			</param>
		</ctor>
		<ctor>
			<doc>Constructs content with a string, an image and a tooltip.</doc>
			<param name="text" type="LocString">
			</param>
			<param name="image" type="GUIContentImages">
			</param>
			<param name="tooltip" type="LocString">
			</param>
		</ctor>
		<field name="text" type="LocString">
		</field>
		<field name="images" type="GUIContentImages">
		</field>
		<field name="tooltip" type="LocString">
		</field>
	</struct>
	<enum native="GUIImagePosition" script="GUIImagePosition">
		<doc>Possible positions used for positioning content image within a GUI element.</doc>
		<enumentry native="Left" script="Left">
		</enumentry>
		<enumentry native="Right" script="Right">
		</enumentry>
	</enum>
	<class native="GUIElementStyle" script="GUIElementStyle">
		<doc>GUI element style that determines the look of a GUI element, as well as the element&apos;s default layout options. Different looks can be provided for different element states.</doc>
		<ctor>
		</ctor>
		<method native="addSubStyle" script="AddSubStyle" static="false">
			<doc>Registers a new sub-style that is used by complex GUI elements that contain one or multiple sub-elements.</doc>
			<param name="guiType" type="string">
				<doc>Name of the sub-element this style is to be used for. This depends on GUI element the style is applied to.</doc>
			</param>
			<param name="styleName" type="string">
				<doc>Name of the style in GUI skin to use for the sub-element.</doc>
			</param>
		</method>
		<property name="Font" type="Font" getter="getfont" setter="setfont" static="false">
			<doc>Font to use for all text within the GUI element.</doc>
		</property>
		<property name="FontSize" type="int" getter="getfontSize" setter="setfontSize" static="false">
			<doc>Font size to use for all text within the GUI element.</doc>
		</property>
		<property name="TextHorzAlign" type="TextHorzAlign" getter="gettextHorzAlign" setter="settextHorzAlign" static="false">
			<doc>Horizontal alignment of text within the GUI element.</doc>
		</property>
		<property name="TextVertAlign" type="TextVertAlign" getter="gettextVertAlign" setter="settextVertAlign" static="false">
			<doc>Vertical alignment of text within the GUI element.</doc>
		</property>
		<property name="ImagePosition" type="GUIImagePosition" getter="getimagePosition" setter="setimagePosition" static="false">
			<doc>Position of content image relative to text.</doc>
		</property>
		<property name="WordWrap" type="bool" getter="getwordWrap" setter="setwordWrap" static="false">
			<doc>Should the text word wrap if it doesn&apos;t fit.</doc>
		</property>
		<property name="Normal" type="GUIElementStateStyle" getter="getnormal" setter="setnormal" static="false">
			<doc>Style used when the element doesn&apos;t have focus nor is the user interacting with the element. Used when the element is in the &apos;off&apos; state.</doc>
		</property>
		<property name="Hover" type="GUIElementStateStyle" getter="gethover" setter="sethover" static="false">
			<doc>Style used when the user is hovering the pointer over the element, while the element doesn&apos;t have focus. Used when the element is in the &apos;off&apos; state.</doc>
		</property>
		<property name="Active" type="GUIElementStateStyle" getter="getactive" setter="setactive" static="false">
			<doc>Style used when the user is actively interacting with the element. Used when the element is in the &apos;off&apos; state.</doc>
		</property>
		<property name="Focused" type="GUIElementStateStyle" getter="getfocused" setter="setfocused" static="false">
			<doc>Style used when the element has focus but the pointer is not hovering over the element. Used when the element is in the &apos;off&apos; state.</doc>
		</property>
		<property name="FocusedHover" type="GUIElementStateStyle" getter="getfocusedHover" setter="setfocusedHover" static="false">
			<doc>Style used when the element has focus and the pointer is hovering over the element. Used when the element is in the &apos;off&apos; state.</doc>
		</property>
		<property name="NormalOn" type="GUIElementStateStyle" getter="getnormalOn" setter="setnormalOn" static="false">
			<doc>Same as GUIElementStyle::normal, except it&apos;s used when element is in the &apos;on&apos; state.</doc>
		</property>
		<property name="HoverOn" type="GUIElementStateStyle" getter="gethoverOn" setter="sethoverOn" static="false">
			<doc>Same as GUIElementStyle::hover, except it&apos;s used when element is in the &apos;on&apos; state.</doc>
		</property>
		<property name="ActiveOn" type="GUIElementStateStyle" getter="getactiveOn" setter="setactiveOn" static="false">
			<doc>Same as GUIElementStyle::active, except it&apos;s used when element is in the &apos;on&apos; state.</doc>
		</property>
		<property name="FocusedOn" type="GUIElementStateStyle" getter="getfocusedOn" setter="setfocusedOn" static="false">
			<doc>Same as GUIElementStyle::focused, except it&apos;s used when element is in the &apos;on&apos; state.</doc>
		</property>
		<property name="FocusedHoverOn" type="GUIElementStateStyle" getter="getfocusedHoverOn" setter="setfocusedHoverOn" static="false">
			<doc>Same as GUIElementStyle::focusedHover, except it&apos;s used when element is in the &apos;on&apos; state.</doc>
		</property>
		<property name="Border" type="RectOffset" getter="getborder" setter="setborder" static="false">
			<doc>Determines how the element is scaled (using the typical Scale9Grid approach).</doc>
		</property>
		<property name="Margins" type="RectOffset" getter="getmargins" setter="setmargins" static="false">
			<doc>Determines offset from the background graphics to the content. Input uses bounds offset by this value.</doc>
		</property>
		<property name="ContentOffset" type="RectOffset" getter="getcontentOffset" setter="setcontentOffset" static="false">
			<doc>Additional offset to the content, that doesn&apos;t effect the bounds. Applied on top of the margins offsets.</doc>
		</property>
		<property name="Padding" type="RectOffset" getter="getpadding" setter="setpadding" static="false">
			<doc>Determines extra distance between this and other elements in a layout.</doc>
		</property>
		<property name="Width" type="int" getter="getwidth" setter="setwidth" static="false">
			<doc>Wanted width of the GUI element in pixels. Only used if fixedWidth is enabled.</doc>
		</property>
		<property name="Height" type="int" getter="getheight" setter="setheight" static="false">
			<doc>Wanted height of the GUI element in pixels. Only used if fixedHeight is enabled.</doc>
		</property>
		<property name="MinWidth" type="int" getter="getminWidth" setter="setminWidth" static="false">
			<doc>Minimum width allowed for the GUI element. Used by the layout only when exact width is not specified.</doc>
		</property>
		<property name="MaxWidth" type="int" getter="getmaxWidth" setter="setmaxWidth" static="false">
			<doc>Maximum width allowed for the GUI element. Used by the layout only when exact width is not specified.</doc>
		</property>
		<property name="MinHeight" type="int" getter="getminHeight" setter="setminHeight" static="false">
			<doc>Minimum height allowed for the GUI element. Used by the layout only when exact height is not specified.</doc>
		</property>
		<property name="MaxHeight" type="int" getter="getmaxHeight" setter="setmaxHeight" static="false">
			<doc>Maximum height allowed for the GUI element. Used by the layout only when exact height is not specified.</doc>
		</property>
		<property name="FixedWidth" type="bool" getter="getfixedWidth" setter="setfixedWidth" static="false">
			<doc>Determines should the layout resize the element depending on available size. If true no resizing will be done.</doc>
		</property>
		<property name="FixedHeight" type="bool" getter="getfixedHeight" setter="setfixedHeight" static="false">
			<doc>Determines should the layout resize the element depending on available size. If true no resizing will be done.</doc>
		</property>
	</class>
	<class native="GUISkin" script="GUISkin">
		<doc>Holds a set of styles that control how are GUI element types positioned and displayed in the GUI. Each element type can be assigned a specific style.</doc>
		<method native="hasStyle" script="HasStyle" static="false">
			<doc>Checks if the style with the specified name exists.</doc>
			<param name="name" type="string">
			</param>
			<returns type="bool">
			</returns>
		</method>
		<method native="getStyle" script="GetStyle" static="false">
			<doc>Returns a style for the specified GUI element type.</doc>
			<param name="guiElemType" type="string">
			</param>
			<returns type="GUIElementStyle">
			</returns>
		</method>
		<method native="setStyle" script="SetStyle" static="false">
			<doc>Sets a style for the specified GUI element type.</doc>
			<param name="guiElemType" type="string">
			</param>
			<param name="style" type="GUIElementStyle">
			</param>
		</method>
		<method native="removeStyle" script="RemoveStyle" static="false">
			<doc>Removes a style for the specified GUI element type.</doc>
			<param name="guiElemType" type="string">
			</param>
		</method>
		<ctor>
			<doc>Creates an empty GUI skin and returns a handle to it.</doc>
		</ctor>
		<property name="StyleNames" type="string" getter="getStyleNames" setter="" static="false">
			<doc>Returns names of all styles registered on this skin.</doc>
		</property>
	</class>
	<enum native="BuiltinShader" script="BuiltinShader">
		<doc>Types of builtin shaders that are always available.</doc>
		<enumentry native="Custom" script="Custom">
		</enumentry>
		<enumentry native="Standard" script="Standard">
			<doc>Physically based shader used for opaque 3D geometry.</doc>
		</enumentry>
		<enumentry native="Transparent" script="Transparent">
			<doc>Physically based shader used for transparent 3D geometry.</doc>
		</enumentry>
		<enumentry native="ParticlesUnlit" script="ParticlesUnlit">
			<doc>Special shader used for rendering particles without any lighting, with support for transparency.</doc>
		</enumentry>
		<enumentry native="ParticlesLit" script="ParticlesLit">
			<doc>Special shader used for rendering particles with lighting using the forward rendering pipeline (supports transparency).</doc>
		</enumentry>
		<enumentry native="ParticlesLitOpaque" script="ParticlesLitOpaque">
			<doc>Special shader used for rendering particles with lighting using the deferred rendering pipeline (no support for transparency).</doc>
		</enumentry>
		<enumentry native="Decal" script="Decal">
			<doc>Special shader used for rendering decals that project onto other geometry.</doc>
		</enumentry>
	</enum>
	<enum native="ShaderParameterType" script="ShaderParameterType">
		<doc>Type of parameters that can be defined by a shader.</doc>
		<enumentry native="Texture3D" script="Texture3D">
		</enumentry>
		<enumentry native="Float" script="Float">
		</enumentry>
		<enumentry native="Vector2" script="Vector2">
		</enumentry>
		<enumentry native="Vector3" script="Vector3">
		</enumentry>
		<enumentry native="Vector4" script="Vector4">
		</enumentry>
		<enumentry native="Color" script="Color">
		</enumentry>
		<enumentry native="Matrix3" script="Matrix3">
		</enumentry>
		<enumentry native="Matrix4" script="Matrix4">
		</enumentry>
		<enumentry native="Texture2D" script="Texture2D">
		</enumentry>
		<enumentry native="TextureCube" script="TextureCube">
		</enumentry>
		<enumentry native="Sampler" script="Sampler">
		</enumentry>
	</enum>
	<struct native="ShaderParameter" script="ShaderParameter">
		<doc>Contains information about a single shader parameter.</doc>
		<field name="name" type="string">
			<doc>Name of the parameter variable.</doc>
		</field>
		<field name="identifier" type="string">
			<doc>Variable identifier of the parameter.</doc>
		</field>
		<field name="type" type="ShaderParameterType">
			<doc>Data type of the parameter.</doc>
		</field>
		<field name="flags" type="ShaderParameterFlag">
			<doc>Flags used to further describe the parameter.</doc>
		</field>
	</struct>
</entries>
